"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
!function (a, b) { "object" == typeof module && "object" == typeof module.exports ? module.exports = a.document ? b(a, !0) : function (a) { if (!a.document)
    throw new Error("jQuery requires a window with a document"); return b(a); } : b(a); }("undefined" != typeof window ? window : this, function (a, b) {
    var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = {}, l = "1.11.1", m = function (a, b) { return new m.fn.init(a, b); }, n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, o = /^-ms-/, p = /-([\da-z])/gi, q = function (a, b) { return b.toUpperCase(); };
    m.fn = m.prototype = { jquery: l, constructor: m, selector: "", length: 0, toArray: function () { return d.call(this); }, get: function (a) { return null != a ? 0 > a ? this[a + this.length] : this[a] : d.call(this); }, pushStack: function (a) { var b = m.merge(this.constructor(), a); return b.prevObject = this, b.context = this.context, b; }, each: function (a, b) { return m.each(this, a, b); }, map: function (a) { return this.pushStack(m.map(this, function (b, c) { return a.call(b, c, b); })); }, slice: function () { return this.pushStack(d.apply(this, arguments)); }, first: function () { return this.eq(0); }, last: function () { return this.eq(-1); }, eq: function (a) { var b = this.length, c = +a + (0 > a ? b : 0); return this.pushStack(c >= 0 && b > c ? [this[c]] : []); }, end: function () { return this.prevObject || this.constructor(null); }, push: f, sort: c.sort, splice: c.splice }, m.extend = m.fn.extend = function () { var a, b, c, d, e, f, g = arguments[0] || {}, h = 1, i = arguments.length, j = !1; for ("boolean" == typeof g && (j = g, g = arguments[h] || {}, h++), "object" == typeof g || m.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++)
        if (null != (e = arguments[h]))
            for (d in e)
                a = g[d], c = e[d], g !== c && (j && c && (m.isPlainObject(c) || (b = m.isArray(c))) ? (b ? (b = !1, f = a && m.isArray(a) ? a : []) : f = a && m.isPlainObject(a) ? a : {}, g[d] = m.extend(j, f, c)) : void 0 !== c && (g[d] = c)); return g; }, m.extend({ expando: "jQuery" + (l + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (a) { throw new Error(a); }, noop: function () { }, isFunction: function (a) { return "function" === m.type(a); }, isArray: Array.isArray || function (a) { return "array" === m.type(a); }, isWindow: function (a) { return null != a && a == a.window; }, isNumeric: function (a) { return !m.isArray(a) && a - parseFloat(a) >= 0; }, isEmptyObject: function (a) { var b; for (b in a)
            return !1; return !0; }, isPlainObject: function (a) { var b; if (!a || "object" !== m.type(a) || a.nodeType || m.isWindow(a))
            return !1; try {
            if (a.constructor && !j.call(a, "constructor") && !j.call(a.constructor.prototype, "isPrototypeOf"))
                return !1;
        }
        catch (c) {
            return !1;
        } if (k.ownLast)
            for (b in a)
                return j.call(a, b); for (b in a)
            ; return void 0 === b || j.call(a, b); }, type: function (a) { return null == a ? a + "" : "object" == typeof a || "function" == typeof a ? h[i.call(a)] || "object" : typeof a; }, globalEval: function (b) { b && m.trim(b) && (a.execScript || function (b) { a.eval.call(a, b); })(b); }, camelCase: function (a) { return a.replace(o, "ms-").replace(p, q); }, nodeName: function (a, b) { return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase(); }, each: function (a, b, c) { var d, e = 0, f = a.length, g = r(a); if (c) {
            if (g) {
                for (; f > e; e++)
                    if (d = b.apply(a[e], c), d === !1)
                        break;
            }
            else
                for (e in a)
                    if (d = b.apply(a[e], c), d === !1)
                        break;
        }
        else if (g) {
            for (; f > e; e++)
                if (d = b.call(a[e], e, a[e]), d === !1)
                    break;
        }
        else
            for (e in a)
                if (d = b.call(a[e], e, a[e]), d === !1)
                    break; return a; }, trim: function (a) { return null == a ? "" : (a + "").replace(n, ""); }, makeArray: function (a, b) { var c = b || []; return null != a && (r(Object(a)) ? m.merge(c, "string" == typeof a ? [a] : a) : f.call(c, a)), c; }, inArray: function (a, b, c) { var d; if (b) {
            if (g)
                return g.call(b, a, c);
            for (d = b.length, c = c ? 0 > c ? Math.max(0, d + c) : c : 0; d > c; c++)
                if (c in b && b[c] === a)
                    return c;
        } return -1; }, merge: function (a, b) { var c = +b.length, d = 0, e = a.length; while (c > d)
            a[e++] = b[d++]; if (c !== c)
            while (void 0 !== b[d])
                a[e++] = b[d++]; return a.length = e, a; }, grep: function (a, b, c) { for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++)
            d = !b(a[f], f), d !== h && e.push(a[f]); return e; }, map: function (a, b, c) { var d, f = 0, g = a.length, h = r(a), i = []; if (h)
            for (; g > f; f++)
                d = b(a[f], f, c), null != d && i.push(d);
        else
            for (f in a)
                d = b(a[f], f, c), null != d && i.push(d); return e.apply([], i); }, guid: 1, proxy: function (a, b) { var c, e, f; return "string" == typeof b && (f = a[b], b = a, a = f), m.isFunction(a) ? (c = d.call(arguments, 2), e = function () { return a.apply(b || this, c.concat(d.call(arguments))); }, e.guid = a.guid = a.guid || m.guid++, e) : void 0; }, now: function () { return +new Date; }, support: k }), m.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (a, b) { h["[object " + b + "]"] = b.toLowerCase(); });
    function r(a) { var b = a.length, c = m.type(a); return "function" === c || m.isWindow(a) ? !1 : 1 === a.nodeType && b ? !0 : "array" === c || 0 === b || "number" == typeof b && b > 0 && b - 1 in a; }
    var s = function (a) { var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + -new Date, v = a.document, w = 0, x = 0, y = gb(), z = gb(), A = gb(), B = function (a, b) { return a === b && (l = !0), 0; }, C = "undefined", D = 1 << 31, E = {}.hasOwnProperty, F = [], G = F.pop, H = F.push, I = F.push, J = F.slice, K = F.indexOf || function (a) { for (var b = 0, c = this.length; c > b; b++)
        if (this[b] === a)
            return b; return -1; }, L = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", M = "[\\x20\\t\\r\\n\\f]", N = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+", O = N.replace("w", "w#"), P = "\\[" + M + "*(" + N + ")(?:" + M + "*([*^$|!~]?=)" + M + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + O + "))|)" + M + "*\\]", Q = ":(" + N + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + P + ")*)|.*)\\)|)", R = new RegExp("^" + M + "+|((?:^|[^\\\\])(?:\\\\.)*)" + M + "+$", "g"), S = new RegExp("^" + M + "*," + M + "*"), T = new RegExp("^" + M + "*([>+~]|" + M + ")" + M + "*"), U = new RegExp("=" + M + "*([^\\]'\"]*?)" + M + "*\\]", "g"), V = new RegExp(Q), W = new RegExp("^" + O + "$"), X = { ID: new RegExp("^#(" + N + ")"), CLASS: new RegExp("^\\.(" + N + ")"), TAG: new RegExp("^(" + N.replace("w", "w*") + ")"), ATTR: new RegExp("^" + P), PSEUDO: new RegExp("^" + Q), CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + M + "*(even|odd|(([+-]|)(\\d*)n|)" + M + "*(?:([+-]|)" + M + "*(\\d+)|))" + M + "*\\)|)", "i"), bool: new RegExp("^(?:" + L + ")$", "i"), needsContext: new RegExp("^" + M + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + M + "*((?:-\\d)?\\d*)" + M + "*\\)|)(?=[^-]|$)", "i") }, Y = /^(?:input|select|textarea|button)$/i, Z = /^h\d$/i, $ = /^[^{]+\{\s*\[native \w/, _ = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ab = /[+~]/, bb = /'|\\/g, cb = new RegExp("\\\\([\\da-f]{1,6}" + M + "?|(" + M + ")|.)", "ig"), db = function (a, b, c) { var d = "0x" + b - 65536; return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320); }; try {
        I.apply(F = J.call(v.childNodes), v.childNodes), F[v.childNodes.length].nodeType;
    }
    catch (eb) {
        I = { apply: F.length ? function (a, b) { H.apply(a, J.call(b)); } : function (a, b) { var c = a.length, d = 0; while (a[c++] = b[d++])
                ; a.length = c - 1; } };
    } function fb(a, b, d, e) { var f, h, j, k, l, o, r, s, w, x; if ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, d = d || [], !a || "string" != typeof a)
        return d; if (1 !== (k = b.nodeType) && 9 !== k)
        return []; if (p && !e) {
        if (f = _.exec(a))
            if (j = f[1]) {
                if (9 === k) {
                    if (h = b.getElementById(j), !h || !h.parentNode)
                        return d;
                    if (h.id === j)
                        return d.push(h), d;
                }
                else if (b.ownerDocument && (h = b.ownerDocument.getElementById(j)) && t(b, h) && h.id === j)
                    return d.push(h), d;
            }
            else {
                if (f[2])
                    return I.apply(d, b.getElementsByTagName(a)), d;
                if ((j = f[3]) && c.getElementsByClassName && b.getElementsByClassName)
                    return I.apply(d, b.getElementsByClassName(j)), d;
            }
        if (c.qsa && (!q || !q.test(a))) {
            if (s = r = u, w = b, x = 9 === k && a, 1 === k && "object" !== b.nodeName.toLowerCase()) {
                o = g(a), (r = b.getAttribute("id")) ? s = r.replace(bb, "\\$&") : b.setAttribute("id", s), s = "[id='" + s + "'] ", l = o.length;
                while (l--)
                    o[l] = s + qb(o[l]);
                w = ab.test(a) && ob(b.parentNode) || b, x = o.join(",");
            }
            if (x)
                try {
                    return I.apply(d, w.querySelectorAll(x)), d;
                }
                catch (y) { }
                finally {
                    r || b.removeAttribute("id");
                }
        }
    } return i(a.replace(R, "$1"), b, d, e); } function gb() { var a = []; function b(c, e) { return a.push(c + " ") > d.cacheLength && delete b[a.shift()], b[c + " "] = e; } return b; } function hb(a) { return a[u] = !0, a; } function ib(a) { var b = n.createElement("div"); try {
        return !!a(b);
    }
    catch (c) {
        return !1;
    }
    finally {
        b.parentNode && b.parentNode.removeChild(b), b = null;
    } } function jb(a, b) { var c = a.split("|"), e = a.length; while (e--)
        d.attrHandle[c[e]] = b; } function kb(a, b) { var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || D) - (~a.sourceIndex || D); if (d)
        return d; if (c)
        while (c = c.nextSibling)
            if (c === b)
                return -1; return a ? 1 : -1; } function lb(a) { return function (b) { var c = b.nodeName.toLowerCase(); return "input" === c && b.type === a; }; } function mb(a) { return function (b) { var c = b.nodeName.toLowerCase(); return ("input" === c || "button" === c) && b.type === a; }; } function nb(a) { return hb(function (b) { return b = +b, hb(function (c, d) { var e, f = a([], c.length, b), g = f.length; while (g--)
        c[e = f[g]] && (c[e] = !(d[e] = c[e])); }); }); } function ob(a) { return a && typeof a.getElementsByTagName !== C && a; } c = fb.support = {}, f = fb.isXML = function (a) { var b = a && (a.ownerDocument || a).documentElement; return b ? "HTML" !== b.nodeName : !1; }, m = fb.setDocument = function (a) { var b, e = a ? a.ownerDocument || a : v, g = e.defaultView; return e !== n && 9 === e.nodeType && e.documentElement ? (n = e, o = e.documentElement, p = !f(e), g && g !== g.top && (g.addEventListener ? g.addEventListener("unload", function () { m(); }, !1) : g.attachEvent && g.attachEvent("onunload", function () { m(); })), c.attributes = ib(function (a) { return a.className = "i", !a.getAttribute("className"); }), c.getElementsByTagName = ib(function (a) { return a.appendChild(e.createComment("")), !a.getElementsByTagName("*").length; }), c.getElementsByClassName = $.test(e.getElementsByClassName) && ib(function (a) { return a.innerHTML = "<div class='a'></div><div class='a i'></div>", a.firstChild.className = "i", 2 === a.getElementsByClassName("i").length; }), c.getById = ib(function (a) { return o.appendChild(a).id = u, !e.getElementsByName || !e.getElementsByName(u).length; }), c.getById ? (d.find.ID = function (a, b) { if (typeof b.getElementById !== C && p) {
        var c = b.getElementById(a);
        return c && c.parentNode ? [c] : [];
    } }, d.filter.ID = function (a) { var b = a.replace(cb, db); return function (a) { return a.getAttribute("id") === b; }; }) : (delete d.find.ID, d.filter.ID = function (a) { var b = a.replace(cb, db); return function (a) { var c = typeof a.getAttributeNode !== C && a.getAttributeNode("id"); return c && c.value === b; }; }), d.find.TAG = c.getElementsByTagName ? function (a, b) { return typeof b.getElementsByTagName !== C ? b.getElementsByTagName(a) : void 0; } : function (a, b) { var c, d = [], e = 0, f = b.getElementsByTagName(a); if ("*" === a) {
        while (c = f[e++])
            1 === c.nodeType && d.push(c);
        return d;
    } return f; }, d.find.CLASS = c.getElementsByClassName && function (a, b) { return typeof b.getElementsByClassName !== C && p ? b.getElementsByClassName(a) : void 0; }, r = [], q = [], (c.qsa = $.test(e.querySelectorAll)) && (ib(function (a) { a.innerHTML = "<select msallowclip=''><option selected=''></option></select>", a.querySelectorAll("[msallowclip^='']").length && q.push("[*^$]=" + M + "*(?:''|\"\")"), a.querySelectorAll("[selected]").length || q.push("\\[" + M + "*(?:value|" + L + ")"), a.querySelectorAll(":checked").length || q.push(":checked"); }), ib(function (a) { var b = e.createElement("input"); b.setAttribute("type", "hidden"), a.appendChild(b).setAttribute("name", "D"), a.querySelectorAll("[name=d]").length && q.push("name" + M + "*[*^$|!~]?="), a.querySelectorAll(":enabled").length || q.push(":enabled", ":disabled"), a.querySelectorAll("*,:x"), q.push(",.*:"); })), (c.matchesSelector = $.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ib(function (a) { c.disconnectedMatch = s.call(a, "div"), s.call(a, "[s!='']:x"), r.push("!=", Q); }), q = q.length && new RegExp(q.join("|")), r = r.length && new RegExp(r.join("|")), b = $.test(o.compareDocumentPosition), t = b || $.test(o.contains) ? function (a, b) { var c = 9 === a.nodeType ? a.documentElement : a, d = b && b.parentNode; return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d))); } : function (a, b) { if (b)
        while (b = b.parentNode)
            if (b === a)
                return !0; return !1; }, B = b ? function (a, b) { if (a === b)
        return l = !0, 0; var d = !a.compareDocumentPosition - !b.compareDocumentPosition; return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === e || a.ownerDocument === v && t(v, a) ? -1 : b === e || b.ownerDocument === v && t(v, b) ? 1 : k ? K.call(k, a) - K.call(k, b) : 0 : 4 & d ? -1 : 1); } : function (a, b) { if (a === b)
        return l = !0, 0; var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], i = [b]; if (!f || !g)
        return a === e ? -1 : b === e ? 1 : f ? -1 : g ? 1 : k ? K.call(k, a) - K.call(k, b) : 0; if (f === g)
        return kb(a, b); c = a; while (c = c.parentNode)
        h.unshift(c); c = b; while (c = c.parentNode)
        i.unshift(c); while (h[d] === i[d])
        d++; return d ? kb(h[d], i[d]) : h[d] === v ? -1 : i[d] === v ? 1 : 0; }, e) : n; }, fb.matches = function (a, b) { return fb(a, null, null, b); }, fb.matchesSelector = function (a, b) { if ((a.ownerDocument || a) !== n && m(a), b = b.replace(U, "='$1']"), !(!c.matchesSelector || !p || r && r.test(b) || q && q.test(b)))
        try {
            var d = s.call(a, b);
            if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType)
                return d;
        }
        catch (e) { } return fb(b, n, null, [a]).length > 0; }, fb.contains = function (a, b) { return (a.ownerDocument || a) !== n && m(a), t(a, b); }, fb.attr = function (a, b) { (a.ownerDocument || a) !== n && m(a); var e = d.attrHandle[b.toLowerCase()], f = e && E.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0; return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null; }, fb.error = function (a) { throw new Error("Syntax error, unrecognized expression: " + a); }, fb.uniqueSort = function (a) { var b, d = [], e = 0, f = 0; if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {
        while (b = a[f++])
            b === a[f] && (e = d.push(f));
        while (e--)
            a.splice(d[e], 1);
    } return k = null, a; }, e = fb.getText = function (a) { var b, c = "", d = 0, f = a.nodeType; if (f) {
        if (1 === f || 9 === f || 11 === f) {
            if ("string" == typeof a.textContent)
                return a.textContent;
            for (a = a.firstChild; a; a = a.nextSibling)
                c += e(a);
        }
        else if (3 === f || 4 === f)
            return a.nodeValue;
    }
    else
        while (b = a[d++])
            c += e(b); return c; }, d = fb.selectors = { cacheLength: 50, createPseudo: hb, match: X, attrHandle: {}, find: {}, relative: { ">": { dir: "parentNode", first: !0 }, " ": { dir: "parentNode" }, "+": { dir: "previousSibling", first: !0 }, "~": { dir: "previousSibling" } }, preFilter: { ATTR: function (a) { return a[1] = a[1].replace(cb, db), a[3] = (a[3] || a[4] || a[5] || "").replace(cb, db), "~=" === a[2] && (a[3] = " " + a[3] + " "), a.slice(0, 4); }, CHILD: function (a) { return a[1] = a[1].toLowerCase(), "nth" === a[1].slice(0, 3) ? (a[3] || fb.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * ("even" === a[3] || "odd" === a[3])), a[5] = +(a[7] + a[8] || "odd" === a[3])) : a[3] && fb.error(a[0]), a; }, PSEUDO: function (a) { var b, c = !a[6] && a[2]; return X.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || "" : c && V.test(c) && (b = g(c, !0)) && (b = c.indexOf(")", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3)); } }, filter: { TAG: function (a) { var b = a.replace(cb, db).toLowerCase(); return "*" === a ? function () { return !0; } : function (a) { return a.nodeName && a.nodeName.toLowerCase() === b; }; }, CLASS: function (a) { var b = y[a + " "]; return b || (b = new RegExp("(^|" + M + ")" + a + "(" + M + "|$)")) && y(a, function (a) { return b.test("string" == typeof a.className && a.className || typeof a.getAttribute !== C && a.getAttribute("class") || ""); }); }, ATTR: function (a, b, c) { return function (d) { var e = fb.attr(d, a); return null == e ? "!=" === b : b ? (e += "", "=" === b ? e === c : "!=" === b ? e !== c : "^=" === b ? c && 0 === e.indexOf(c) : "*=" === b ? c && e.indexOf(c) > -1 : "$=" === b ? c && e.slice(-c.length) === c : "~=" === b ? (" " + e + " ").indexOf(c) > -1 : "|=" === b ? e === c || e.slice(0, c.length + 1) === c + "-" : !1) : !0; }; }, CHILD: function (a, b, c, d, e) { var f = "nth" !== a.slice(0, 3), g = "last" !== a.slice(-4), h = "of-type" === b; return 1 === d && 0 === e ? function (a) { return !!a.parentNode; } : function (b, c, i) { var j, k, l, m, n, o, p = f !== g ? "nextSibling" : "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase(), s = !i && !h; if (q) {
                if (f) {
                    while (p) {
                        l = b;
                        while (l = l[p])
                            if (h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType)
                                return !1;
                        o = p = "only" === a && !o && "nextSibling";
                    }
                    return !0;
                }
                if (o = [g ? q.firstChild : q.lastChild], g && s) {
                    k = q[u] || (q[u] = {}), j = k[a] || [], n = j[0] === w && j[1], m = j[0] === w && j[2], l = n && q.childNodes[n];
                    while (l = ++n && l && l[p] || (m = n = 0) || o.pop())
                        if (1 === l.nodeType && ++m && l === b) {
                            k[a] = [w, n, m];
                            break;
                        }
                }
                else if (s && (j = (b[u] || (b[u] = {}))[a]) && j[0] === w)
                    m = j[1];
                else
                    while (l = ++n && l && l[p] || (m = n = 0) || o.pop())
                        if ((h ? l.nodeName.toLowerCase() === r : 1 === l.nodeType) && ++m && (s && ((l[u] || (l[u] = {}))[a] = [w, m]), l === b))
                            break;
                return m -= e, m === d || m % d === 0 && m / d >= 0;
            } }; }, PSEUDO: function (a, b) { var c, e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fb.error("unsupported pseudo: " + a); return e[u] ? e(b) : e.length > 1 ? (c = [a, a, "", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? hb(function (a, c) { var d, f = e(a, b), g = f.length; while (g--)
                d = K.call(a, f[g]), a[d] = !(c[d] = f[g]); }) : function (a) { return e(a, 0, c); }) : e; } }, pseudos: { not: hb(function (a) { var b = [], c = [], d = h(a.replace(R, "$1")); return d[u] ? hb(function (a, b, c, e) { var f, g = d(a, null, e, []), h = a.length; while (h--)
                (f = g[h]) && (a[h] = !(b[h] = f)); }) : function (a, e, f) { return b[0] = a, d(b, null, f, c), !c.pop(); }; }), has: hb(function (a) { return function (b) { return fb(a, b).length > 0; }; }), contains: hb(function (a) { return function (b) { return (b.textContent || b.innerText || e(b)).indexOf(a) > -1; }; }), lang: hb(function (a) { return W.test(a || "") || fb.error("unsupported lang: " + a), a = a.replace(cb, db).toLowerCase(), function (b) { var c; do
                if (c = p ? b.lang : b.getAttribute("xml:lang") || b.getAttribute("lang"))
                    return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + "-");
            while ((b = b.parentNode) && 1 === b.nodeType); return !1; }; }), target: function (b) { var c = a.location && a.location.hash; return c && c.slice(1) === b.id; }, root: function (a) { return a === o; }, focus: function (a) { return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex); }, enabled: function (a) { return a.disabled === !1; }, disabled: function (a) { return a.disabled === !0; }, checked: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && !!a.checked || "option" === b && !!a.selected; }, selected: function (a) { return a.parentNode && a.parentNode.selectedIndex, a.selected === !0; }, empty: function (a) { for (a = a.firstChild; a; a = a.nextSibling)
                if (a.nodeType < 6)
                    return !1; return !0; }, parent: function (a) { return !d.pseudos.empty(a); }, header: function (a) { return Z.test(a.nodeName); }, input: function (a) { return Y.test(a.nodeName); }, button: function (a) { var b = a.nodeName.toLowerCase(); return "input" === b && "button" === a.type || "button" === b; }, text: function (a) { var b; return "input" === a.nodeName.toLowerCase() && "text" === a.type && (null == (b = a.getAttribute("type")) || "text" === b.toLowerCase()); }, first: nb(function () { return [0]; }), last: nb(function (a, b) { return [b - 1]; }), eq: nb(function (a, b, c) { return [0 > c ? c + b : c]; }), even: nb(function (a, b) { for (var c = 0; b > c; c += 2)
                a.push(c); return a; }), odd: nb(function (a, b) { for (var c = 1; b > c; c += 2)
                a.push(c); return a; }), lt: nb(function (a, b, c) { for (var d = 0 > c ? c + b : c; --d >= 0;)
                a.push(d); return a; }), gt: nb(function (a, b, c) { for (var d = 0 > c ? c + b : c; ++d < b;)
                a.push(d); return a; }) } }, d.pseudos.nth = d.pseudos.eq; for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 })
        d.pseudos[b] = lb(b); for (b in { submit: !0, reset: !0 })
        d.pseudos[b] = mb(b); function pb() { } pb.prototype = d.filters = d.pseudos, d.setFilters = new pb, g = fb.tokenize = function (a, b) { var c, e, f, g, h, i, j, k = z[a + " "]; if (k)
        return b ? 0 : k.slice(0); h = a, i = [], j = d.preFilter; while (h) {
        (!c || (e = S.exec(h))) && (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = T.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(R, " ") }), h = h.slice(c.length));
        for (g in d.filter)
            !(e = X[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));
        if (!c)
            break;
    } return b ? h.length : h ? fb.error(a) : z(a, i).slice(0); }; function qb(a) { for (var b = 0, c = a.length, d = ""; c > b; b++)
        d += a[b].value; return d; } function rb(a, b, c) { var d = b.dir, e = c && "parentNode" === d, f = x++; return b.first ? function (b, c, f) { while (b = b[d])
        if (1 === b.nodeType || e)
            return a(b, c, f); } : function (b, c, g) { var h, i, j = [w, f]; if (g) {
        while (b = b[d])
            if ((1 === b.nodeType || e) && a(b, c, g))
                return !0;
    }
    else
        while (b = b[d])
            if (1 === b.nodeType || e) {
                if (i = b[u] || (b[u] = {}), (h = i[d]) && h[0] === w && h[1] === f)
                    return j[2] = h[2];
                if (i[d] = j, j[2] = a(b, c, g))
                    return !0;
            } }; } function sb(a) { return a.length > 1 ? function (b, c, d) { var e = a.length; while (e--)
        if (!a[e](b, c, d))
            return !1; return !0; } : a[0]; } function tb(a, b, c) { for (var d = 0, e = b.length; e > d; d++)
        fb(a, b[d], c); return c; } function ub(a, b, c, d, e) { for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++)
        (f = a[h]) && (!c || c(f, d, e)) && (g.push(f), j && b.push(h)); return g; } function vb(a, b, c, d, e, f) { return d && !d[u] && (d = vb(d)), e && !e[u] && (e = vb(e, f)), hb(function (f, g, h, i) { var j, k, l, m = [], n = [], o = g.length, p = f || tb(b || "*", h.nodeType ? [h] : h, []), q = !a || !f && b ? p : ub(p, m, a, h, i), r = c ? e || (f ? a : o || d) ? [] : g : q; if (c && c(q, r, h, i), d) {
        j = ub(r, n), d(j, [], h, i), k = j.length;
        while (k--)
            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));
    } if (f) {
        if (e || a) {
            if (e) {
                j = [], k = r.length;
                while (k--)
                    (l = r[k]) && j.push(q[k] = l);
                e(null, r = [], j, i);
            }
            k = r.length;
            while (k--)
                (l = r[k]) && (j = e ? K.call(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));
        }
    }
    else
        r = ub(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : I.apply(g, r); }); } function wb(a) { for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[" "], i = g ? 1 : 0, k = rb(function (a) { return a === b; }, h, !0), l = rb(function (a) { return K.call(b, a) > -1; }, h, !0), m = [function (a, c, d) { return !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d)); }]; f > i; i++)
        if (c = d.relative[a[i].type])
            m = [rb(sb(m), c)];
        else {
            if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {
                for (e = ++i; f > e; e++)
                    if (d.relative[a[e].type])
                        break;
                return vb(i > 1 && sb(m), i > 1 && qb(a.slice(0, i - 1).concat({ value: " " === a[i - 2].type ? "*" : "" })).replace(R, "$1"), c, e > i && wb(a.slice(i, e)), f > e && wb(a = a.slice(e)), f > e && qb(a));
            }
            m.push(c);
        } return sb(m); } function xb(a, b) { var c = b.length > 0, e = a.length > 0, f = function (f, g, h, i, k) { var l, m, o, p = 0, q = "0", r = f && [], s = [], t = j, u = f || e && d.find.TAG("*", k), v = w += null == t ? 1 : Math.random() || .1, x = u.length; for (k && (j = g !== n && g); q !== x && null != (l = u[q]); q++) {
        if (e && l) {
            m = 0;
            while (o = a[m++])
                if (o(l, g, h)) {
                    i.push(l);
                    break;
                }
            k && (w = v);
        }
        c && ((l = !o && l) && p--, f && r.push(l));
    } if (p += q, c && q !== p) {
        m = 0;
        while (o = b[m++])
            o(r, s, g, h);
        if (f) {
            if (p > 0)
                while (q--)
                    r[q] || s[q] || (s[q] = G.call(i));
            s = ub(s);
        }
        I.apply(i, s), k && !f && s.length > 0 && p + b.length > 1 && fb.uniqueSort(i);
    } return k && (w = v, j = t), r; }; return c ? hb(f) : f; } return h = fb.compile = function (a, b) { var c, d = [], e = [], f = A[a + " "]; if (!f) {
        b || (b = g(a)), c = b.length;
        while (c--)
            f = wb(b[c]), f[u] ? d.push(f) : e.push(f);
        f = A(a, xb(e, d)), f.selector = a;
    } return f; }, i = fb.select = function (a, b, e, f) { var i, j, k, l, m, n = "function" == typeof a && a, o = !f && g(a = n.selector || a); if (e = e || [], 1 === o.length) {
        if (j = o[0] = o[0].slice(0), j.length > 2 && "ID" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {
            if (b = (d.find.ID(k.matches[0].replace(cb, db), b) || [])[0], !b)
                return e;
            n && (b = b.parentNode), a = a.slice(j.shift().value.length);
        }
        i = X.needsContext.test(a) ? 0 : j.length;
        while (i--) {
            if (k = j[i], d.relative[l = k.type])
                break;
            if ((m = d.find[l]) && (f = m(k.matches[0].replace(cb, db), ab.test(j[0].type) && ob(b.parentNode) || b))) {
                if (j.splice(i, 1), a = f.length && qb(j), !a)
                    return I.apply(e, f), e;
                break;
            }
        }
    } return (n || h(a, o))(f, b, !p, e, ab.test(a) && ob(b.parentNode) || b), e; }, c.sortStable = u.split("").sort(B).join("") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ib(function (a) { return 1 & a.compareDocumentPosition(n.createElement("div")); }), ib(function (a) { return a.innerHTML = "<a href='#'></a>", "#" === a.firstChild.getAttribute("href"); }) || jb("type|href|height|width", function (a, b, c) { return c ? void 0 : a.getAttribute(b, "type" === b.toLowerCase() ? 1 : 2); }), c.attributes && ib(function (a) { return a.innerHTML = "<input/>", a.firstChild.setAttribute("value", ""), "" === a.firstChild.getAttribute("value"); }) || jb("value", function (a, b, c) { return c || "input" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue; }), ib(function (a) { return null == a.getAttribute("disabled"); }) || jb(L, function (a, b, c) { var d; return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null; }), fb; }(a);
    m.find = s, m.expr = s.selectors, m.expr[":"] = m.expr.pseudos, m.unique = s.uniqueSort, m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains;
    var t = m.expr.match.needsContext, u = /^<(\w+)\s*\/?>(?:<\/\1>|)$/, v = /^.[^:#\[\.,]*$/;
    function w(a, b, c) { if (m.isFunction(b))
        return m.grep(a, function (a, d) { return !!b.call(a, d, a) !== c; }); if (b.nodeType)
        return m.grep(a, function (a) { return a === b !== c; }); if ("string" == typeof b) {
        if (v.test(b))
            return m.filter(b, a, c);
        b = m.filter(b, a);
    } return m.grep(a, function (a) { return m.inArray(a, b) >= 0 !== c; }); }
    m.filter = function (a, b, c) { var d = b[0]; return c && (a = ":not(" + a + ")"), 1 === b.length && 1 === d.nodeType ? m.find.matchesSelector(d, a) ? [d] : [] : m.find.matches(a, m.grep(b, function (a) { return 1 === a.nodeType; })); }, m.fn.extend({ find: function (a) { var b, c = [], d = this, e = d.length; if ("string" != typeof a)
            return this.pushStack(m(a).filter(function () { for (b = 0; e > b; b++)
                if (m.contains(d[b], this))
                    return !0; })); for (b = 0; e > b; b++)
            m.find(a, d[b], c); return c = this.pushStack(e > 1 ? m.unique(c) : c), c.selector = this.selector ? this.selector + " " + a : a, c; }, filter: function (a) { return this.pushStack(w(this, a || [], !1)); }, not: function (a) { return this.pushStack(w(this, a || [], !0)); }, is: function (a) { return !!w(this, "string" == typeof a && t.test(a) ? m(a) : a || [], !1).length; } });
    var x, y = a.document, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, A = m.fn.init = function (a, b) { var c, d; if (!a)
        return this; if ("string" == typeof a) {
        if (c = "<" === a.charAt(0) && ">" === a.charAt(a.length - 1) && a.length >= 3 ? [null, a, null] : z.exec(a), !c || !c[1] && b)
            return !b || b.jquery ? (b || x).find(a) : this.constructor(b).find(a);
        if (c[1]) {
            if (b = b instanceof m ? b[0] : b, m.merge(this, m.parseHTML(c[1], b && b.nodeType ? b.ownerDocument || b : y, !0)), u.test(c[1]) && m.isPlainObject(b))
                for (c in b)
                    m.isFunction(this[c]) ? this[c](b[c]) : this.attr(c, b[c]);
            return this;
        }
        if (d = y.getElementById(c[2]), d && d.parentNode) {
            if (d.id !== c[2])
                return x.find(a);
            this.length = 1, this[0] = d;
        }
        return this.context = y, this.selector = a, this;
    } return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : m.isFunction(a) ? "undefined" != typeof x.ready ? x.ready(a) : a(m) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), m.makeArray(a, this)); };
    A.prototype = m.fn, x = m(y);
    var B = /^(?:parents|prev(?:Until|All))/, C = { children: !0, contents: !0, next: !0, prev: !0 };
    m.extend({ dir: function (a, b, c) { var d = [], e = a[b]; while (e && 9 !== e.nodeType && (void 0 === c || 1 !== e.nodeType || !m(e).is(c)))
            1 === e.nodeType && d.push(e), e = e[b]; return d; }, sibling: function (a, b) { for (var c = []; a; a = a.nextSibling)
            1 === a.nodeType && a !== b && c.push(a); return c; } }), m.fn.extend({ has: function (a) { var b, c = m(a, this), d = c.length; return this.filter(function () { for (b = 0; d > b; b++)
            if (m.contains(this, c[b]))
                return !0; }); }, closest: function (a, b) { for (var c, d = 0, e = this.length, f = [], g = t.test(a) || "string" != typeof a ? m(a, b || this.context) : 0; e > d; d++)
            for (c = this[d]; c && c !== b; c = c.parentNode)
                if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && m.find.matchesSelector(c, a))) {
                    f.push(c);
                    break;
                } return this.pushStack(f.length > 1 ? m.unique(f) : f); }, index: function (a) { return a ? "string" == typeof a ? m.inArray(this[0], m(a)) : m.inArray(a.jquery ? a[0] : a, this) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1; }, add: function (a, b) { return this.pushStack(m.unique(m.merge(this.get(), m(a, b)))); }, addBack: function (a) { return this.add(null == a ? this.prevObject : this.prevObject.filter(a)); } });
    function D(a, b) { do
        a = a[b];
    while (a && 1 !== a.nodeType); return a; }
    m.each({ parent: function (a) { var b = a.parentNode; return b && 11 !== b.nodeType ? b : null; }, parents: function (a) { return m.dir(a, "parentNode"); }, parentsUntil: function (a, b, c) { return m.dir(a, "parentNode", c); }, next: function (a) { return D(a, "nextSibling"); }, prev: function (a) { return D(a, "previousSibling"); }, nextAll: function (a) { return m.dir(a, "nextSibling"); }, prevAll: function (a) { return m.dir(a, "previousSibling"); }, nextUntil: function (a, b, c) { return m.dir(a, "nextSibling", c); }, prevUntil: function (a, b, c) { return m.dir(a, "previousSibling", c); }, siblings: function (a) { return m.sibling((a.parentNode || {}).firstChild, a); }, children: function (a) { return m.sibling(a.firstChild); }, contents: function (a) { return m.nodeName(a, "iframe") ? a.contentDocument || a.contentWindow.document : m.merge([], a.childNodes); } }, function (a, b) { m.fn[a] = function (c, d) { var e = m.map(this, b, c); return "Until" !== a.slice(-5) && (d = c), d && "string" == typeof d && (e = m.filter(d, e)), this.length > 1 && (C[a] || (e = m.unique(e)), B.test(a) && (e = e.reverse())), this.pushStack(e); }; });
    var E = /\S+/g, F = {};
    function G(a) { var b = F[a] = {}; return m.each(a.match(E) || [], function (a, c) { b[c] = !0; }), b; }
    m.Callbacks = function (a) { a = "string" == typeof a ? F[a] || G(a) : m.extend({}, a); var b, c, d, e, f, g, h = [], i = !a.once && [], j = function (l) { for (c = a.memory && l, d = !0, f = g || 0, g = 0, e = h.length, b = !0; h && e > f; f++)
        if (h[f].apply(l[0], l[1]) === !1 && a.stopOnFalse) {
            c = !1;
            break;
        } b = !1, h && (i ? i.length && j(i.shift()) : c ? h = [] : k.disable()); }, k = { add: function () { if (h) {
            var d = h.length;
            !function f(b) { m.each(b, function (b, c) { var d = m.type(c); "function" === d ? a.unique && k.has(c) || h.push(c) : c && c.length && "string" !== d && f(c); }); }(arguments), b ? e = h.length : c && (g = d, j(c));
        } return this; }, remove: function () { return h && m.each(arguments, function (a, c) { var d; while ((d = m.inArray(c, h, d)) > -1)
            h.splice(d, 1), b && (e >= d && e--, f >= d && f--); }), this; }, has: function (a) { return a ? m.inArray(a, h) > -1 : !(!h || !h.length); }, empty: function () { return h = [], e = 0, this; }, disable: function () { return h = i = c = void 0, this; }, disabled: function () { return !h; }, lock: function () { return i = void 0, c || k.disable(), this; }, locked: function () { return !i; }, fireWith: function (a, c) { return !h || d && !i || (c = c || [], c = [a, c.slice ? c.slice() : c], b ? i.push(c) : j(c)), this; }, fire: function () { return k.fireWith(this, arguments), this; }, fired: function () { return !!d; } }; return k; }, m.extend({ Deferred: function (a) { var b = [["resolve", "done", m.Callbacks("once memory"), "resolved"], ["reject", "fail", m.Callbacks("once memory"), "rejected"], ["notify", "progress", m.Callbacks("memory")]], c = "pending", d = { state: function () { return c; }, always: function () { return e.done(arguments).fail(arguments), this; }, then: function () { var a = arguments; return m.Deferred(function (c) { m.each(b, function (b, f) { var g = m.isFunction(a[b]) && a[b]; e[f[1]](function () { var a = g && g.apply(this, arguments); a && m.isFunction(a.promise) ? a.promise().done(c.resolve).fail(c.reject).progress(c.notify) : c[f[0] + "With"](this === d ? c.promise() : this, g ? [a] : arguments); }); }), a = null; }).promise(); }, promise: function (a) { return null != a ? m.extend(a, d) : d; } }, e = {}; return d.pipe = d.then, m.each(b, function (a, f) { var g = f[2], h = f[3]; d[f[1]] = g.add, h && g.add(function () { c = h; }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () { return e[f[0] + "With"](this === e ? d : this, arguments), this; }, e[f[0] + "With"] = g.fireWith; }), d.promise(e), a && a.call(e, e), e; }, when: function (a) { var b = 0, c = d.call(arguments), e = c.length, f = 1 !== e || a && m.isFunction(a.promise) ? e : 0, g = 1 === f ? a : m.Deferred(), h = function (a, b, c) { return function (e) { b[a] = this, c[a] = arguments.length > 1 ? d.call(arguments) : e, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c); }; }, i, j, k; if (e > 1)
            for (i = new Array(e), j = new Array(e), k = new Array(e); e > b; b++)
                c[b] && m.isFunction(c[b].promise) ? c[b].promise().done(h(b, k, c)).fail(g.reject).progress(h(b, j, i)) : --f; return f || g.resolveWith(k, c), g.promise(); } });
    var H;
    m.fn.ready = function (a) { return m.ready.promise().done(a), this; }, m.extend({ isReady: !1, readyWait: 1, holdReady: function (a) { a ? m.readyWait++ : m.ready(!0); }, ready: function (a) { if (a === !0 ? !--m.readyWait : !m.isReady) {
            if (!y.body)
                return setTimeout(m.ready);
            m.isReady = !0, a !== !0 && --m.readyWait > 0 || (H.resolveWith(y, [m]), m.fn.triggerHandler && (m(y).triggerHandler("ready"), m(y).off("ready")));
        } } });
    function I() { y.addEventListener ? (y.removeEventListener("DOMContentLoaded", J, !1), a.removeEventListener("load", J, !1)) : (y.detachEvent("onreadystatechange", J), a.detachEvent("onload", J)); }
    function J() { (y.addEventListener || "load" === event.type || "complete" === y.readyState) && (I(), m.ready()); }
    m.ready.promise = function (b) { if (!H)
        if (H = m.Deferred(), "complete" === y.readyState)
            setTimeout(m.ready);
        else if (y.addEventListener)
            y.addEventListener("DOMContentLoaded", J, !1), a.addEventListener("load", J, !1);
        else {
            y.attachEvent("onreadystatechange", J), a.attachEvent("onload", J);
            var c = !1;
            try {
                c = null == a.frameElement && y.documentElement;
            }
            catch (d) { }
            c && c.doScroll && !function e() { if (!m.isReady) {
                try {
                    c.doScroll("left");
                }
                catch (a) {
                    return setTimeout(e, 50);
                }
                I(), m.ready();
            } }();
        } return H.promise(b); };
    var K = "undefined", L;
    for (L in m(k))
        break;
    k.ownLast = "0" !== L, k.inlineBlockNeedsLayout = !1, m(function () { var a, b, c, d; c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1", k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, a && (c.style.zoom = 1)), c.removeChild(d)); }), function () { var a = y.createElement("div"); if (null == k.deleteExpando) {
        k.deleteExpando = !0;
        try {
            delete a.test;
        }
        catch (b) {
            k.deleteExpando = !1;
        }
    } a = null; }(), m.acceptData = function (a) { var b = m.noData[(a.nodeName + " ").toLowerCase()], c = +a.nodeType || 1; return 1 !== c && 9 !== c ? !1 : !b || b !== !0 && a.getAttribute("classid") === b; };
    var M = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, N = /([A-Z])/g;
    function O(a, b, c) { if (void 0 === c && 1 === a.nodeType) {
        var d = "data-" + b.replace(N, "-$1").toLowerCase();
        if (c = a.getAttribute(d), "string" == typeof c) {
            try {
                c = "true" === c ? !0 : "false" === c ? !1 : "null" === c ? null : +c + "" === c ? +c : M.test(c) ? m.parseJSON(c) : c;
            }
            catch (e) { }
            m.data(a, b, c);
        }
        else
            c = void 0;
    } return c; }
    function P(a) { var b; for (b in a)
        if (("data" !== b || !m.isEmptyObject(a[b])) && "toJSON" !== b)
            return !1; return !0; }
    function Q(a, b, d, e) {
        if (m.acceptData(a)) {
            var f, g, h = m.expando, i = a.nodeType, j = i ? m.cache : a, k = i ? a[h] : a[h] && h;
            if (k && j[k] && (e || j[k].data) || void 0 !== d || "string" != typeof b)
                return k || (k = i ? a[h] = c.pop() || m.guid++ : h), j[k] || (j[k] = i ? {} : { toJSON: m.noop }), ("object" == typeof b || "function" == typeof b) && (e ? j[k] = m.extend(j[k], b) : j[k].data = m.extend(j[k].data, b)), g = j[k], e || (g.data || (g.data = {}), g = g.data), void 0 !== d && (g[m.camelCase(b)] = d), "string" == typeof b ? (f = g[b], null == f && (f = g[m.camelCase(b)])) : f = g, f;
        }
    }
    function R(a, b, c) { if (m.acceptData(a)) {
        var d, e, f = a.nodeType, g = f ? m.cache : a, h = f ? a[m.expando] : m.expando;
        if (g[h]) {
            if (b && (d = c ? g[h] : g[h].data)) {
                m.isArray(b) ? b = b.concat(m.map(b, m.camelCase)) : b in d ? b = [b] : (b = m.camelCase(b), b = b in d ? [b] : b.split(" ")), e = b.length;
                while (e--)
                    delete d[b[e]];
                if (c ? !P(d) : !m.isEmptyObject(d))
                    return;
            }
            (c || (delete g[h].data, P(g[h]))) && (f ? m.cleanData([a], !0) : k.deleteExpando || g != g.window ? delete g[h] : g[h] = null);
        }
    } }
    m.extend({ cache: {}, noData: { "applet ": !0, "embed ": !0, "object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" }, hasData: function (a) { return a = a.nodeType ? m.cache[a[m.expando]] : a[m.expando], !!a && !P(a); }, data: function (a, b, c) { return Q(a, b, c); }, removeData: function (a, b) { return R(a, b); }, _data: function (a, b, c) { return Q(a, b, c, !0); }, _removeData: function (a, b) { return R(a, b, !0); } }), m.fn.extend({ data: function (a, b) { var c, d, e, f = this[0], g = f && f.attributes; if (void 0 === a) {
            if (this.length && (e = m.data(f), 1 === f.nodeType && !m._data(f, "parsedAttrs"))) {
                c = g.length;
                while (c--)
                    g[c] && (d = g[c].name, 0 === d.indexOf("data-") && (d = m.camelCase(d.slice(5)), O(f, d, e[d])));
                m._data(f, "parsedAttrs", !0);
            }
            return e;
        } return "object" == typeof a ? this.each(function () { m.data(this, a); }) : arguments.length > 1 ? this.each(function () { m.data(this, a, b); }) : f ? O(f, a, m.data(f, a)) : void 0; }, removeData: function (a) { return this.each(function () { m.removeData(this, a); }); } }), m.extend({ queue: function (a, b, c) { var d; return a ? (b = (b || "fx") + "queue", d = m._data(a, b), c && (!d || m.isArray(c) ? d = m._data(a, b, m.makeArray(c)) : d.push(c)), d || []) : void 0; }, dequeue: function (a, b) { b = b || "fx"; var c = m.queue(a, b), d = c.length, e = c.shift(), f = m._queueHooks(a, b), g = function () { m.dequeue(a, b); }; "inprogress" === e && (e = c.shift(), d--), e && ("fx" === b && c.unshift("inprogress"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire(); }, _queueHooks: function (a, b) { var c = b + "queueHooks"; return m._data(a, c) || m._data(a, c, { empty: m.Callbacks("once memory").add(function () { m._removeData(a, b + "queue"), m._removeData(a, c); }) }); } }), m.fn.extend({ queue: function (a, b) { var c = 2; return "string" != typeof a && (b = a, a = "fx", c--), arguments.length < c ? m.queue(this[0], a) : void 0 === b ? this : this.each(function () { var c = m.queue(this, a, b); m._queueHooks(this, a), "fx" === a && "inprogress" !== c[0] && m.dequeue(this, a); }); }, dequeue: function (a) { return this.each(function () { m.dequeue(this, a); }); }, clearQueue: function (a) { return this.queue(a || "fx", []); }, promise: function (a, b) { var c, d = 1, e = m.Deferred(), f = this, g = this.length, h = function () { --d || e.resolveWith(f, [f]); }; "string" != typeof a && (b = a, a = void 0), a = a || "fx"; while (g--)
            c = m._data(f[g], a + "queueHooks"), c && c.empty && (d++, c.empty.add(h)); return h(), e.promise(b); } });
    var S = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, T = ["Top", "Right", "Bottom", "Left"], U = function (a, b) { return a = b || a, "none" === m.css(a, "display") || !m.contains(a.ownerDocument, a); }, V = m.access = function (a, b, c, d, e, f, g) { var h = 0, i = a.length, j = null == c; if ("object" === m.type(c)) {
        e = !0;
        for (h in c)
            m.access(a, b, h, c[h], !0, f, g);
    }
    else if (void 0 !== d && (e = !0, m.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function (a, b, c) { return j.call(m(a), c); })), b))
        for (; i > h; h++)
            b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c))); return e ? a : j ? b.call(a) : i ? b(a[0], c) : f; }, W = /^(?:checkbox|radio)$/i;
    !function () { var a = y.createElement("input"), b = y.createElement("div"), c = y.createDocumentFragment(); if (b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody = !b.getElementsByTagName("tbody").length, k.htmlSerialize = !!b.getElementsByTagName("link").length, k.html5Clone = "<:nav></:nav>" !== y.createElement("nav").cloneNode(!0).outerHTML, a.type = "checkbox", a.checked = !0, c.appendChild(a), k.appendChecked = a.checked, b.innerHTML = "<textarea>x</textarea>", k.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue, c.appendChild(b), b.innerHTML = "<input type='radio' checked='checked' name='t'/>", k.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, k.noCloneEvent = !0, b.attachEvent && (b.attachEvent("onclick", function () { k.noCloneEvent = !1; }), b.cloneNode(!0).click()), null == k.deleteExpando) {
        k.deleteExpando = !0;
        try {
            delete b.test;
        }
        catch (d) {
            k.deleteExpando = !1;
        }
    } }(), function () { var b, c, d = y.createElement("div"); for (b in { submit: !0, change: !0, focusin: !0 })
        c = "on" + b, (k[b + "Bubbles"] = c in a) || (d.setAttribute(c, "t"), k[b + "Bubbles"] = d.attributes[c].expando === !1); d = null; }();
    var X = /^(?:input|select|textarea)$/i, Y = /^key/, Z = /^(?:mouse|pointer|contextmenu)|click/, $ = /^(?:focusinfocus|focusoutblur)$/, _ = /^([^.]*)(?:\.(.+)|)$/;
    function ab() { return !0; }
    function bb() { return !1; }
    function cb() { try {
        return y.activeElement;
    }
    catch (a) { } }
    m.event = { global: {}, add: function (a, b, c, d, e) { var f, g, h, i, j, k, l, n, o, p, q, r = m._data(a); if (r) {
            c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = m.guid++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function (a) { return typeof m === K || a && m.event.triggered === a.type ? void 0 : m.event.dispatch.apply(k.elem, arguments); }, k.elem = a), b = (b || "").match(E) || [""], h = b.length;
            while (h--)
                f = _.exec(b[h]) || [], o = q = f[1], p = (f[2] || "").split(".").sort(), o && (j = m.event.special[o] || {}, o = (e ? j.delegateType : j.bindType) || o, j = m.event.special[o] || {}, l = m.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && m.expr.match.needsContext.test(e), namespace: p.join(".") }, i), (n = g[o]) || (n = g[o] = [], n.delegateCount = 0, j.setup && j.setup.call(a, d, p, k) !== !1 || (a.addEventListener ? a.addEventListener(o, k, !1) : a.attachEvent && a.attachEvent("on" + o, k))), j.add && (j.add.call(a, l), l.handler.guid || (l.handler.guid = c.guid)), e ? n.splice(n.delegateCount++, 0, l) : n.push(l), m.event.global[o] = !0);
            a = null;
        } }, remove: function (a, b, c, d, e) { var f, g, h, i, j, k, l, n, o, p, q, r = m.hasData(a) && m._data(a); if (r && (k = r.events)) {
            b = (b || "").match(E) || [""], j = b.length;
            while (j--)
                if (h = _.exec(b[j]) || [], o = q = h[1], p = (h[2] || "").split(".").sort(), o) {
                    l = m.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, n = k[o] || [], h = h[2] && new RegExp("(^|\\.)" + p.join("\\.(?:.*\\.|)") + "(\\.|$)"), i = f = n.length;
                    while (f--)
                        g = n[f], !e && q !== g.origType || c && c.guid !== g.guid || h && !h.test(g.namespace) || d && d !== g.selector && ("**" !== d || !g.selector) || (n.splice(f, 1), g.selector && n.delegateCount--, l.remove && l.remove.call(a, g));
                    i && !n.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || m.removeEvent(a, o, r.handle), delete k[o]);
                }
                else
                    for (o in k)
                        m.event.remove(a, o + b[j], c, d, !0);
            m.isEmptyObject(k) && (delete r.handle, m._removeData(a, "events"));
        } }, trigger: function (b, c, d, e) { var f, g, h, i, k, l, n, o = [d || y], p = j.call(b, "type") ? b.type : b, q = j.call(b, "namespace") ? b.namespace.split(".") : []; if (h = l = d = d || y, 3 !== d.nodeType && 8 !== d.nodeType && !$.test(p + m.event.triggered) && (p.indexOf(".") >= 0 && (q = p.split("."), p = q.shift(), q.sort()), g = p.indexOf(":") < 0 && "on" + p, b = b[m.expando] ? b : new m.Event(p, "object" == typeof b && b), b.isTrigger = e ? 2 : 3, b.namespace = q.join("."), b.namespace_re = b.namespace ? new RegExp("(^|\\.)" + q.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, b.result = void 0, b.target || (b.target = d), c = null == c ? [b] : m.makeArray(c, [b]), k = m.event.special[p] || {}, e || !k.trigger || k.trigger.apply(d, c) !== !1)) {
            if (!e && !k.noBubble && !m.isWindow(d)) {
                for (i = k.delegateType || p, $.test(i + p) || (h = h.parentNode); h; h = h.parentNode)
                    o.push(h), l = h;
                l === (d.ownerDocument || y) && o.push(l.defaultView || l.parentWindow || a);
            }
            n = 0;
            while ((h = o[n++]) && !b.isPropagationStopped())
                b.type = n > 1 ? i : k.bindType || p, f = (m._data(h, "events") || {})[b.type] && m._data(h, "handle"), f && f.apply(h, c), f = g && h[g], f && f.apply && m.acceptData(h) && (b.result = f.apply(h, c), b.result === !1 && b.preventDefault());
            if (b.type = p, !e && !b.isDefaultPrevented() && (!k._default || k._default.apply(o.pop(), c) === !1) && m.acceptData(d) && g && d[p] && !m.isWindow(d)) {
                l = d[g], l && (d[g] = null), m.event.triggered = p;
                try {
                    d[p]();
                }
                catch (r) { }
                m.event.triggered = void 0, l && (d[g] = l);
            }
            return b.result;
        } }, dispatch: function (a) { a = m.event.fix(a); var b, c, e, f, g, h = [], i = d.call(arguments), j = (m._data(this, "events") || {})[a.type] || [], k = m.event.special[a.type] || {}; if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {
            h = m.event.handlers.call(this, a, j), b = 0;
            while ((f = h[b++]) && !a.isPropagationStopped()) {
                a.currentTarget = f.elem, g = 0;
                while ((e = f.handlers[g++]) && !a.isImmediatePropagationStopped())
                    (!a.namespace_re || a.namespace_re.test(e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((m.event.special[e.origType] || {}).handle || e.handler).apply(f.elem, i), void 0 !== c && (a.result = c) === !1 && (a.preventDefault(), a.stopPropagation()));
            }
            return k.postDispatch && k.postDispatch.call(this, a), a.result;
        } }, handlers: function (a, b) { var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && (!a.button || "click" !== a.type))
            for (; i != this; i = i.parentNode || this)
                if (1 === i.nodeType && (i.disabled !== !0 || "click" !== a.type)) {
                    for (e = [], f = 0; h > f; f++)
                        d = b[f], c = d.selector + " ", void 0 === e[c] && (e[c] = d.needsContext ? m(c, this).index(i) >= 0 : m.find(c, this, null, [i]).length), e[c] && e.push(d);
                    e.length && g.push({ elem: i, handlers: e });
                } return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g; }, fix: function (a) { if (a[m.expando])
            return a; var b, c, d, e = a.type, f = a, g = this.fixHooks[e]; g || (this.fixHooks[e] = g = Z.test(e) ? this.mouseHooks : Y.test(e) ? this.keyHooks : {}), d = g.props ? this.props.concat(g.props) : this.props, a = new m.Event(f), b = d.length; while (b--)
            c = d[b], a[c] = f[c]; return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !!a.metaKey, g.filter ? g.filter(a, f) : a; }, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "), fixHooks: {}, keyHooks: { props: "char charCode key keyCode".split(" "), filter: function (a, b) { return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a; } }, mouseHooks: { props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "), filter: function (a, b) { var c, d, e, f = b.button, g = b.fromElement; return null == a.pageX && null != b.clientX && (d = a.target.ownerDocument || y, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c && c.scrollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)), !a.relatedTarget && g && (a.relatedTarget = g === a.target ? b.toElement : g), a.which || void 0 === f || (a.which = 1 & f ? 1 : 2 & f ? 3 : 4 & f ? 2 : 0), a; } }, special: { load: { noBubble: !0 }, focus: { trigger: function () { if (this !== cb() && this.focus)
                    try {
                        return this.focus(), !1;
                    }
                    catch (a) { } }, delegateType: "focusin" }, blur: { trigger: function () { return this === cb() && this.blur ? (this.blur(), !1) : void 0; }, delegateType: "focusout" }, click: { trigger: function () { return m.nodeName(this, "input") && "checkbox" === this.type && this.click ? (this.click(), !1) : void 0; }, _default: function (a) { return m.nodeName(a.target, "a"); } }, beforeunload: { postDispatch: function (a) { void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result); } } }, simulate: function (a, b, c, d) { var e = m.extend(new m.Event, c, { type: a, isSimulated: !0, originalEvent: {} }); d ? m.event.trigger(e, null, b) : m.event.dispatch.call(b, e), e.isDefaultPrevented() && c.preventDefault(); } }, m.removeEvent = y.removeEventListener ? function (a, b, c) { a.removeEventListener && a.removeEventListener(b, c, !1); } : function (a, b, c) { var d = "on" + b; a.detachEvent && (typeof a[d] === K && (a[d] = null), a.detachEvent(d, c)); }, m.Event = function (a, b) { return this instanceof m.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ab : bb) : this.type = a, b && m.extend(this, b), this.timeStamp = a && a.timeStamp || m.now(), void (this[m.expando] = !0)) : new m.Event(a, b); }, m.Event.prototype = { isDefaultPrevented: bb, isPropagationStopped: bb, isImmediatePropagationStopped: bb, preventDefault: function () { var a = this.originalEvent; this.isDefaultPrevented = ab, a && (a.preventDefault ? a.preventDefault() : a.returnValue = !1); }, stopPropagation: function () { var a = this.originalEvent; this.isPropagationStopped = ab, a && (a.stopPropagation && a.stopPropagation(), a.cancelBubble = !0); }, stopImmediatePropagation: function () { var a = this.originalEvent; this.isImmediatePropagationStopped = ab, a && a.stopImmediatePropagation && a.stopImmediatePropagation(), this.stopPropagation(); } }, m.each({ mouseenter: "mouseover", mouseleave: "mouseout", pointerenter: "pointerover", pointerleave: "pointerout" }, function (a, b) { m.event.special[a] = { delegateType: b, bindType: b, handle: function (a) { var c, d = this, e = a.relatedTarget, f = a.handleObj; return (!e || e !== d && !m.contains(d, e)) && (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c; } }; }), k.submitBubbles || (m.event.special.submit = { setup: function () { return m.nodeName(this, "form") ? !1 : void m.event.add(this, "click._submit keypress._submit", function (a) { var b = a.target, c = m.nodeName(b, "input") || m.nodeName(b, "button") ? b.form : void 0; c && !m._data(c, "submitBubbles") && (m.event.add(c, "submit._submit", function (a) { a._submit_bubble = !0; }), m._data(c, "submitBubbles", !0)); }); }, postDispatch: function (a) { a._submit_bubble && (delete a._submit_bubble, this.parentNode && !a.isTrigger && m.event.simulate("submit", this.parentNode, a, !0)); }, teardown: function () { return m.nodeName(this, "form") ? !1 : void m.event.remove(this, "._submit"); } }), k.changeBubbles || (m.event.special.change = { setup: function () { return X.test(this.nodeName) ? (("checkbox" === this.type || "radio" === this.type) && (m.event.add(this, "propertychange._change", function (a) { "checked" === a.originalEvent.propertyName && (this._just_changed = !0); }), m.event.add(this, "click._change", function (a) { this._just_changed && !a.isTrigger && (this._just_changed = !1), m.event.simulate("change", this, a, !0); })), !1) : void m.event.add(this, "beforeactivate._change", function (a) { var b = a.target; X.test(b.nodeName) && !m._data(b, "changeBubbles") && (m.event.add(b, "change._change", function (a) { !this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate("change", this.parentNode, a, !0); }), m._data(b, "changeBubbles", !0)); }); }, handle: function (a) { var b = a.target; return this !== b || a.isSimulated || a.isTrigger || "radio" !== b.type && "checkbox" !== b.type ? a.handleObj.handler.apply(this, arguments) : void 0; }, teardown: function () { return m.event.remove(this, "._change"), !X.test(this.nodeName); } }), k.focusinBubbles || m.each({ focus: "focusin", blur: "focusout" }, function (a, b) { var c = function (a) { m.event.simulate(b, a.target, m.event.fix(a), !0); }; m.event.special[b] = { setup: function () { var d = this.ownerDocument || this, e = m._data(d, b); e || d.addEventListener(a, c, !0), m._data(d, b, (e || 0) + 1); }, teardown: function () { var d = this.ownerDocument || this, e = m._data(d, b) - 1; e ? m._data(d, b, e) : (d.removeEventListener(a, c, !0), m._removeData(d, b)); } }; }), m.fn.extend({ on: function (a, b, c, d, e) { var f, g; if ("object" == typeof a) {
            "string" != typeof b && (c = c || b, b = void 0);
            for (f in a)
                this.on(f, b, c, a[f], e);
            return this;
        } if (null == c && null == d ? (d = b, c = b = void 0) : null == d && ("string" == typeof b ? (d = c, c = void 0) : (d = c, c = b, b = void 0)), d === !1)
            d = bb;
        else if (!d)
            return this; return 1 === e && (g = d, d = function (a) { return m().off(a), g.apply(this, arguments); }, d.guid = g.guid || (g.guid = m.guid++)), this.each(function () { m.event.add(this, a, d, c, b); }); }, one: function (a, b, c, d) { return this.on(a, b, c, d, 1); }, off: function (a, b, c) { var d, e; if (a && a.preventDefault && a.handleObj)
            return d = a.handleObj, m(a.delegateTarget).off(d.namespace ? d.origType + "." + d.namespace : d.origType, d.selector, d.handler), this; if ("object" == typeof a) {
            for (e in a)
                this.off(e, b, a[e]);
            return this;
        } return (b === !1 || "function" == typeof b) && (c = b, b = void 0), c === !1 && (c = bb), this.each(function () { m.event.remove(this, a, c, b); }); }, trigger: function (a, b) { return this.each(function () { m.event.trigger(a, b, this); }); }, triggerHandler: function (a, b) { var c = this[0]; return c ? m.event.trigger(a, b, c, !0) : void 0; } });
    function db(a) { var b = eb.split("|"), c = a.createDocumentFragment(); if (c.createElement)
        while (b.length)
            c.createElement(b.pop()); return c; }
    var eb = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video", fb = / jQuery\d+="(?:null|\d+)"/g, gb = new RegExp("<(?:" + eb + ")[\\s/>]", "i"), hb = /^\s+/, ib = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, jb = /<([\w:]+)/, kb = /<tbody/i, lb = /<|&#?\w+;/, mb = /<(?:script|style|link)/i, nb = /checked\s*(?:[^=]|=\s*.checked.)/i, ob = /^$|\/(?:java|ecma)script/i, pb = /^true\/(.*)/, qb = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, rb = { option: [1, "<select multiple='multiple'>", "</select>"], legend: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>", "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [2, "<table><tbody>", "</tbody></table>"], col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"], td: [3, "<table><tbody><tr>", "</tr></tbody></table>"], _default: k.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"] }, sb = db(y), tb = sb.appendChild(y.createElement("div"));
    rb.optgroup = rb.option, rb.tbody = rb.tfoot = rb.colgroup = rb.caption = rb.thead, rb.th = rb.td;
    function ub(a, b) { var c, d, e = 0, f = typeof a.getElementsByTagName !== K ? a.getElementsByTagName(b || "*") : typeof a.querySelectorAll !== K ? a.querySelectorAll(b || "*") : void 0; if (!f)
        for (f = [], c = a.childNodes || a; null != (d = c[e]); e++)
            !b || m.nodeName(d, b) ? f.push(d) : m.merge(f, ub(d, b)); return void 0 === b || b && m.nodeName(a, b) ? m.merge([a], f) : f; }
    function vb(a) { W.test(a.type) && (a.defaultChecked = a.checked); }
    function wb(a, b) { return m.nodeName(a, "table") && m.nodeName(11 !== b.nodeType ? b : b.firstChild, "tr") ? a.getElementsByTagName("tbody")[0] || a.appendChild(a.ownerDocument.createElement("tbody")) : a; }
    function xb(a) { return a.type = (null !== m.find.attr(a, "type")) + "/" + a.type, a; }
    function yb(a) { var b = pb.exec(a.type); return b ? a.type = b[1] : a.removeAttribute("type"), a; }
    function zb(a, b) { for (var c, d = 0; null != (c = a[d]); d++)
        m._data(c, "globalEval", !b || m._data(b[d], "globalEval")); }
    function Ab(a, b) { if (1 === b.nodeType && m.hasData(a)) {
        var c, d, e, f = m._data(a), g = m._data(b, f), h = f.events;
        if (h) {
            delete g.handle, g.events = {};
            for (c in h)
                for (d = 0, e = h[c].length; e > d; d++)
                    m.event.add(b, c, h[c][d]);
        }
        g.data && (g.data = m.extend({}, g.data));
    } }
    function Bb(a, b) { var c, d, e; if (1 === b.nodeType) {
        if (c = b.nodeName.toLowerCase(), !k.noCloneEvent && b[m.expando]) {
            e = m._data(b);
            for (d in e.events)
                m.removeEvent(b, d, e.handle);
            b.removeAttribute(m.expando);
        }
        "script" === c && b.text !== a.text ? (xb(b).text = a.text, yb(b)) : "object" === c ? (b.parentNode && (b.outerHTML = a.outerHTML), k.html5Clone && a.innerHTML && !m.trim(b.innerHTML) && (b.innerHTML = a.innerHTML)) : "input" === c && W.test(a.type) ? (b.defaultChecked = b.checked = a.checked, b.value !== a.value && (b.value = a.value)) : "option" === c ? b.defaultSelected = b.selected = a.defaultSelected : ("input" === c || "textarea" === c) && (b.defaultValue = a.defaultValue);
    } }
    m.extend({ clone: function (a, b, c) { var d, e, f, g, h, i = m.contains(a.ownerDocument, a); if (k.html5Clone || m.isXMLDoc(a) || !gb.test("<" + a.nodeName + ">") ? f = a.cloneNode(!0) : (tb.innerHTML = a.outerHTML, tb.removeChild(f = tb.firstChild)), !(k.noCloneEvent && k.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || m.isXMLDoc(a)))
            for (d = ub(f), h = ub(a), g = 0; null != (e = h[g]); ++g)
                d[g] && Bb(e, d[g]); if (b)
            if (c)
                for (h = h || ub(a), d = d || ub(f), g = 0; null != (e = h[g]); g++)
                    Ab(e, d[g]);
            else
                Ab(a, f); return d = ub(f, "script"), d.length > 0 && zb(d, !i && ub(a, "script")), d = h = e = null, f; }, buildFragment: function (a, b, c, d) { for (var e, f, g, h, i, j, l, n = a.length, o = db(b), p = [], q = 0; n > q; q++)
            if (f = a[q], f || 0 === f)
                if ("object" === m.type(f))
                    m.merge(p, f.nodeType ? [f] : f);
                else if (lb.test(f)) {
                    h = h || o.appendChild(b.createElement("div")), i = (jb.exec(f) || ["", ""])[1].toLowerCase(), l = rb[i] || rb._default, h.innerHTML = l[1] + f.replace(ib, "<$1></$2>") + l[2], e = l[0];
                    while (e--)
                        h = h.lastChild;
                    if (!k.leadingWhitespace && hb.test(f) && p.push(b.createTextNode(hb.exec(f)[0])), !k.tbody) {
                        f = "table" !== i || kb.test(f) ? "<table>" !== l[1] || kb.test(f) ? 0 : h : h.firstChild, e = f && f.childNodes.length;
                        while (e--)
                            m.nodeName(j = f.childNodes[e], "tbody") && !j.childNodes.length && f.removeChild(j);
                    }
                    m.merge(p, h.childNodes), h.textContent = "";
                    while (h.firstChild)
                        h.removeChild(h.firstChild);
                    h = o.lastChild;
                }
                else
                    p.push(b.createTextNode(f)); h && o.removeChild(h), k.appendChecked || m.grep(ub(p, "input"), vb), q = 0; while (f = p[q++])
            if ((!d || -1 === m.inArray(f, d)) && (g = m.contains(f.ownerDocument, f), h = ub(o.appendChild(f), "script"), g && zb(h), c)) {
                e = 0;
                while (f = h[e++])
                    ob.test(f.type || "") && c.push(f);
            } return h = null, o; }, cleanData: function (a, b) { for (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m.event.special; null != (d = a[h]); h++)
            if ((b || m.acceptData(d)) && (f = d[i], g = f && j[f])) {
                if (g.events)
                    for (e in g.events)
                        n[e] ? m.event.remove(d, e) : m.removeEvent(d, e, g.handle);
                j[f] && (delete j[f], l ? delete d[i] : typeof d.removeAttribute !== K ? d.removeAttribute(i) : d[i] = null, c.push(f));
            } } }), m.fn.extend({ text: function (a) { return V(this, function (a) { return void 0 === a ? m.text(this) : this.empty().append((this[0] && this[0].ownerDocument || y).createTextNode(a)); }, null, a, arguments.length); }, append: function () { return this.domManip(arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
            var b = wb(this, a);
            b.appendChild(a);
        } }); }, prepend: function () { return this.domManip(arguments, function (a) { if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
            var b = wb(this, a);
            b.insertBefore(a, b.firstChild);
        } }); }, before: function () { return this.domManip(arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this); }); }, after: function () { return this.domManip(arguments, function (a) { this.parentNode && this.parentNode.insertBefore(a, this.nextSibling); }); }, remove: function (a, b) { for (var c, d = a ? m.filter(a, this) : this, e = 0; null != (c = d[e]); e++)
            b || 1 !== c.nodeType || m.cleanData(ub(c)), c.parentNode && (b && m.contains(c.ownerDocument, c) && zb(ub(c, "script")), c.parentNode.removeChild(c)); return this; }, empty: function () { for (var a, b = 0; null != (a = this[b]); b++) {
            1 === a.nodeType && m.cleanData(ub(a, !1));
            while (a.firstChild)
                a.removeChild(a.firstChild);
            a.options && m.nodeName(a, "select") && (a.options.length = 0);
        } return this; }, clone: function (a, b) { return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () { return m.clone(this, a, b); }); }, html: function (a) { return V(this, function (a) { var b = this[0] || {}, c = 0, d = this.length; if (void 0 === a)
            return 1 === b.nodeType ? b.innerHTML.replace(fb, "") : void 0; if (!("string" != typeof a || mb.test(a) || !k.htmlSerialize && gb.test(a) || !k.leadingWhitespace && hb.test(a) || rb[(jb.exec(a) || ["", ""])[1].toLowerCase()])) {
            a = a.replace(ib, "<$1></$2>");
            try {
                for (; d > c; c++)
                    b = this[c] || {}, 1 === b.nodeType && (m.cleanData(ub(b, !1)), b.innerHTML = a);
                b = 0;
            }
            catch (e) { }
        } b && this.empty().append(a); }, null, a, arguments.length); }, replaceWith: function () { var a = arguments[0]; return this.domManip(arguments, function (b) { a = this.parentNode, m.cleanData(ub(this)), a && a.replaceChild(b, this); }), a && (a.length || a.nodeType) ? this : this.remove(); }, detach: function (a) { return this.remove(a, !0); }, domManip: function (a, b) { a = e.apply([], a); var c, d, f, g, h, i, j = 0, l = this.length, n = this, o = l - 1, p = a[0], q = m.isFunction(p); if (q || l > 1 && "string" == typeof p && !k.checkClone && nb.test(p))
            return this.each(function (c) { var d = n.eq(c); q && (a[0] = p.call(this, c, d.html())), d.domManip(a, b); }); if (l && (i = m.buildFragment(a, this[0].ownerDocument, !1, this), c = i.firstChild, 1 === i.childNodes.length && (i = c), c)) {
            for (g = m.map(ub(i, "script"), xb), f = g.length; l > j; j++)
                d = i, j !== o && (d = m.clone(d, !0, !0), f && m.merge(g, ub(d, "script"))), b.call(this[j], d, j);
            if (f)
                for (h = g[g.length - 1].ownerDocument, m.map(g, yb), j = 0; f > j; j++)
                    d = g[j], ob.test(d.type || "") && !m._data(d, "globalEval") && m.contains(h, d) && (d.src ? m._evalUrl && m._evalUrl(d.src) : m.globalEval((d.text || d.textContent || d.innerHTML || "").replace(qb, "")));
            i = c = null;
        } return this; } }), m.each({ appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith" }, function (a, b) { m.fn[a] = function (a) { for (var c, d = 0, e = [], g = m(a), h = g.length - 1; h >= d; d++)
        c = d === h ? this : this.clone(!0), m(g[d])[b](c), f.apply(e, c.get()); return this.pushStack(e); }; });
    var Cb, Db = {};
    function Eb(b, c) { var d, e = m(c.createElement(b)).appendTo(c.body), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle(e[0])) ? d.display : m.css(e[0], "display"); return e.detach(), f; }
    function Fb(a) { var b = y, c = Db[a]; return c || (c = Eb(a, b), "none" !== c && c || (Cb = (Cb || m("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement), b = (Cb[0].contentWindow || Cb[0].contentDocument).document, b.write(), b.close(), c = Eb(a, b), Cb.detach()), Db[a] = c), c; }
    !function () { var a; k.shrinkWrapBlocks = function () { if (null != a)
        return a; a = !1; var b, c, d; return c = y.getElementsByTagName("body")[0], c && c.style ? (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), typeof b.style.zoom !== K && (b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:1px;width:1px;zoom:1", b.appendChild(y.createElement("div")).style.width = "5px", a = 3 !== b.offsetWidth), c.removeChild(d), a) : void 0; }; }();
    var Gb = /^margin/, Hb = new RegExp("^(" + S + ")(?!px)[a-z%]+$", "i"), Ib, Jb, Kb = /^(top|right|bottom|left)$/;
    a.getComputedStyle ? (Ib = function (a) { return a.ownerDocument.defaultView.getComputedStyle(a, null); }, Jb = function (a, b, c) { var d, e, f, g, h = a.style; return c = c || Ib(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, c && ("" !== g || m.contains(a.ownerDocument, a) || (g = m.style(a, b)), Hb.test(g) && Gb.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g ? g : g + ""; }) : y.documentElement.currentStyle && (Ib = function (a) { return a.currentStyle; }, Jb = function (a, b, c) { var d, e, f, g, h = a.style; return c = c || Ib(a), g = c ? c[b] : void 0, null == g && h && h[b] && (g = h[b]), Hb.test(g) && !Kb.test(b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b ? "1em" : g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g ? g : g + "" || "auto"; });
    function Lb(a, b) { return { get: function () { var c = a(); if (null != c)
            return c ? void delete this.get : (this.get = b).apply(this, arguments); } }; }
    !function () { var b, c, d, e, f, g, h; if (b = y.createElement("div"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = d && d.style) {
        c.cssText = "float:left;opacity:.5", k.opacity = "0.5" === c.opacity, k.cssFloat = !!c.cssFloat, b.style.backgroundClip = "content-box", b.cloneNode(!0).style.backgroundClip = "", k.clearCloneStyle = "content-box" === b.style.backgroundClip, k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, m.extend(k, { reliableHiddenOffsets: function () { return null == g && i(), g; }, boxSizingReliable: function () { return null == f && i(), f; }, pixelPosition: function () { return null == e && i(), e; }, reliableMarginRight: function () { return null == h && i(), h; } });
        function i() { var b, c, d, i; c = y.getElementsByTagName("body")[0], c && c.style && (b = y.createElement("div"), d = y.createElement("div"), d.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px", c.appendChild(d).appendChild(b), b.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute", e = f = !1, h = !0, a.getComputedStyle && (e = "1%" !== (a.getComputedStyle(b, null) || {}).top, f = "4px" === (a.getComputedStyle(b, null) || { width: "4px" }).width, i = b.appendChild(y.createElement("div")), i.style.cssText = b.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0", i.style.marginRight = i.style.width = "0", b.style.width = "1px", h = !parseFloat((a.getComputedStyle(i, null) || {}).marginRight)), b.innerHTML = "<table><tr><td></td><td>t</td></tr></table>", i = b.getElementsByTagName("td"), i[0].style.cssText = "margin:0;border:0;padding:0;display:none", g = 0 === i[0].offsetHeight, g && (i[0].style.display = "", i[1].style.display = "none", g = 0 === i[0].offsetHeight), c.removeChild(d)); }
    } }(), m.swap = function (a, b, c, d) { var e, f, g = {}; for (f in b)
        g[f] = a.style[f], a.style[f] = b[f]; e = c.apply(a, d || []); for (f in b)
        a.style[f] = g[f]; return e; };
    var Mb = /alpha\([^)]*\)/i, Nb = /opacity\s*=\s*([^)]*)/, Ob = /^(none|table(?!-c[ea]).+)/, Pb = new RegExp("^(" + S + ")(.*)$", "i"), Qb = new RegExp("^([+-])=(" + S + ")", "i"), Rb = { position: "absolute", visibility: "hidden", display: "block" }, Sb = { letterSpacing: "0", fontWeight: "400" }, Tb = ["Webkit", "O", "Moz", "ms"];
    function Ub(a, b) { if (b in a)
        return b; var c = b.charAt(0).toUpperCase() + b.slice(1), d = b, e = Tb.length; while (e--)
        if (b = Tb[e] + c, b in a)
            return b; return d; }
    function Vb(a, b) { for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++)
        d = a[g], d.style && (f[g] = m._data(d, "olddisplay"), c = d.style.display, b ? (f[g] || "none" !== c || (d.style.display = ""), "" === d.style.display && U(d) && (f[g] = m._data(d, "olddisplay", Fb(d.nodeName)))) : (e = U(d), (c && "none" !== c || !e) && m._data(d, "olddisplay", e ? c : m.css(d, "display")))); for (g = 0; h > g; g++)
        d = a[g], d.style && (b && "none" !== d.style.display && "" !== d.style.display || (d.style.display = b ? f[g] || "" : "none")); return a; }
    function Wb(a, b, c) { var d = Pb.exec(b); return d ? Math.max(0, d[1] - (c || 0)) + (d[2] || "px") : b; }
    function Xb(a, b, c, d, e) { for (var f = c === (d ? "border" : "content") ? 4 : "width" === b ? 1 : 0, g = 0; 4 > f; f += 2)
        "margin" === c && (g += m.css(a, c + T[f], !0, e)), d ? ("content" === c && (g -= m.css(a, "padding" + T[f], !0, e)), "margin" !== c && (g -= m.css(a, "border" + T[f] + "Width", !0, e))) : (g += m.css(a, "padding" + T[f], !0, e), "padding" !== c && (g += m.css(a, "border" + T[f] + "Width", !0, e))); return g; }
    function Yb(a, b, c) { var d = !0, e = "width" === b ? a.offsetWidth : a.offsetHeight, f = Ib(a), g = k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, f); if (0 >= e || null == e) {
        if (e = Jb(a, b, f), (0 > e || null == e) && (e = a.style[b]), Hb.test(e))
            return e;
        d = g && (k.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;
    } return e + Xb(a, b, c || (g ? "border" : "content"), d, f) + "px"; }
    m.extend({ cssHooks: { opacity: { get: function (a, b) { if (b) {
                    var c = Jb(a, "opacity");
                    return "" === c ? "1" : c;
                } } } }, cssNumber: { columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { "float": k.cssFloat ? "cssFloat" : "styleFloat" }, style: function (a, b, c, d) { if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {
            var e, f, g, h = m.camelCase(b), i = a.style;
            if (b = m.cssProps[h] || (m.cssProps[h] = Ub(i, h)), g = m.cssHooks[b] || m.cssHooks[h], void 0 === c)
                return g && "get" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b];
            if (f = typeof c, "string" === f && (e = Qb.exec(c)) && (c = (e[1] + 1) * e[2] + parseFloat(m.css(a, b)), f = "number"), null != c && c === c && ("number" !== f || m.cssNumber[h] || (c += "px"), k.clearCloneStyle || "" !== c || 0 !== b.indexOf("background") || (i[b] = "inherit"), !(g && "set" in g && void 0 === (c = g.set(a, c, d)))))
                try {
                    i[b] = c;
                }
                catch (j) { }
        } }, css: function (a, b, c, d) { var e, f, g, h = m.camelCase(b); return b = m.cssProps[h] || (m.cssProps[h] = Ub(a.style, h)), g = m.cssHooks[b] || m.cssHooks[h], g && "get" in g && (f = g.get(a, !0, c)), void 0 === f && (f = Jb(a, b, d)), "normal" === f && b in Sb && (f = Sb[b]), "" === c || c ? (e = parseFloat(f), c === !0 || m.isNumeric(e) ? e || 0 : f) : f; } }), m.each(["height", "width"], function (a, b) { m.cssHooks[b] = { get: function (a, c, d) { return c ? Ob.test(m.css(a, "display")) && 0 === a.offsetWidth ? m.swap(a, Rb, function () { return Yb(a, b, d); }) : Yb(a, b, d) : void 0; }, set: function (a, c, d) { var e = d && Ib(a); return Wb(a, c, d ? Xb(a, b, d, k.boxSizing && "border-box" === m.css(a, "boxSizing", !1, e), e) : 0); } }; }), k.opacity || (m.cssHooks.opacity = { get: function (a, b) { return Nb.test((b && a.currentStyle ? a.currentStyle.filter : a.style.filter) || "") ? .01 * parseFloat(RegExp.$1) + "" : b ? "1" : ""; }, set: function (a, b) { var c = a.style, d = a.currentStyle, e = m.isNumeric(b) ? "alpha(opacity=" + 100 * b + ")" : "", f = d && d.filter || c.filter || ""; c.zoom = 1, (b >= 1 || "" === b) && "" === m.trim(f.replace(Mb, "")) && c.removeAttribute && (c.removeAttribute("filter"), "" === b || d && !d.filter) || (c.filter = Mb.test(f) ? f.replace(Mb, e) : f + " " + e); } }), m.cssHooks.marginRight = Lb(k.reliableMarginRight, function (a, b) { return b ? m.swap(a, { display: "inline-block" }, Jb, [a, "marginRight"]) : void 0; }), m.each({ margin: "", padding: "", border: "Width" }, function (a, b) { m.cssHooks[a + b] = { expand: function (c) { for (var d = 0, e = {}, f = "string" == typeof c ? c.split(" ") : [c]; 4 > d; d++)
            e[a + T[d] + b] = f[d] || f[d - 2] || f[0]; return e; } }, Gb.test(a) || (m.cssHooks[a + b].set = Wb); }), m.fn.extend({ css: function (a, b) { return V(this, function (a, b, c) { var d, e, f = {}, g = 0; if (m.isArray(b)) {
            for (d = Ib(a), e = b.length; e > g; g++)
                f[b[g]] = m.css(a, b[g], !1, d);
            return f;
        } return void 0 !== c ? m.style(a, b, c) : m.css(a, b); }, a, b, arguments.length > 1); }, show: function () { return Vb(this, !0); }, hide: function () { return Vb(this); }, toggle: function (a) { return "boolean" == typeof a ? a ? this.show() : this.hide() : this.each(function () { U(this) ? m(this).show() : m(this).hide(); }); } });
    function Zb(a, b, c, d, e) { return new Zb.prototype.init(a, b, c, d, e); }
    m.Tween = Zb, Zb.prototype = { constructor: Zb, init: function (a, b, c, d, e, f) {
            this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (m.cssNumber[c] ? "" : "px");
        }, cur: function () { var a = Zb.propHooks[this.prop]; return a && a.get ? a.get(this) : Zb.propHooks._default.get(this); }, run: function (a) { var b, c = Zb.propHooks[this.prop]; return this.pos = b = this.options.duration ? m.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Zb.propHooks._default.set(this), this; } }, Zb.prototype.init.prototype = Zb.prototype, Zb.propHooks = { _default: { get: function (a) { var b; return null == a.elem[a.prop] || a.elem.style && null != a.elem.style[a.prop] ? (b = m.css(a.elem, a.prop, ""), b && "auto" !== b ? b : 0) : a.elem[a.prop]; }, set: function (a) { m.fx.step[a.prop] ? m.fx.step[a.prop](a) : a.elem.style && (null != a.elem.style[m.cssProps[a.prop]] || m.cssHooks[a.prop]) ? m.style(a.elem, a.prop, a.now + a.unit) : a.elem[a.prop] = a.now; } } }, Zb.propHooks.scrollTop = Zb.propHooks.scrollLeft = { set: function (a) { a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now); } }, m.easing = { linear: function (a) { return a; }, swing: function (a) { return .5 - Math.cos(a * Math.PI) / 2; } }, m.fx = Zb.prototype.init, m.fx.step = {};
    var $b, _b, ac = /^(?:toggle|show|hide)$/, bc = new RegExp("^(?:([+-])=|)(" + S + ")([a-z%]*)$", "i"), cc = /queueHooks$/, dc = [ic], ec = { "*": [function (a, b) { var c = this.createTween(a, b), d = c.cur(), e = bc.exec(b), f = e && e[3] || (m.cssNumber[a] ? "" : "px"), g = (m.cssNumber[a] || "px" !== f && +d) && bc.exec(m.css(c.elem, a)), h = 1, i = 20; if (g && g[3] !== f) {
                f = f || g[3], e = e || [], g = +d || 1;
                do
                    h = h || ".5", g /= h, m.style(c.elem, a, g + f);
                while (h !== (h = c.cur() / d) && 1 !== h && --i);
            } return e && (g = c.start = +g || +d || 0, c.unit = f, c.end = e[1] ? g + (e[1] + 1) * e[2] : +e[2]), c; }] };
    function fc() { return setTimeout(function () { $b = void 0; }), $b = m.now(); }
    function gc(a, b) { var c, d = { height: a }, e = 0; for (b = b ? 1 : 0; 4 > e; e += 2 - b)
        c = T[e], d["margin" + c] = d["padding" + c] = a; return b && (d.opacity = d.width = a), d; }
    function hc(a, b, c) { for (var d, e = (ec[b] || []).concat(ec["*"]), f = 0, g = e.length; g > f; f++)
        if (d = e[f].call(c, b, a))
            return d; }
    function ic(a, b, c) { var d, e, f, g, h, i, j, l, n = this, o = {}, p = a.style, q = a.nodeType && U(a), r = m._data(a, "fxshow"); c.queue || (h = m._queueHooks(a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () { h.unqueued || i(); }), h.unqueued++, n.always(function () { n.always(function () { h.unqueued--, m.queue(a, "fx").length || h.empty.fire(); }); })), 1 === a.nodeType && ("height" in b || "width" in b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = m.css(a, "display"), l = "none" === j ? m._data(a, "olddisplay") || Fb(a.nodeName) : j, "inline" === l && "none" === m.css(a, "float") && (k.inlineBlockNeedsLayout && "inline" !== Fb(a.nodeName) ? p.zoom = 1 : p.display = "inline-block")), c.overflow && (p.overflow = "hidden", k.shrinkWrapBlocks() || n.always(function () { p.overflow = c.overflow[0], p.overflowX = c.overflow[1], p.overflowY = c.overflow[2]; })); for (d in b)
        if (e = b[d], ac.exec(e)) {
            if (delete b[d], f = f || "toggle" === e, e === (q ? "hide" : "show")) {
                if ("show" !== e || !r || void 0 === r[d])
                    continue;
                q = !0;
            }
            o[d] = r && r[d] || m.style(a, d);
        }
        else
            j = void 0; if (m.isEmptyObject(o))
        "inline" === ("none" === j ? Fb(a.nodeName) : j) && (p.display = j);
    else {
        r ? "hidden" in r && (q = r.hidden) : r = m._data(a, "fxshow", {}), f && (r.hidden = !q), q ? m(a).show() : n.done(function () { m(a).hide(); }), n.done(function () { var b; m._removeData(a, "fxshow"); for (b in o)
            m.style(a, b, o[b]); });
        for (d in o)
            g = hc(q ? r[d] : 0, d, n), d in r || (r[d] = g.start, q && (g.end = g.start, g.start = "width" === d || "height" === d ? 1 : 0));
    } }
    function jc(a, b) { var c, d, e, f, g; for (c in a)
        if (d = m.camelCase(c), e = b[d], f = a[c], m.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = m.cssHooks[d], g && "expand" in g) {
            f = g.expand(f), delete a[d];
            for (c in f)
                c in a || (a[c] = f[c], b[c] = e);
        }
        else
            b[d] = e; }
    function kc(a, b, c) { var d, e, f = 0, g = dc.length, h = m.Deferred().always(function () { delete i.elem; }), i = function () { if (e)
        return !1; for (var b = $b || fc(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++)
        j.tweens[g].run(f); return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1); }, j = h.promise({ elem: a, props: m.extend({}, b), opts: m.extend(!0, { specialEasing: {} }, c), originalProperties: b, originalOptions: c, startTime: $b || fc(), duration: c.duration, tweens: [], createTween: function (b, c) { var d = m.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing); return j.tweens.push(d), d; }, stop: function (b) { var c = 0, d = b ? j.tweens.length : 0; if (e)
            return this; for (e = !0; d > c; c++)
            j.tweens[c].run(1); return b ? h.resolveWith(a, [j, b]) : h.rejectWith(a, [j, b]), this; } }), k = j.props; for (jc(k, j.opts.specialEasing); g > f; f++)
        if (d = dc[f].call(j, a, k, j.opts))
            return d; return m.map(k, hc, j), m.isFunction(j.opts.start) && j.opts.start.call(a, j), m.fx.timer(m.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always); }
    m.Animation = m.extend(kc, { tweener: function (a, b) { m.isFunction(a) ? (b = a, a = ["*"]) : a = a.split(" "); for (var c, d = 0, e = a.length; e > d; d++)
            c = a[d], ec[c] = ec[c] || [], ec[c].unshift(b); }, prefilter: function (a, b) { b ? dc.unshift(a) : dc.push(a); } }), m.speed = function (a, b, c) { var d = a && "object" == typeof a ? m.extend({}, a) : { complete: c || !c && b || m.isFunction(a) && a, duration: a, easing: c && b || b && !m.isFunction(b) && b }; return d.duration = m.fx.off ? 0 : "number" == typeof d.duration ? d.duration : d.duration in m.fx.speeds ? m.fx.speeds[d.duration] : m.fx.speeds._default, (null == d.queue || d.queue === !0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () { m.isFunction(d.old) && d.old.call(this), d.queue && m.dequeue(this, d.queue); }, d; }, m.fn.extend({ fadeTo: function (a, b, c, d) { return this.filter(U).css("opacity", 0).show().end().animate({ opacity: b }, a, c, d); }, animate: function (a, b, c, d) { var e = m.isEmptyObject(a), f = m.speed(b, c, d), g = function () { var b = kc(this, m.extend({}, a), f); (e || m._data(this, "finish")) && b.stop(!0); }; return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g); }, stop: function (a, b, c) { var d = function (a) { var b = a.stop; delete a.stop, b(c); }; return "string" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || "fx", []), this.each(function () { var b = !0, e = null != a && a + "queueHooks", f = m.timers, g = m._data(this); if (e)
            g[e] && g[e].stop && d(g[e]);
        else
            for (e in g)
                g[e] && g[e].stop && cc.test(e) && d(g[e]); for (e = f.length; e--;)
            f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1)); (b || !c) && m.dequeue(this, a); }); }, finish: function (a) { return a !== !1 && (a = a || "fx"), this.each(function () { var b, c = m._data(this), d = c[a + "queue"], e = c[a + "queueHooks"], f = m.timers, g = d ? d.length : 0; for (c.finish = !0, m.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;)
            f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1)); for (b = 0; g > b; b++)
            d[b] && d[b].finish && d[b].finish.call(this); delete c.finish; }); } }), m.each(["toggle", "show", "hide"], function (a, b) { var c = m.fn[b]; m.fn[b] = function (a, d, e) { return null == a || "boolean" == typeof a ? c.apply(this, arguments) : this.animate(gc(b, !0), a, d, e); }; }), m.each({ slideDown: gc("show"), slideUp: gc("hide"), slideToggle: gc("toggle"), fadeIn: { opacity: "show" }, fadeOut: { opacity: "hide" }, fadeToggle: { opacity: "toggle" } }, function (a, b) { m.fn[a] = function (a, c, d) { return this.animate(b, a, c, d); }; }), m.timers = [], m.fx.tick = function () { var a, b = m.timers, c = 0; for ($b = m.now(); c < b.length; c++)
        a = b[c], a() || b[c] !== a || b.splice(c--, 1); b.length || m.fx.stop(), $b = void 0; }, m.fx.timer = function (a) { m.timers.push(a), a() ? m.fx.start() : m.timers.pop(); }, m.fx.interval = 13, m.fx.start = function () { _b || (_b = setInterval(m.fx.tick, m.fx.interval)); }, m.fx.stop = function () { clearInterval(_b), _b = null; }, m.fx.speeds = { slow: 600, fast: 200, _default: 400 }, m.fn.delay = function (a, b) { return a = m.fx ? m.fx.speeds[a] || a : a, b = b || "fx", this.queue(b, function (b, c) { var d = setTimeout(b, a); c.stop = function () { clearTimeout(d); }; }); }, function () { var a, b, c, d, e; b = y.createElement("div"), b.setAttribute("className", "t"), b.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>", d = b.getElementsByTagName("a")[0], c = y.createElement("select"), e = c.appendChild(y.createElement("option")), a = b.getElementsByTagName("input")[0], d.style.cssText = "top:1px", k.getSetAttribute = "t" !== b.className, k.style = /top/.test(d.getAttribute("style")), k.hrefNormalized = "/a" === d.getAttribute("href"), k.checkOn = !!a.value, k.optSelected = e.selected, k.enctype = !!y.createElement("form").enctype, c.disabled = !0, k.optDisabled = !e.disabled, a = y.createElement("input"), a.setAttribute("value", ""), k.input = "" === a.getAttribute("value"), a.value = "t", a.setAttribute("type", "radio"), k.radioValue = "t" === a.value; }();
    var lc = /\r/g;
    m.fn.extend({ val: function (a) { var b, c, d, e = this[0]; {
            if (arguments.length)
                return d = m.isFunction(a), this.each(function (c) { var e; 1 === this.nodeType && (e = d ? a.call(this, c, m(this).val()) : a, null == e ? e = "" : "number" == typeof e ? e += "" : m.isArray(e) && (e = m.map(e, function (a) { return null == a ? "" : a + ""; })), b = m.valHooks[this.type] || m.valHooks[this.nodeName.toLowerCase()], b && "set" in b && void 0 !== b.set(this, e, "value") || (this.value = e)); });
            if (e)
                return b = m.valHooks[e.type] || m.valHooks[e.nodeName.toLowerCase()], b && "get" in b && void 0 !== (c = b.get(e, "value")) ? c : (c = e.value, "string" == typeof c ? c.replace(lc, "") : null == c ? "" : c);
        } } }), m.extend({ valHooks: { option: { get: function (a) { var b = m.find.attr(a, "value"); return null != b ? b : m.trim(m.text(a)); } }, select: { get: function (a) { for (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++)
                    if (c = d[i], !(!c.selected && i !== e || (k.optDisabled ? c.disabled : null !== c.getAttribute("disabled")) || c.parentNode.disabled && m.nodeName(c.parentNode, "optgroup"))) {
                        if (b = m(c).val(), f)
                            return b;
                        g.push(b);
                    } return g; }, set: function (a, b) { var c, d, e = a.options, f = m.makeArray(b), g = e.length; while (g--)
                    if (d = e[g], m.inArray(m.valHooks.option.get(d), f) >= 0)
                        try {
                            d.selected = c = !0;
                        }
                        catch (h) {
                            d.scrollHeight;
                        }
                    else
                        d.selected = !1; return c || (a.selectedIndex = -1), e; } } } }), m.each(["radio", "checkbox"], function () { m.valHooks[this] = { set: function (a, b) { return m.isArray(b) ? a.checked = m.inArray(m(a).val(), b) >= 0 : void 0; } }, k.checkOn || (m.valHooks[this].get = function (a) { return null === a.getAttribute("value") ? "on" : a.value; }); });
    var mc, nc, oc = m.expr.attrHandle, pc = /^(?:checked|selected)$/i, qc = k.getSetAttribute, rc = k.input;
    m.fn.extend({ attr: function (a, b) { return V(this, m.attr, a, b, arguments.length > 1); }, removeAttr: function (a) { return this.each(function () { m.removeAttr(this, a); }); } }), m.extend({ attr: function (a, b, c) { var d, e, f = a.nodeType; if (a && 3 !== f && 8 !== f && 2 !== f)
            return typeof a.getAttribute === K ? m.prop(a, b, c) : (1 === f && m.isXMLDoc(a) || (b = b.toLowerCase(), d = m.attrHooks[b] || (m.expr.match.bool.test(b) ? nc : mc)), void 0 === c ? d && "get" in d && null !== (e = d.get(a, b)) ? e : (e = m.find.attr(a, b), null == e ? void 0 : e) : null !== c ? d && "set" in d && void 0 !== (e = d.set(a, c, b)) ? e : (a.setAttribute(b, c + ""), c) : void m.removeAttr(a, b)); }, removeAttr: function (a, b) { var c, d, e = 0, f = b && b.match(E); if (f && 1 === a.nodeType)
            while (c = f[e++])
                d = m.propFix[c] || c, m.expr.match.bool.test(c) ? rc && qc || !pc.test(c) ? a[d] = !1 : a[m.camelCase("default-" + c)] = a[d] = !1 : m.attr(a, c, ""), a.removeAttribute(qc ? c : d); }, attrHooks: { type: { set: function (a, b) { if (!k.radioValue && "radio" === b && m.nodeName(a, "input")) {
                    var c = a.value;
                    return a.setAttribute("type", b), c && (a.value = c), b;
                } } } } }), nc = { set: function (a, b, c) { return b === !1 ? m.removeAttr(a, c) : rc && qc || !pc.test(c) ? a.setAttribute(!qc && m.propFix[c] || c, c) : a[m.camelCase("default-" + c)] = a[c] = !0, c; } }, m.each(m.expr.match.bool.source.match(/\w+/g), function (a, b) { var c = oc[b] || m.find.attr; oc[b] = rc && qc || !pc.test(b) ? function (a, b, d) { var e, f; return d || (f = oc[b], oc[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, oc[b] = f), e; } : function (a, b, c) { return c ? void 0 : a[m.camelCase("default-" + b)] ? b.toLowerCase() : null; }; }), rc && qc || (m.attrHooks.value = { set: function (a, b, c) { return m.nodeName(a, "input") ? void (a.defaultValue = b) : mc && mc.set(a, b, c); } }), qc || (mc = { set: function (a, b, c) { var d = a.getAttributeNode(c); return d || a.setAttributeNode(d = a.ownerDocument.createAttribute(c)), d.value = b += "", "value" === c || b === a.getAttribute(c) ? b : void 0; } }, oc.id = oc.name = oc.coords = function (a, b, c) { var d; return c ? void 0 : (d = a.getAttributeNode(b)) && "" !== d.value ? d.value : null; }, m.valHooks.button = { get: function (a, b) { var c = a.getAttributeNode(b); return c && c.specified ? c.value : void 0; }, set: mc.set }, m.attrHooks.contenteditable = { set: function (a, b, c) { mc.set(a, "" === b ? !1 : b, c); } }, m.each(["width", "height"], function (a, b) { m.attrHooks[b] = { set: function (a, c) { return "" === c ? (a.setAttribute(b, "auto"), c) : void 0; } }; })), k.style || (m.attrHooks.style = { get: function (a) { return a.style.cssText || void 0; }, set: function (a, b) { return a.style.cssText = b + ""; } });
    var sc = /^(?:input|select|textarea|button|object)$/i, tc = /^(?:a|area)$/i;
    m.fn.extend({ prop: function (a, b) { return V(this, m.prop, a, b, arguments.length > 1); }, removeProp: function (a) { return a = m.propFix[a] || a, this.each(function () { try {
            this[a] = void 0, delete this[a];
        }
        catch (b) { } }); } }), m.extend({ propFix: { "for": "htmlFor", "class": "className" }, prop: function (a, b, c) { var d, e, f, g = a.nodeType; if (a && 3 !== g && 8 !== g && 2 !== g)
            return f = 1 !== g || !m.isXMLDoc(a), f && (b = m.propFix[b] || b, e = m.propHooks[b]), void 0 !== c ? e && "set" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && "get" in e && null !== (d = e.get(a, b)) ? d : a[b]; }, propHooks: { tabIndex: { get: function (a) { var b = m.find.attr(a, "tabindex"); return b ? parseInt(b, 10) : sc.test(a.nodeName) || tc.test(a.nodeName) && a.href ? 0 : -1; } } } }), k.hrefNormalized || m.each(["href", "src"], function (a, b) { m.propHooks[b] = { get: function (a) { return a.getAttribute(b, 4); } }; }), k.optSelected || (m.propHooks.selected = { get: function (a) { var b = a.parentNode; return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex), null; } }), m.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () { m.propFix[this.toLowerCase()] = this; }), k.enctype || (m.propFix.enctype = "encoding");
    var uc = /[\t\r\n\f]/g;
    m.fn.extend({ addClass: function (a) { var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a; if (m.isFunction(a))
            return this.each(function (b) { m(this).addClass(a.call(this, b, this.className)); }); if (j)
            for (b = (a || "").match(E) || []; i > h; h++)
                if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(uc, " ") : " ")) {
                    f = 0;
                    while (e = b[f++])
                        d.indexOf(" " + e + " ") < 0 && (d += e + " ");
                    g = m.trim(d), c.className !== g && (c.className = g);
                } return this; }, removeClass: function (a) { var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === arguments.length || "string" == typeof a && a; if (m.isFunction(a))
            return this.each(function (b) { m(this).removeClass(a.call(this, b, this.className)); }); if (j)
            for (b = (a || "").match(E) || []; i > h; h++)
                if (c = this[h], d = 1 === c.nodeType && (c.className ? (" " + c.className + " ").replace(uc, " ") : "")) {
                    f = 0;
                    while (e = b[f++])
                        while (d.indexOf(" " + e + " ") >= 0)
                            d = d.replace(" " + e + " ", " ");
                    g = a ? m.trim(d) : "", c.className !== g && (c.className = g);
                } return this; }, toggleClass: function (a, b) { var c = typeof a; return "boolean" == typeof b && "string" === c ? b ? this.addClass(a) : this.removeClass(a) : this.each(m.isFunction(a) ? function (c) { m(this).toggleClass(a.call(this, c, this.className, b), b); } : function () { if ("string" === c) {
            var b, d = 0, e = m(this), f = a.match(E) || [];
            while (b = f[d++])
                e.hasClass(b) ? e.removeClass(b) : e.addClass(b);
        }
        else
            (c === K || "boolean" === c) && (this.className && m._data(this, "__className__", this.className), this.className = this.className || a === !1 ? "" : m._data(this, "__className__") || ""); }); }, hasClass: function (a) { for (var b = " " + a + " ", c = 0, d = this.length; d > c; c++)
            if (1 === this[c].nodeType && (" " + this[c].className + " ").replace(uc, " ").indexOf(b) >= 0)
                return !0; return !1; } }), m.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "), function (a, b) { m.fn[b] = function (a, c) { return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b); }; }), m.fn.extend({ hover: function (a, b) { return this.mouseenter(a).mouseleave(b || a); }, bind: function (a, b, c) { return this.on(a, null, b, c); }, unbind: function (a, b) { return this.off(a, null, b); }, delegate: function (a, b, c, d) { return this.on(b, a, c, d); }, undelegate: function (a, b, c) { return 1 === arguments.length ? this.off(a, "**") : this.off(b, a || "**", c); } });
    var vc = m.now(), wc = /\?/, xc = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
    m.parseJSON = function (b) { if (a.JSON && a.JSON.parse)
        return a.JSON.parse(b + ""); var c, d = null, e = m.trim(b + ""); return e && !m.trim(e.replace(xc, function (a, b, e, f) { return c && b && (d = 0), 0 === d ? a : (c = e || b, d += !f - !e, ""); })) ? Function("return " + e)() : m.error("Invalid JSON: " + b); }, m.parseXML = function (b) { var c, d; if (!b || "string" != typeof b)
        return null; try {
        a.DOMParser ? (d = new DOMParser, c = d.parseFromString(b, "text/xml")) : (c = new ActiveXObject("Microsoft.XMLDOM"), c.async = "false", c.loadXML(b));
    }
    catch (e) {
        c = void 0;
    } return c && c.documentElement && !c.getElementsByTagName("parsererror").length || m.error("Invalid XML: " + b), c; };
    var yc, zc, Ac = /#.*$/, Bc = /([?&])_=[^&]*/, Cc = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm, Dc = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Ec = /^(?:GET|HEAD)$/, Fc = /^\/\//, Gc = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, Hc = {}, Ic = {}, Jc = "*/".concat("*");
    try {
        zc = location.href;
    }
    catch (Kc) {
        zc = y.createElement("a"), zc.href = "", zc = zc.href;
    }
    yc = Gc.exec(zc.toLowerCase()) || [];
    function Lc(a) { return function (b, c) { "string" != typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase().match(E) || []; if (m.isFunction(c))
        while (d = f[e++])
            "+" === d.charAt(0) ? (d = d.slice(1) || "*", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c); }; }
    function Mc(a, b, c, d) { var e = {}, f = a === Ic; function g(h) { var i; return e[h] = !0, m.each(a[h] || [], function (a, h) { var j = h(b, c, d); return "string" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1); }), i; } return g(b.dataTypes[0]) || !e["*"] && g("*"); }
    function Nc(a, b) { var c, d, e = m.ajaxSettings.flatOptions || {}; for (d in b)
        void 0 !== b[d] && ((e[d] ? a : c || (c = {}))[d] = b[d]); return c && m.extend(!0, a, c), a; }
    function Oc(a, b, c) { var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i[0])
        i.shift(), void 0 === e && (e = a.mimeType || b.getResponseHeader("Content-Type")); if (e)
        for (g in h)
            if (h[g] && h[g].test(e)) {
                i.unshift(g);
                break;
            } if (i[0] in c)
        f = i[0];
    else {
        for (g in c) {
            if (!i[0] || a.converters[g + " " + i[0]]) {
                f = g;
                break;
            }
            d || (d = g);
        }
        f = f || d;
    } return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0; }
    function Pc(a, b, c, d) { var e, f, g, h, i, j = {}, k = a.dataTypes.slice(); if (k[1])
        for (g in a.converters)
            j[g.toLowerCase()] = a.converters[g]; f = k.shift(); while (f)
        if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift())
            if ("*" === f)
                f = i;
            else if ("*" !== i && i !== f) {
                if (g = j[i + " " + f] || j["* " + f], !g)
                    for (e in j)
                        if (h = e.split(" "), h[1] === f && (g = j[i + " " + h[0]] || j["* " + h[0]])) {
                            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));
                            break;
                        }
                if (g !== !0)
                    if (g && a["throws"])
                        b = g(b);
                    else
                        try {
                            b = g(b);
                        }
                        catch (l) {
                            return { state: "parsererror", error: g ? l : "No conversion from " + i + " to " + f };
                        }
            } return { state: "success", data: b }; }
    m.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: zc, type: "GET", isLocal: Dc.test(yc[1]), global: !0, processData: !0, async: !0, contentType: "application/x-www-form-urlencoded; charset=UTF-8", accepts: { "*": Jc, text: "text/plain", html: "text/html", xml: "application/xml, text/xml", json: "application/json, text/javascript" }, contents: { xml: /xml/, html: /html/, json: /json/ }, responseFields: { xml: "responseXML", text: "responseText", json: "responseJSON" }, converters: { "* text": String, "text html": !0, "text json": m.parseJSON, "text xml": m.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function (a, b) { return b ? Nc(Nc(a, m.ajaxSettings), b) : Nc(m.ajaxSettings, a); }, ajaxPrefilter: Lc(Hc), ajaxTransport: Lc(Ic), ajax: function (a, b) { "object" == typeof a && (b = a, a = void 0), b = b || {}; var c, d, e, f, g, h, i, j, k = m.ajaxSetup({}, b), l = k.context || k, n = k.context && (l.nodeType || l.jquery) ? m(l) : m.event, o = m.Deferred(), p = m.Callbacks("once memory"), q = k.statusCode || {}, r = {}, s = {}, t = 0, u = "canceled", v = { readyState: 0, getResponseHeader: function (a) { var b; if (2 === t) {
                if (!j) {
                    j = {};
                    while (b = Cc.exec(f))
                        j[b[1].toLowerCase()] = b[2];
                }
                b = j[a.toLowerCase()];
            } return null == b ? null : b; }, getAllResponseHeaders: function () { return 2 === t ? f : null; }, setRequestHeader: function (a, b) { var c = a.toLowerCase(); return t || (a = s[c] = s[c] || a, r[a] = b), this; }, overrideMimeType: function (a) { return t || (k.mimeType = a), this; }, statusCode: function (a) { var b; if (a)
                if (2 > t)
                    for (b in a)
                        q[b] = [q[b], a[b]];
                else
                    v.always(a[v.status]); return this; }, abort: function (a) { var b = a || u; return i && i.abort(b), x(0, b), this; } }; if (o.promise(v).complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a || k.url || zc) + "").replace(Ac, "").replace(Fc, yc[1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim(k.dataType || "*").toLowerCase().match(E) || [""], null == k.crossDomain && (c = Gc.exec(k.url.toLowerCase()), k.crossDomain = !(!c || c[1] === yc[1] && c[2] === yc[2] && (c[3] || ("http:" === c[1] ? "80" : "443")) === (yc[3] || ("http:" === yc[1] ? "80" : "443")))), k.data && k.processData && "string" != typeof k.data && (k.data = m.param(k.data, k.traditional)), Mc(Hc, k, b, v), 2 === t)
            return v; h = k.global, h && 0 === m.active++ && m.event.trigger("ajaxStart"), k.type = k.type.toUpperCase(), k.hasContent = !Ec.test(k.type), e = k.url, k.hasContent || (k.data && (e = k.url += (wc.test(e) ? "&" : "?") + k.data, delete k.data), k.cache === !1 && (k.url = Bc.test(e) ? e.replace(Bc, "$1_=" + vc++) : e + (wc.test(e) ? "&" : "?") + "_=" + vc++)), k.ifModified && (m.lastModified[e] && v.setRequestHeader("If-Modified-Since", m.lastModified[e]), m.etag[e] && v.setRequestHeader("If-None-Match", m.etag[e])), (k.data && k.hasContent && k.contentType !== !1 || b.contentType) && v.setRequestHeader("Content-Type", k.contentType), v.setRequestHeader("Accept", k.dataTypes[0] && k.accepts[k.dataTypes[0]] ? k.accepts[k.dataTypes[0]] + ("*" !== k.dataTypes[0] ? ", " + Jc + "; q=0.01" : "") : k.accepts["*"]); for (d in k.headers)
            v.setRequestHeader(d, k.headers[d]); if (k.beforeSend && (k.beforeSend.call(l, v, k) === !1 || 2 === t))
            return v.abort(); u = "abort"; for (d in { success: 1, error: 1, complete: 1 })
            v[d](k[d]); if (i = Mc(Ic, k, b, v)) {
            v.readyState = 1, h && n.trigger("ajaxSend", [v, k]), k.async && k.timeout > 0 && (g = setTimeout(function () { v.abort("timeout"); }, k.timeout));
            try {
                t = 1, i.send(r, x);
            }
            catch (w) {
                if (!(2 > t))
                    throw w;
                x(-1, w);
            }
        }
        else
            x(-1, "No Transport"); function x(a, b, c, d) { var j, r, s, u, w, x = b; 2 !== t && (t = 2, g && clearTimeout(g), i = void 0, f = d || "", v.readyState = a > 0 ? 4 : 0, j = a >= 200 && 300 > a || 304 === a, c && (u = Oc(k, v, c)), u = Pc(k, u, v, j), j ? (k.ifModified && (w = v.getResponseHeader("Last-Modified"), w && (m.lastModified[e] = w), w = v.getResponseHeader("etag"), w && (m.etag[e] = w)), 204 === a || "HEAD" === k.type ? x = "nocontent" : 304 === a ? x = "notmodified" : (x = u.state, r = u.data, s = u.error, j = !s)) : (s = x, (a || !x) && (x = "error", 0 > a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j ? o.resolveWith(l, [r, x, v]) : o.rejectWith(l, [v, x, s]), v.statusCode(q), q = void 0, h && n.trigger(j ? "ajaxSuccess" : "ajaxError", [v, k, j ? r : s]), p.fireWith(l, [v, x]), h && (n.trigger("ajaxComplete", [v, k]), --m.active || m.event.trigger("ajaxStop"))); } return v; }, getJSON: function (a, b, c) { return m.get(a, b, c, "json"); }, getScript: function (a, b) { return m.get(a, void 0, b, "script"); } }), m.each(["get", "post"], function (a, b) { m[b] = function (a, c, d, e) { return m.isFunction(c) && (e = e || d, d = c, c = void 0), m.ajax({ url: a, type: b, dataType: e, data: c, success: d }); }; }), m.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (a, b) { m.fn[b] = function (a) { return this.on(b, a); }; }), m._evalUrl = function (a) { return m.ajax({ url: a, type: "GET", dataType: "script", async: !1, global: !1, "throws": !0 }); }, m.fn.extend({ wrapAll: function (a) { if (m.isFunction(a))
            return this.each(function (b) { m(this).wrapAll(a.call(this, b)); }); if (this[0]) {
            var b = m(a, this[0].ownerDocument).eq(0).clone(!0);
            this[0].parentNode && b.insertBefore(this[0]), b.map(function () { var a = this; while (a.firstChild && 1 === a.firstChild.nodeType)
                a = a.firstChild; return a; }).append(this);
        } return this; }, wrapInner: function (a) { return this.each(m.isFunction(a) ? function (b) { m(this).wrapInner(a.call(this, b)); } : function () { var b = m(this), c = b.contents(); c.length ? c.wrapAll(a) : b.append(a); }); }, wrap: function (a) { var b = m.isFunction(a); return this.each(function (c) { m(this).wrapAll(b ? a.call(this, c) : a); }); }, unwrap: function () { return this.parent().each(function () { m.nodeName(this, "body") || m(this).replaceWith(this.childNodes); }).end(); } }), m.expr.filters.hidden = function (a) { return a.offsetWidth <= 0 && a.offsetHeight <= 0 || !k.reliableHiddenOffsets() && "none" === (a.style && a.style.display || m.css(a, "display")); }, m.expr.filters.visible = function (a) { return !m.expr.filters.hidden(a); };
    var Qc = /%20/g, Rc = /\[\]$/, Sc = /\r?\n/g, Tc = /^(?:submit|button|image|reset|file)$/i, Uc = /^(?:input|select|textarea|keygen)/i;
    function Vc(a, b, c, d) { var e; if (m.isArray(b))
        m.each(b, function (b, e) { c || Rc.test(a) ? d(a, e) : Vc(a + "[" + ("object" == typeof e ? b : "") + "]", e, c, d); });
    else if (c || "object" !== m.type(b))
        d(a, b);
    else
        for (e in b)
            Vc(a + "[" + e + "]", b[e], c, d); }
    m.param = function (a, b) { var c, d = [], e = function (a, b) { b = m.isFunction(b) ? b() : null == b ? "" : b, d[d.length] = encodeURIComponent(a) + "=" + encodeURIComponent(b); }; if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray(a) || a.jquery && !m.isPlainObject(a))
        m.each(a, function () { e(this.name, this.value); });
    else
        for (c in a)
            Vc(c, a[c], b, e); return d.join("&").replace(Qc, "+"); }, m.fn.extend({ serialize: function () { return m.param(this.serializeArray()); }, serializeArray: function () { return this.map(function () { var a = m.prop(this, "elements"); return a ? m.makeArray(a) : this; }).filter(function () { var a = this.type; return this.name && !m(this).is(":disabled") && Uc.test(this.nodeName) && !Tc.test(a) && (this.checked || !W.test(a)); }).map(function (a, b) { var c = m(this).val(); return null == c ? null : m.isArray(c) ? m.map(c, function (a) { return { name: b.name, value: a.replace(Sc, "\r\n") }; }) : { name: b.name, value: c.replace(Sc, "\r\n") }; }).get(); } }), m.ajaxSettings.xhr = void 0 !== a.ActiveXObject ? function () { return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && Zc() || $c(); } : Zc;
    var Wc = 0, Xc = {}, Yc = m.ajaxSettings.xhr();
    a.ActiveXObject && m(a).on("unload", function () { for (var a in Xc)
        Xc[a](void 0, !0); }), k.cors = !!Yc && "withCredentials" in Yc, Yc = k.ajax = !!Yc, Yc && m.ajaxTransport(function (a) { if (!a.crossDomain || k.cors) {
        var b;
        return { send: function (c, d) { var e, f = a.xhr(), g = ++Wc; if (f.open(a.type, a.url, a.async, a.username, a.password), a.xhrFields)
                for (e in a.xhrFields)
                    f[e] = a.xhrFields[e]; a.mimeType && f.overrideMimeType && f.overrideMimeType(a.mimeType), a.crossDomain || c["X-Requested-With"] || (c["X-Requested-With"] = "XMLHttpRequest"); for (e in c)
                void 0 !== c[e] && f.setRequestHeader(e, c[e] + ""); f.send(a.hasContent && a.data || null), b = function (c, e) { var h, i, j; if (b && (e || 4 === f.readyState))
                if (delete Xc[g], b = void 0, f.onreadystatechange = m.noop, e)
                    4 !== f.readyState && f.abort();
                else {
                    j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText);
                    try {
                        i = f.statusText;
                    }
                    catch (k) {
                        i = "";
                    }
                    h || !a.isLocal || a.crossDomain ? 1223 === h && (h = 204) : h = j.text ? 200 : 404;
                } j && d(h, i, j, f.getAllResponseHeaders()); }, a.async ? 4 === f.readyState ? setTimeout(b) : f.onreadystatechange = Xc[g] = b : b(); }, abort: function () { b && b(void 0, !0); } };
    } });
    function Zc() { try {
        return new a.XMLHttpRequest;
    }
    catch (b) { } }
    function $c() { try {
        return new a.ActiveXObject("Microsoft.XMLHTTP");
    }
    catch (b) { } }
    m.ajaxSetup({ accepts: { script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript" }, contents: { script: /(?:java|ecma)script/ }, converters: { "text script": function (a) { return m.globalEval(a), a; } } }), m.ajaxPrefilter("script", function (a) { void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = "GET", a.global = !1); }), m.ajaxTransport("script", function (a) { if (a.crossDomain) {
        var b, c = y.head || m("head")[0] || y.documentElement;
        return { send: function (d, e) { b = y.createElement("script"), b.async = !0, a.scriptCharset && (b.charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function (a, c) { (c || !b.readyState || /loaded|complete/.test(b.readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild(b), b = null, c || e(200, "success")); }, c.insertBefore(b, c.firstChild); }, abort: function () { b && b.onload(void 0, !0); } };
    } });
    var _c = [], ad = /(=)\?(?=&|$)|\?\?/;
    m.ajaxSetup({ jsonp: "callback", jsonpCallback: function () { var a = _c.pop() || m.expando + "_" + vc++; return this[a] = !0, a; } }), m.ajaxPrefilter("json jsonp", function (b, c, d) { var e, f, g, h = b.jsonp !== !1 && (ad.test(b.url) ? "url" : "string" == typeof b.data && !(b.contentType || "").indexOf("application/x-www-form-urlencoded") && ad.test(b.data) && "data"); return h || "jsonp" === b.dataTypes[0] ? (e = b.jsonpCallback = m.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(ad, "$1" + e) : b.jsonp !== !1 && (b.url += (wc.test(b.url) ? "&" : "?") + b.jsonp + "=" + e), b.converters["script json"] = function () { return g || m.error(e + " was not called"), g[0]; }, b.dataTypes[0] = "json", f = a[e], a[e] = function () { g = arguments; }, d.always(function () { a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, _c.push(e)), g && m.isFunction(f) && f(g[0]), g = f = void 0; }), "script") : void 0; }), m.parseHTML = function (a, b, c) { if (!a || "string" != typeof a)
        return null; "boolean" == typeof b && (c = b, b = !1), b = b || y; var d = u.exec(a), e = !c && []; return d ? [b.createElement(d[1])] : (d = m.buildFragment([a], b, e), e && e.length && m(e).remove(), m.merge([], d.childNodes)); };
    var bd = m.fn.load;
    m.fn.load = function (a, b, c) { if ("string" != typeof a && bd)
        return bd.apply(this, arguments); var d, e, f, g = this, h = a.indexOf(" "); return h >= 0 && (d = m.trim(a.slice(h, a.length)), a = a.slice(0, h)), m.isFunction(b) ? (c = b, b = void 0) : b && "object" == typeof b && (f = "POST"), g.length > 0 && m.ajax({ url: a, type: f, dataType: "html", data: b }).done(function (a) { e = arguments, g.html(d ? m("<div>").append(m.parseHTML(a)).find(d) : a); }).complete(c && function (a, b) { g.each(c, e || [a.responseText, b, a]); }), this; }, m.expr.filters.animated = function (a) { return m.grep(m.timers, function (b) { return a === b.elem; }).length; };
    var cd = a.document.documentElement;
    function dd(a) { return m.isWindow(a) ? a : 9 === a.nodeType ? a.defaultView || a.parentWindow : !1; }
    m.offset = { setOffset: function (a, b, c) { var d, e, f, g, h, i, j, k = m.css(a, "position"), l = m(a), n = {}; "static" === k && (a.style.position = "relative"), h = l.offset(), f = m.css(a, "top"), i = m.css(a, "left"), j = ("absolute" === k || "fixed" === k) && m.inArray("auto", [f, i]) > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), m.isFunction(b) && (b = b.call(a, c, h)), null != b.top && (n.top = b.top - h.top + g), null != b.left && (n.left = b.left - h.left + e), "using" in b ? b.using.call(a, n) : l.css(n); } }, m.fn.extend({ offset: function (a) { if (arguments.length)
            return void 0 === a ? this : this.each(function (b) { m.offset.setOffset(this, a, b); }); var b, c, d = { top: 0, left: 0 }, e = this[0], f = e && e.ownerDocument; if (f)
            return b = f.documentElement, m.contains(b, e) ? (typeof e.getBoundingClientRect !== K && (d = e.getBoundingClientRect()), c = dd(f), { top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), left: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0) }) : d; }, position: function () { if (this[0]) {
            var a, b, c = { top: 0, left: 0 }, d = this[0];
            return "fixed" === m.css(d, "position") ? b = d.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), m.nodeName(a[0], "html") || (c = a.offset()), c.top += m.css(a[0], "borderTopWidth", !0), c.left += m.css(a[0], "borderLeftWidth", !0)), { top: b.top - c.top - m.css(d, "marginTop", !0), left: b.left - c.left - m.css(d, "marginLeft", !0) };
        } }, offsetParent: function () { return this.map(function () { var a = this.offsetParent || cd; while (a && !m.nodeName(a, "html") && "static" === m.css(a, "position"))
            a = a.offsetParent; return a || cd; }); } }), m.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function (a, b) { var c = /Y/.test(b); m.fn[a] = function (d) { return V(this, function (a, d, e) { var f = dd(a); return void 0 === e ? f ? b in f ? f[b] : f.document.documentElement[d] : a[d] : void (f ? f.scrollTo(c ? m(f).scrollLeft() : e, c ? e : m(f).scrollTop()) : a[d] = e); }, a, d, arguments.length, null); }; }), m.each(["top", "left"], function (a, b) { m.cssHooks[b] = Lb(k.pixelPosition, function (a, c) { return c ? (c = Jb(a, b), Hb.test(c) ? m(a).position()[b] + "px" : c) : void 0; }); }), m.each({ Height: "height", Width: "width" }, function (a, b) { m.each({ padding: "inner" + a, content: b, "": "outer" + a }, function (c, d) { m.fn[d] = function (d, e) { var f = arguments.length && (c || "boolean" != typeof d), g = c || (d === !0 || e === !0 ? "margin" : "border"); return V(this, function (b, c, d) { var e; return m.isWindow(b) ? b.document.documentElement["client" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body["scroll" + a], e["scroll" + a], b.body["offset" + a], e["offset" + a], e["client" + a])) : void 0 === d ? m.css(b, c, g) : m.style(b, c, d, g); }, b, f ? d : void 0, f, null); }; }); }), m.fn.size = function () { return this.length; }, m.fn.andSelf = m.fn.addBack, "function" == typeof define && define.amd && define("jquery", [], function () { return m; });
    var ed = a.jQuery, fd = a.$;
    return m.noConflict = function (b) { return a.$ === m && (a.$ = fd), b && a.jQuery === m && (a.jQuery = ed), m; }, typeof b === K && (a.jQuery = a.$ = m), m;
});
!function () {
    var d3 = {
        version: "3.5.17"
    };
    var d3_arraySlice = [].slice, d3_array = function (list) {
        return d3_arraySlice.call(list);
    };
    var d3_document = this.document;
    function d3_documentElement(node) {
        return node && (node.ownerDocument || node.document || node).documentElement;
    }
    function d3_window(node) {
        return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
    }
    if (d3_document) {
        try {
            d3_array(d3_document.documentElement.childNodes)[0].nodeType;
        }
        catch (e) {
            d3_array = function (list) {
                var i = list.length, array = new Array(i);
                while (i--)
                    array[i] = list[i];
                return array;
            };
        }
    }
    if (!Date.now)
        Date.now = function () {
            return +new Date();
        };
    if (d3_document) {
        try {
            d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
        }
        catch (error) {
            var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
            d3_element_prototype.setAttribute = function (name, value) {
                d3_element_setAttribute.call(this, name, value + "");
            };
            d3_element_prototype.setAttributeNS = function (space, local, value) {
                d3_element_setAttributeNS.call(this, space, local, value + "");
            };
            d3_style_prototype.setProperty = function (name, value, priority) {
                d3_style_setProperty.call(this, name, value + "", priority);
            };
        }
    }
    d3.ascending = d3_ascending;
    function d3_ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }
    d3.descending = function (a, b) {
        return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    };
    d3.min = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && a > b)
                    a = b;
        }
        else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && a > b)
                    a = b;
        }
        return a;
    };
    d3.max = function (array, f) {
        var i = -1, n = array.length, a, b;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null && b > a)
                    a = b;
        }
        else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b > a)
                    a = b;
        }
        return a;
    };
    d3.extent = function (array, f) {
        var i = -1, n = array.length, a, b, c;
        if (arguments.length === 1) {
            while (++i < n)
                if ((b = array[i]) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = array[i]) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        }
        else {
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null && b >= b) {
                    a = c = b;
                    break;
                }
            while (++i < n)
                if ((b = f.call(array, array[i], i)) != null) {
                    if (a > b)
                        a = b;
                    if (c < b)
                        c = b;
                }
        }
        return [a, c];
    };
    function d3_number(x) {
        return x === null ? NaN : +x;
    }
    function d3_numeric(x) {
        return !isNaN(x);
    }
    d3.sum = function (array, f) {
        var s = 0, n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = +array[i]))
                    s += a;
        }
        else {
            while (++i < n)
                if (d3_numeric(a = +f.call(array, array[i], i)))
                    s += a;
        }
        return s;
    };
    d3.mean = function (array, f) {
        var s = 0, n = array.length, a, i = -1, j = n;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    s += a;
                else
                    --j;
        }
        else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    s += a;
                else
                    --j;
        }
        if (j)
            return s / j;
    };
    d3.quantile = function (values, p) {
        var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
        return e ? v + e * (values[h] - v) : v;
    };
    d3.median = function (array, f) {
        var numbers = [], n = array.length, a, i = -1;
        if (arguments.length === 1) {
            while (++i < n)
                if (d3_numeric(a = d3_number(array[i])))
                    numbers.push(a);
        }
        else {
            while (++i < n)
                if (d3_numeric(a = d3_number(f.call(array, array[i], i))))
                    numbers.push(a);
        }
        if (numbers.length)
            return d3.quantile(numbers.sort(d3_ascending), .5);
    };
    d3.variance = function (array, f) {
        var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
        if (arguments.length === 1) {
            while (++i < n) {
                if (d3_numeric(a = d3_number(array[i]))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        else {
            while (++i < n) {
                if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
                    d = a - m;
                    m += d / ++j;
                    s += d * (a - m);
                }
            }
        }
        if (j > 1)
            return s / (j - 1);
    };
    d3.deviation = function () {
        var v = d3.variance.apply(this, arguments);
        return v ? Math.sqrt(v) : v;
    };
    function d3_bisector(compare) {
        return {
            left: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) < 0)
                        lo = mid + 1;
                    else
                        hi = mid;
                }
                return lo;
            },
            right: function (a, x, lo, hi) {
                if (arguments.length < 3)
                    lo = 0;
                if (arguments.length < 4)
                    hi = a.length;
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (compare(a[mid], x) > 0)
                        hi = mid;
                    else
                        lo = mid + 1;
                }
                return lo;
            }
        };
    }
    var d3_bisect = d3_bisector(d3_ascending);
    d3.bisectLeft = d3_bisect.left;
    d3.bisect = d3.bisectRight = d3_bisect.right;
    d3.bisector = function (f) {
        return d3_bisector(f.length === 1 ? function (d, x) {
            return d3_ascending(f(d), x);
        } : f);
    };
    d3.shuffle = function (array, i0, i1) {
        if ((m = arguments.length) < 3) {
            i1 = array.length;
            if (m < 2)
                i0 = 0;
        }
        var m = i1 - i0, t, i;
        while (m) {
            i = Math.random() * m-- | 0;
            t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
        }
        return array;
    };
    d3.permute = function (array, indexes) {
        var i = indexes.length, permutes = new Array(i);
        while (i--)
            permutes[i] = array[indexes[i]];
        return permutes;
    };
    d3.pairs = function (array) {
        var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
        while (i < n)
            pairs[i] = [p0 = p1, p1 = array[++i]];
        return pairs;
    };
    d3.transpose = function (matrix) {
        if (!(n = matrix.length))
            return [];
        for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m;) {
            for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
                row[j] = matrix[j][i];
            }
        }
        return transpose;
    };
    function d3_transposeLength(d) {
        return d.length;
    }
    d3.zip = function () {
        return d3.transpose(arguments);
    };
    d3.keys = function (map) {
        var keys = [];
        for (var key in map)
            keys.push(key);
        return keys;
    };
    d3.values = function (map) {
        var values = [];
        for (var key in map)
            values.push(map[key]);
        return values;
    };
    d3.entries = function (map) {
        var entries = [];
        for (var key in map)
            entries.push({
                key: key,
                value: map[key]
            });
        return entries;
    };
    d3.merge = function (arrays) {
        var n = arrays.length, m, i = -1, j = 0, merged, array;
        while (++i < n)
            j += arrays[i].length;
        merged = new Array(j);
        while (--n >= 0) {
            array = arrays[n];
            m = array.length;
            while (--m >= 0) {
                merged[--j] = array[m];
            }
        }
        return merged;
    };
    var abs = Math.abs;
    d3.range = function (start, stop, step) {
        if (arguments.length < 3) {
            step = 1;
            if (arguments.length < 2) {
                stop = start;
                start = 0;
            }
        }
        if ((stop - start) / step === Infinity)
            throw new Error("infinite range");
        var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
        start *= k, stop *= k, step *= k;
        if (step < 0)
            while ((j = start + step * ++i) > stop)
                range.push(j / k);
        else
            while ((j = start + step * ++i) < stop)
                range.push(j / k);
        return range;
    };
    function d3_range_integerScale(x) {
        var k = 1;
        while (x * k % 1)
            k *= 10;
        return k;
    }
    function d3_class(ctor, properties) {
        for (var key in properties) {
            Object.defineProperty(ctor.prototype, key, {
                value: properties[key],
                enumerable: false
            });
        }
    }
    d3.map = function (object, f) {
        var map = new d3_Map();
        if (object instanceof d3_Map) {
            object.forEach(function (key, value) {
                map.set(key, value);
            });
        }
        else if (Array.isArray(object)) {
            var i = -1, n = object.length, o;
            if (arguments.length === 1)
                while (++i < n)
                    map.set(i, object[i]);
            else
                while (++i < n)
                    map.set(f.call(object, o = object[i], i), o);
        }
        else {
            for (var key in object)
                map.set(key, object[key]);
        }
        return map;
    };
    function d3_Map() {
        this._ = Object.create(null);
    }
    var d3_map_proto = "__proto__", d3_map_zero = "\x00";
    d3_class(d3_Map, {
        has: d3_map_has,
        get: function (key) {
            return this._[d3_map_escape(key)];
        },
        set: function (key, value) {
            return this._[d3_map_escape(key)] = value;
        },
        remove: d3_map_remove,
        keys: d3_map_keys,
        values: function () {
            var values = [];
            for (var key in this._)
                values.push(this._[key]);
            return values;
        },
        entries: function () {
            var entries = [];
            for (var key in this._)
                entries.push({
                    key: d3_map_unescape(key),
                    value: this._[key]
                });
            return entries;
        },
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key), this._[key]);
        }
    });
    function d3_map_escape(key) {
        return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
    }
    function d3_map_unescape(key) {
        return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
    }
    function d3_map_has(key) {
        return d3_map_escape(key) in this._;
    }
    function d3_map_remove(key) {
        return (key = d3_map_escape(key)) in this._ && delete this._[key];
    }
    function d3_map_keys() {
        var keys = [];
        for (var key in this._)
            keys.push(d3_map_unescape(key));
        return keys;
    }
    function d3_map_size() {
        var size = 0;
        for (var key in this._)
            ++size;
        return size;
    }
    function d3_map_empty() {
        for (var key in this._)
            return false;
        return true;
    }
    d3.nest = function () {
        var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
        function map(mapType, array, depth) {
            if (depth >= keys.length)
                return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
            var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
            while (++i < n) {
                if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
                    values.push(object);
                }
                else {
                    valuesByKey.set(keyValue, [object]);
                }
            }
            if (mapType) {
                object = mapType();
                setter = function (keyValue, values) {
                    object.set(keyValue, map(mapType, values, depth));
                };
            }
            else {
                object = {};
                setter = function (keyValue, values) {
                    object[keyValue] = map(mapType, values, depth);
                };
            }
            valuesByKey.forEach(setter);
            return object;
        }
        function entries(map, depth) {
            if (depth >= keys.length)
                return map;
            var array = [], sortKey = sortKeys[depth++];
            map.forEach(function (key, keyMap) {
                array.push({
                    key: key,
                    values: entries(keyMap, depth)
                });
            });
            return sortKey ? array.sort(function (a, b) {
                return sortKey(a.key, b.key);
            }) : array;
        }
        nest.map = function (array, mapType) {
            return map(mapType, array, 0);
        };
        nest.entries = function (array) {
            return entries(map(d3.map, array, 0), 0);
        };
        nest.key = function (d) {
            keys.push(d);
            return nest;
        };
        nest.sortKeys = function (order) {
            sortKeys[keys.length - 1] = order;
            return nest;
        };
        nest.sortValues = function (order) {
            sortValues = order;
            return nest;
        };
        nest.rollup = function (f) {
            rollup = f;
            return nest;
        };
        return nest;
    };
    d3.set = function (array) {
        var set = new d3_Set();
        if (array)
            for (var i = 0, n = array.length; i < n; ++i)
                set.add(array[i]);
        return set;
    };
    function d3_Set() {
        this._ = Object.create(null);
    }
    d3_class(d3_Set, {
        has: d3_map_has,
        add: function (key) {
            this._[d3_map_escape(key += "")] = true;
            return key;
        },
        remove: d3_map_remove,
        values: d3_map_keys,
        size: d3_map_size,
        empty: d3_map_empty,
        forEach: function (f) {
            for (var key in this._)
                f.call(this, d3_map_unescape(key));
        }
    });
    d3.behavior = {};
    function d3_identity(d) {
        return d;
    }
    d3.rebind = function (target, source) {
        var i = 1, n = arguments.length, method;
        while (++i < n)
            target[method = arguments[i]] = d3_rebind(target, source, source[method]);
        return target;
    };
    function d3_rebind(target, source, method) {
        return function () {
            var value = method.apply(source, arguments);
            return value === source ? target : value;
        };
    }
    function d3_vendorSymbol(object, name) {
        if (name in object)
            return name;
        name = name.charAt(0).toUpperCase() + name.slice(1);
        for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
            var prefixName = d3_vendorPrefixes[i] + name;
            if (prefixName in object)
                return prefixName;
        }
    }
    var d3_vendorPrefixes = ["webkit", "ms", "moz", "Moz", "o", "O"];
    function d3_noop() { }
    d3.dispatch = function () {
        var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        return dispatch;
    };
    function d3_dispatch() { }
    d3_dispatch.prototype.on = function (type, listener) {
        var i = type.indexOf("."), name = "";
        if (i >= 0) {
            name = type.slice(i + 1);
            type = type.slice(0, i);
        }
        if (type)
            return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
        if (arguments.length === 2) {
            if (listener == null)
                for (type in this) {
                    if (this.hasOwnProperty(type))
                        this[type].on(name, null);
                }
            return this;
        }
    };
    function d3_dispatch_event(dispatch) {
        var listeners = [], listenerByName = new d3_Map();
        function event() {
            var z = listeners, i = -1, n = z.length, l;
            while (++i < n)
                if (l = z[i].on)
                    l.apply(this, arguments);
            return dispatch;
        }
        event.on = function (name, listener) {
            var l = listenerByName.get(name), i;
            if (arguments.length < 2)
                return l && l.on;
            if (l) {
                l.on = null;
                listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
                listenerByName.remove(name);
            }
            if (listener)
                listeners.push(listenerByName.set(name, {
                    on: listener
                }));
            return dispatch;
        };
        return event;
    }
    d3.event = null;
    function d3_eventPreventDefault() {
        d3.event.preventDefault();
    }
    function d3_eventSource() {
        var e = d3.event, s;
        while (s = e.sourceEvent)
            e = s;
        return e;
    }
    function d3_eventDispatch(target) {
        var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
        while (++i < n)
            dispatch[arguments[i]] = d3_dispatch_event(dispatch);
        dispatch.of = function (thiz, argumentz) {
            return function (e1) {
                try {
                    var e0 = e1.sourceEvent = d3.event;
                    e1.target = target;
                    d3.event = e1;
                    dispatch[e1.type].apply(thiz, argumentz);
                }
                finally {
                    d3.event = e0;
                }
            };
        };
        return dispatch;
    }
    d3.requote = function (s) {
        return s.replace(d3_requote_re, "\\$&");
    };
    var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
    var d3_subclass = {}.__proto__ ? function (object, prototype) {
        object.__proto__ = prototype;
    } : function (object, prototype) {
        for (var property in prototype)
            object[property] = prototype[property];
    };
    function d3_selection(groups) {
        d3_subclass(groups, d3_selectionPrototype);
        return groups;
    }
    var d3_select = function (s, n) {
        return n.querySelector(s);
    }, d3_selectAll = function (s, n) {
        return n.querySelectorAll(s);
    }, d3_selectMatches = function (n, s) {
        var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
        d3_selectMatches = function (n, s) {
            return d3_selectMatcher.call(n, s);
        };
        return d3_selectMatches(n, s);
    };
    if (typeof Sizzle === "function") {
        d3_select = function (s, n) {
            return Sizzle(s, n)[0] || null;
        };
        d3_selectAll = Sizzle;
        d3_selectMatches = Sizzle.matchesSelector;
    }
    d3.selection = function () {
        return d3.select(d3_document.documentElement);
    };
    var d3_selectionPrototype = d3.selection.prototype = [];
    d3_selectionPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, group, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(subnode = selector.call(node, node.__data__, i, j));
                    if (subnode && "__data__" in node)
                        subnode.__data__ = node.__data__;
                }
                else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selector(selector) {
        return typeof selector === "function" ? selector : function () {
            return d3_select(selector, this);
        };
    }
    d3_selectionPrototype.selectAll = function (selector) {
        var subgroups = [], subgroup, node;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
                    subgroup.parentNode = node;
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_selectorAll(selector) {
        return typeof selector === "function" ? selector : function () {
            return d3_selectAll(selector, this);
        };
    }
    var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
    var d3_nsPrefix = {
        svg: "http://www.w3.org/2000/svg",
        xhtml: d3_nsXhtml,
        xlink: "http://www.w3.org/1999/xlink",
        xml: "http://www.w3.org/XML/1998/namespace",
        xmlns: "http://www.w3.org/2000/xmlns/"
    };
    d3.ns = {
        prefix: d3_nsPrefix,
        qualify: function (name) {
            var i = name.indexOf(":"), prefix = name;
            if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns")
                name = name.slice(i + 1);
            return d3_nsPrefix.hasOwnProperty(prefix) ? {
                space: d3_nsPrefix[prefix],
                local: name
            } : name;
        }
    };
    d3_selectionPrototype.attr = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node();
                name = d3.ns.qualify(name);
                return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
            }
            for (value in name)
                this.each(d3_selection_attr(value, name[value]));
            return this;
        }
        return this.each(d3_selection_attr(name, value));
    };
    function d3_selection_attr(name, value) {
        name = d3.ns.qualify(name);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrConstant() {
            this.setAttribute(name, value);
        }
        function attrConstantNS() {
            this.setAttributeNS(name.space, name.local, value);
        }
        function attrFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttribute(name);
            else
                this.setAttribute(name, x);
        }
        function attrFunctionNS() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.removeAttributeNS(name.space, name.local);
            else
                this.setAttributeNS(name.space, name.local, x);
        }
        return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
    }
    function d3_collapse(s) {
        return s.trim().replace(/\s+/g, " ");
    }
    d3_selectionPrototype.classed = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string") {
                var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
                if (value = node.classList) {
                    while (++i < n)
                        if (!value.contains(name[i]))
                            return false;
                }
                else {
                    value = node.getAttribute("class");
                    while (++i < n)
                        if (!d3_selection_classedRe(name[i]).test(value))
                            return false;
                }
                return true;
            }
            for (value in name)
                this.each(d3_selection_classed(value, name[value]));
            return this;
        }
        return this.each(d3_selection_classed(name, value));
    };
    function d3_selection_classedRe(name) {
        return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
    }
    function d3_selection_classes(name) {
        return (name + "").trim().split(/^|\s+/);
    }
    function d3_selection_classed(name, value) {
        name = d3_selection_classes(name).map(d3_selection_classedName);
        var n = name.length;
        function classedConstant() {
            var i = -1;
            while (++i < n)
                name[i](this, value);
        }
        function classedFunction() {
            var i = -1, x = value.apply(this, arguments);
            while (++i < n)
                name[i](this, x);
        }
        return typeof value === "function" ? classedFunction : classedConstant;
    }
    function d3_selection_classedName(name) {
        var re = d3_selection_classedRe(name);
        return function (node, value) {
            if (c = node.classList)
                return value ? c.add(name) : c.remove(name);
            var c = node.getAttribute("class") || "";
            if (value) {
                re.lastIndex = 0;
                if (!re.test(c))
                    node.setAttribute("class", d3_collapse(c + " " + name));
            }
            else {
                node.setAttribute("class", d3_collapse(c.replace(re, " ")));
            }
        };
    }
    d3_selectionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2)
                    value = "";
                for (priority in name)
                    this.each(d3_selection_style(priority, name[priority], value));
                return this;
            }
            if (n < 2) {
                var node = this.node();
                return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
            }
            priority = "";
        }
        return this.each(d3_selection_style(name, value, priority));
    };
    function d3_selection_style(name, value, priority) {
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleConstant() {
            this.style.setProperty(name, value, priority);
        }
        function styleFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                this.style.removeProperty(name);
            else
                this.style.setProperty(name, x, priority);
        }
        return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
    }
    d3_selectionPrototype.property = function (name, value) {
        if (arguments.length < 2) {
            if (typeof name === "string")
                return this.node()[name];
            for (value in name)
                this.each(d3_selection_property(value, name[value]));
            return this;
        }
        return this.each(d3_selection_property(name, value));
    };
    function d3_selection_property(name, value) {
        function propertyNull() {
            delete this[name];
        }
        function propertyConstant() {
            this[name] = value;
        }
        function propertyFunction() {
            var x = value.apply(this, arguments);
            if (x == null)
                delete this[name];
            else
                this[name] = x;
        }
        return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
    }
    d3_selectionPrototype.text = function (value) {
        return arguments.length ? this.each(typeof value === "function" ? function () {
            var v = value.apply(this, arguments);
            this.textContent = v == null ? "" : v;
        } : value == null ? function () {
            this.textContent = "";
        } : function () {
            this.textContent = value;
        }) : this.node().textContent;
    };
    d3_selectionPrototype.html = function (value) {
        return arguments.length ? this.each(typeof value === "function" ? function () {
            var v = value.apply(this, arguments);
            this.innerHTML = v == null ? "" : v;
        } : value == null ? function () {
            this.innerHTML = "";
        } : function () {
            this.innerHTML = value;
        }) : this.node().innerHTML;
    };
    d3_selectionPrototype.append = function (name) {
        name = d3_selection_creator(name);
        return this.select(function () {
            return this.appendChild(name.apply(this, arguments));
        });
    };
    function d3_selection_creator(name) {
        function create() {
            var document = this.ownerDocument, namespace = this.namespaceURI;
            return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
        }
        function createNS() {
            return this.ownerDocument.createElementNS(name.space, name.local);
        }
        return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
    }
    d3_selectionPrototype.insert = function (name, before) {
        name = d3_selection_creator(name);
        before = d3_selection_selector(before);
        return this.select(function () {
            return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
        });
    };
    d3_selectionPrototype.remove = function () {
        return this.each(d3_selectionRemove);
    };
    function d3_selectionRemove() {
        var parent = this.parentNode;
        if (parent)
            parent.removeChild(this);
    }
    d3_selectionPrototype.data = function (value, key) {
        var i = -1, n = this.length, group, node;
        if (!arguments.length) {
            value = new Array(n = (group = this[0]).length);
            while (++i < n) {
                if (node = group[i]) {
                    value[i] = node.__data__;
                }
            }
            return value;
        }
        function bind(group, groupData) {
            var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
            if (key) {
                var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
                for (i = -1; ++i < n;) {
                    if (node = group[i]) {
                        if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
                            exitNodes[i] = node;
                        }
                        else {
                            nodeByKeyValue.set(keyValue, node);
                        }
                        keyValues[i] = keyValue;
                    }
                }
                for (i = -1; ++i < m;) {
                    if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                    else if (node !== true) {
                        updateNodes[i] = node;
                        node.__data__ = nodeData;
                    }
                    nodeByKeyValue.set(keyValue, true);
                }
                for (i = -1; ++i < n;) {
                    if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
                        exitNodes[i] = group[i];
                    }
                }
            }
            else {
                for (i = -1; ++i < n0;) {
                    node = group[i];
                    nodeData = groupData[i];
                    if (node) {
                        node.__data__ = nodeData;
                        updateNodes[i] = node;
                    }
                    else {
                        enterNodes[i] = d3_selection_dataNode(nodeData);
                    }
                }
                for (; i < m; ++i) {
                    enterNodes[i] = d3_selection_dataNode(groupData[i]);
                }
                for (; i < n; ++i) {
                    exitNodes[i] = group[i];
                }
            }
            enterNodes.update = updateNodes;
            enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
            enter.push(enterNodes);
            update.push(updateNodes);
            exit.push(exitNodes);
        }
        var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
        if (typeof value === "function") {
            while (++i < n) {
                bind(group = this[i], value.call(group, group.parentNode.__data__, i));
            }
        }
        else {
            while (++i < n) {
                bind(group = this[i], value);
            }
        }
        update.enter = function () {
            return enter;
        };
        update.exit = function () {
            return exit;
        };
        return update;
    };
    function d3_selection_dataNode(data) {
        return {
            __data__: data
        };
    }
    d3_selectionPrototype.datum = function (value) {
        return arguments.length ? this.property("__data__", value) : this.property("__data__");
    };
    d3_selectionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function")
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            subgroup.parentNode = (group = this[j]).parentNode;
            for (var i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_selection(subgroups);
    };
    function d3_selection_filter(selector) {
        return function () {
            return d3_selectMatches(this, selector);
        };
    }
    d3_selectionPrototype.order = function () {
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
                if (node = group[i]) {
                    if (next && next !== node.nextSibling)
                        next.parentNode.insertBefore(node, next);
                    next = node;
                }
            }
        }
        return this;
    };
    d3_selectionPrototype.sort = function (comparator) {
        comparator = d3_selection_sortComparator.apply(this, arguments);
        for (var j = -1, m = this.length; ++j < m;)
            this[j].sort(comparator);
        return this.order();
    };
    function d3_selection_sortComparator(comparator) {
        if (!arguments.length)
            comparator = d3_ascending;
        return function (a, b) {
            return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
        };
    }
    d3_selectionPrototype.each = function (callback) {
        return d3_selection_each(this, function (node, i, j) {
            callback.call(node, node.__data__, i, j);
        });
    };
    function d3_selection_each(groups, callback) {
        for (var j = 0, m = groups.length; j < m; j++) {
            for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
                if (node = group[i])
                    callback(node, i, j);
            }
        }
        return groups;
    }
    d3_selectionPrototype.call = function (callback) {
        var args = d3_array(arguments);
        callback.apply(args[0] = this, args);
        return this;
    };
    d3_selectionPrototype.empty = function () {
        return !this.node();
    };
    d3_selectionPrototype.node = function () {
        for (var j = 0, m = this.length; j < m; j++) {
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                var node = group[i];
                if (node)
                    return node;
            }
        }
        return null;
    };
    d3_selectionPrototype.size = function () {
        var n = 0;
        d3_selection_each(this, function () {
            ++n;
        });
        return n;
    };
    function d3_selection_enter(selection) {
        d3_subclass(selection, d3_selection_enterPrototype);
        return selection;
    }
    var d3_selection_enterPrototype = [];
    d3.selection.enter = d3_selection_enter;
    d3.selection.enter.prototype = d3_selection_enterPrototype;
    d3_selection_enterPrototype.append = d3_selectionPrototype.append;
    d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
    d3_selection_enterPrototype.node = d3_selectionPrototype.node;
    d3_selection_enterPrototype.call = d3_selectionPrototype.call;
    d3_selection_enterPrototype.size = d3_selectionPrototype.size;
    d3_selection_enterPrototype.select = function (selector) {
        var subgroups = [], subgroup, subnode, upgroup, group, node;
        for (var j = -1, m = this.length; ++j < m;) {
            upgroup = (group = this[j]).update;
            subgroups.push(subgroup = []);
            subgroup.parentNode = group.parentNode;
            for (var i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
                    subnode.__data__ = node.__data__;
                }
                else {
                    subgroup.push(null);
                }
            }
        }
        return d3_selection(subgroups);
    };
    d3_selection_enterPrototype.insert = function (name, before) {
        if (arguments.length < 2)
            before = d3_selection_enterInsertBefore(this);
        return d3_selectionPrototype.insert.call(this, name, before);
    };
    function d3_selection_enterInsertBefore(enter) {
        var i0, j0;
        return function (d, i, j) {
            var group = enter[j].update, n = group.length, node;
            if (j != j0)
                j0 = j, i0 = 0;
            if (i >= i0)
                i0 = i + 1;
            while (!(node = group[i0]) && ++i0 < n)
                ;
            return node;
        };
    }
    d3.select = function (node) {
        var group;
        if (typeof node === "string") {
            group = [d3_select(node, d3_document)];
            group.parentNode = d3_document.documentElement;
        }
        else {
            group = [node];
            group.parentNode = d3_documentElement(node);
        }
        return d3_selection([group]);
    };
    d3.selectAll = function (nodes) {
        var group;
        if (typeof nodes === "string") {
            group = d3_array(d3_selectAll(nodes, d3_document));
            group.parentNode = d3_document.documentElement;
        }
        else {
            group = d3_array(nodes);
            group.parentNode = null;
        }
        return d3_selection([group]);
    };
    d3_selectionPrototype.on = function (type, listener, capture) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof type !== "string") {
                if (n < 2)
                    listener = false;
                for (capture in type)
                    this.each(d3_selection_on(capture, type[capture], listener));
                return this;
            }
            if (n < 2)
                return (n = this.node()["__on" + type]) && n._;
            capture = false;
        }
        return this.each(d3_selection_on(type, listener, capture));
    };
    function d3_selection_on(type, listener, capture) {
        var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
        if (i > 0)
            type = type.slice(0, i);
        var filter = d3_selection_onFilters.get(type);
        if (filter)
            type = filter, wrap = d3_selection_onFilter;
        function onRemove() {
            var l = this[name];
            if (l) {
                this.removeEventListener(type, l, l.$);
                delete this[name];
            }
        }
        function onAdd() {
            var l = wrap(listener, d3_array(arguments));
            onRemove.call(this);
            this.addEventListener(type, this[name] = l, l.$ = capture);
            l._ = listener;
        }
        function removeAll() {
            var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
            for (var name in this) {
                if (match = name.match(re)) {
                    var l = this[name];
                    this.removeEventListener(match[1], l, l.$);
                    delete this[name];
                }
            }
        }
        return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
    }
    var d3_selection_onFilters = d3.map({
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    });
    if (d3_document) {
        d3_selection_onFilters.forEach(function (k) {
            if ("on" + k in d3_document)
                d3_selection_onFilters.remove(k);
        });
    }
    function d3_selection_onListener(listener, argumentz) {
        return function (e) {
            var o = d3.event;
            d3.event = e;
            argumentz[0] = this.__data__;
            try {
                listener.apply(this, argumentz);
            }
            finally {
                d3.event = o;
            }
        };
    }
    function d3_selection_onFilter(listener, argumentz) {
        var l = d3_selection_onListener(listener, argumentz);
        return function (e) {
            var target = this, related = e.relatedTarget;
            if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
                l.call(target, e);
            }
        };
    }
    var d3_event_dragSelect, d3_event_dragId = 0;
    function d3_event_dragSuppress(node) {
        var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
        if (d3_event_dragSelect == null) {
            d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
        }
        if (d3_event_dragSelect) {
            var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
            style[d3_event_dragSelect] = "none";
        }
        return function (suppressClick) {
            w.on(name, null);
            if (d3_event_dragSelect)
                style[d3_event_dragSelect] = select;
            if (suppressClick) {
                var off = function () {
                    w.on(click, null);
                };
                w.on(click, function () {
                    d3_eventPreventDefault();
                    off();
                }, true);
                setTimeout(off, 0);
            }
        };
    }
    d3.mouse = function (container) {
        return d3_mousePoint(container, d3_eventSource());
    };
    var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
    function d3_mousePoint(container, e) {
        if (e.changedTouches)
            e = e.changedTouches[0];
        var svg = container.ownerSVGElement || container;
        if (svg.createSVGPoint) {
            var point = svg.createSVGPoint();
            if (d3_mouse_bug44083 < 0) {
                var window = d3_window(container);
                if (window.scrollX || window.scrollY) {
                    svg = d3.select("body").append("svg").style({
                        position: "absolute",
                        top: 0,
                        left: 0,
                        margin: 0,
                        padding: 0,
                        border: "none"
                    }, "important");
                    var ctm = svg[0][0].getScreenCTM();
                    d3_mouse_bug44083 = !(ctm.f || ctm.e);
                    svg.remove();
                }
            }
            if (d3_mouse_bug44083)
                point.x = e.pageX, point.y = e.pageY;
            else
                point.x = e.clientX,
                    point.y = e.clientY;
            point = point.matrixTransform(container.getScreenCTM().inverse());
            return [point.x, point.y];
        }
        var rect = container.getBoundingClientRect();
        return [e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop];
    }
    d3.touch = function (container, touches, identifier) {
        if (arguments.length < 3)
            identifier = touches, touches = d3_eventSource().changedTouches;
        if (touches)
            for (var i = 0, n = touches.length, touch; i < n; ++i) {
                if ((touch = touches[i]).identifier === identifier) {
                    return d3_mousePoint(container, touch);
                }
            }
    };
    d3.behavior.drag = function () {
        var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
        function drag() {
            this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
        }
        function dragstart(id, position, subject, move, end) {
            return function () {
                var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
                if (origin) {
                    dragOffset = origin.apply(that, arguments);
                    dragOffset = [dragOffset.x - position0[0], dragOffset.y - position0[1]];
                }
                else {
                    dragOffset = [0, 0];
                }
                dispatch({
                    type: "dragstart"
                });
                function moved() {
                    var position1 = position(parent, dragId), dx, dy;
                    if (!position1)
                        return;
                    dx = position1[0] - position0[0];
                    dy = position1[1] - position0[1];
                    dragged |= dx | dy;
                    position0 = position1;
                    dispatch({
                        type: "drag",
                        x: position1[0] + dragOffset[0],
                        y: position1[1] + dragOffset[1],
                        dx: dx,
                        dy: dy
                    });
                }
                function ended() {
                    if (!position(parent, dragId))
                        return;
                    dragSubject.on(move + dragName, null).on(end + dragName, null);
                    dragRestore(dragged);
                    dispatch({
                        type: "dragend"
                    });
                }
            };
        }
        drag.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return drag;
        };
        return d3.rebind(drag, event, "on");
    };
    function d3_behavior_dragTouchId() {
        return d3.event.changedTouches[0].identifier;
    }
    d3.touches = function (container, touches) {
        if (arguments.length < 2)
            touches = d3_eventSource().touches;
        return touches ? d3_array(touches).map(function (touch) {
            var point = d3_mousePoint(container, touch);
            point.identifier = touch.identifier;
            return point;
        }) : [];
    };
    var epsilon = 1e-6, epsilon2 = epsilon * epsilon, pipipi = Math.PI, tau = 2 * pipipi, tauepsilon = tau - epsilon, halfpipipi = pipipi / 2, d3_radians = pipipi / 180, d3_degrees = 180 / pipipi;
    function d3_sgn(x) {
        return x > 0 ? 1 : x < 0 ? -1 : 0;
    }
    function d3_cross2d(a, b, c) {
        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }
    function d3_acos(x) {
        return x > 1 ? 0 : x < -1 ? pipipi : Math.acos(x);
    }
    function d3_asin(x) {
        return x > 1 ? halfpipipi : x < -1 ? -halfpipipi : Math.asin(x);
    }
    function d3_sinh(x) {
        return ((x = Math.exp(x)) - 1 / x) / 2;
    }
    function d3_cosh(x) {
        return ((x = Math.exp(x)) + 1 / x) / 2;
    }
    function d3_tanh(x) {
        return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }
    function d3_haversin(x) {
        return (x = Math.sin(x / 2)) * x;
    }
    var rho = Math.SQRT2, rho2 = 2, rho4 = 4;
    d3.interpolateZoom = function (p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
        if (d2 < epsilon2) {
            S = Math.log(w1 / w0) / rho;
            i = function (t) {
                return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
            };
        }
        else {
            var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
            S = (r1 - r0) / rho;
            i = function (t) {
                var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * d3_tanh(rho * s + r0) - d3_sinh(r0));
                return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(rho * s + r0)];
            };
        }
        i.duration = S * 1e3;
        return i;
    };
    d3.behavior.zoom = function () {
        var view = {
            x: 0,
            y: 0,
            k: 1
        }, translate0, center0, center, size = [960, 500], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
        if (!d3_behavior_zoomWheel) {
            d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function () {
                return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
            }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function () {
                return d3.event.wheelDelta;
            }, "mousewheel") : (d3_behavior_zoomDelta = function () {
                return -d3.event.detail;
            }, "MozMousePixelScroll");
        }
        function zoom(g) {
            g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
        }
        zoom.event = function (g) {
            g.each(function () {
                var dispatch = event.of(this, arguments), view1 = view;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.zoom", function () {
                        view = this.__chart__ || {
                            x: 0,
                            y: 0,
                            k: 1
                        };
                        zoomstarted(dispatch);
                    }).tween("zoom:zoom", function () {
                        var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([(cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k], [(cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k]);
                        return function (t) {
                            var l = i(t), k = dx / l[2];
                            this.__chart__ = view = {
                                x: cx - l[0] * k,
                                y: cy - l[1] * k,
                                k: k
                            };
                            zoomed(dispatch);
                        };
                    }).each("interrupt.zoom", function () {
                        zoomended(dispatch);
                    }).each("end.zoom", function () {
                        zoomended(dispatch);
                    });
                }
                else {
                    this.__chart__ = view;
                    zoomstarted(dispatch);
                    zoomed(dispatch);
                    zoomended(dispatch);
                }
            });
        };
        zoom.translate = function (_) {
            if (!arguments.length)
                return [view.x, view.y];
            view = {
                x: +_[0],
                y: +_[1],
                k: view.k
            };
            rescale();
            return zoom;
        };
        zoom.scale = function (_) {
            if (!arguments.length)
                return view.k;
            view = {
                x: view.x,
                y: view.y,
                k: null
            };
            scaleTo(+_);
            rescale();
            return zoom;
        };
        zoom.scaleExtent = function (_) {
            if (!arguments.length)
                return scaleExtent;
            scaleExtent = _ == null ? d3_behavior_zoomInfinity : [+_[0], +_[1]];
            return zoom;
        };
        zoom.center = function (_) {
            if (!arguments.length)
                return center;
            center = _ && [+_[0], +_[1]];
            return zoom;
        };
        zoom.size = function (_) {
            if (!arguments.length)
                return size;
            size = _ && [+_[0], +_[1]];
            return zoom;
        };
        zoom.duration = function (_) {
            if (!arguments.length)
                return duration;
            duration = +_;
            return zoom;
        };
        zoom.x = function (z) {
            if (!arguments.length)
                return x1;
            x1 = z;
            x0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        zoom.y = function (z) {
            if (!arguments.length)
                return y1;
            y1 = z;
            y0 = z.copy();
            view = {
                x: 0,
                y: 0,
                k: 1
            };
            return zoom;
        };
        function location(p) {
            return [(p[0] - view.x) / view.k, (p[1] - view.y) / view.k];
        }
        function point(l) {
            return [l[0] * view.k + view.x, l[1] * view.k + view.y];
        }
        function scaleTo(s) {
            view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
        }
        function translateTo(p, l) {
            l = point(l);
            view.x += p[0] - l[0];
            view.y += p[1] - l[1];
        }
        function zoomTo(that, p, l, k) {
            that.__chart__ = {
                x: view.x,
                y: view.y,
                k: view.k
            };
            scaleTo(Math.pow(2, k));
            translateTo(center0 = p, l);
            that = d3.select(that);
            if (duration > 0)
                that = that.transition().duration(duration);
            that.call(zoom.event);
        }
        function rescale() {
            if (x1)
                x1.domain(x0.range().map(function (x) {
                    return (x - view.x) / view.k;
                }).map(x0.invert));
            if (y1)
                y1.domain(y0.range().map(function (y) {
                    return (y - view.y) / view.k;
                }).map(y0.invert));
        }
        function zoomstarted(dispatch) {
            if (!zooming++)
                dispatch({
                    type: "zoomstart"
                });
        }
        function zoomed(dispatch) {
            rescale();
            dispatch({
                type: "zoom",
                scale: view.k,
                translate: [view.x, view.y]
            });
        }
        function zoomended(dispatch) {
            if (!--zooming)
                dispatch({
                    type: "zoomend"
                }), center0 = null;
        }
        function mousedowned() {
            var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
            d3_selection_interrupt.call(that);
            zoomstarted(dispatch);
            function moved() {
                dragged = 1;
                translateTo(d3.mouse(that), location0);
                zoomed(dispatch);
            }
            function ended() {
                subject.on(mousemove, null).on(mouseup, null);
                dragRestore(dragged);
                zoomended(dispatch);
            }
        }
        function touchstarted() {
            var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
            started();
            zoomstarted(dispatch);
            subject.on(mousedown, null).on(touchstart, started);
            function relocate() {
                var touches = d3.touches(that);
                scale0 = view.k;
                touches.forEach(function (t) {
                    if (t.identifier in locations0)
                        locations0[t.identifier] = location(t);
                });
                return touches;
            }
            function started() {
                var target = d3.event.target;
                d3.select(target).on(touchmove, moved).on(touchend, ended);
                targets.push(target);
                var changed = d3.event.changedTouches;
                for (var i = 0, n = changed.length; i < n; ++i) {
                    locations0[changed[i].identifier] = null;
                }
                var touches = relocate(), now = Date.now();
                if (touches.length === 1) {
                    if (now - touchtime < 500) {
                        var p = touches[0];
                        zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
                        d3_eventPreventDefault();
                    }
                    touchtime = now;
                }
                else if (touches.length > 1) {
                    var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
                    distance0 = dx * dx + dy * dy;
                }
            }
            function moved() {
                var touches = d3.touches(that), p0, l0, p1, l1;
                d3_selection_interrupt.call(that);
                for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
                    p1 = touches[i];
                    if (l1 = locations0[p1.identifier]) {
                        if (l0)
                            break;
                        p0 = p1, l0 = l1;
                    }
                }
                if (l1) {
                    var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
                    p0 = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
                    l0 = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
                    scaleTo(scale1 * scale0);
                }
                touchtime = null;
                translateTo(p0, l0);
                zoomed(dispatch);
            }
            function ended() {
                if (d3.event.touches.length) {
                    var changed = d3.event.changedTouches;
                    for (var i = 0, n = changed.length; i < n; ++i) {
                        delete locations0[changed[i].identifier];
                    }
                    for (var identifier in locations0) {
                        return void relocate();
                    }
                }
                d3.selectAll(targets).on(zoomName, null);
                subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
                dragRestore();
                zoomended(dispatch);
            }
        }
        function mousewheeled() {
            var dispatch = event.of(this, arguments);
            if (mousewheelTimer)
                clearTimeout(mousewheelTimer);
            else
                d3_selection_interrupt.call(this),
                    translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
            mousewheelTimer = setTimeout(function () {
                mousewheelTimer = null;
                zoomended(dispatch);
            }, 50);
            d3_eventPreventDefault();
            scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
            translateTo(center0, translate0);
            zoomed(dispatch);
        }
        function dblclicked() {
            var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
            zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
        }
        return d3.rebind(zoom, event, "on");
    };
    var d3_behavior_zoomInfinity = [0, Infinity], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
    d3.color = d3_color;
    function d3_color() { }
    d3_color.prototype.toString = function () {
        return this.rgb() + "";
    };
    d3.hsl = d3_hsl;
    function d3_hsl(h, s, l) {
        return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
    }
    var d3_hslPrototype = d3_hsl.prototype = new d3_color();
    d3_hslPrototype.brighter = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, this.l / k);
    };
    d3_hslPrototype.darker = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_hsl(this.h, this.s, k * this.l);
    };
    d3_hslPrototype.rgb = function () {
        return d3_hsl_rgb(this.h, this.s, this.l);
    };
    function d3_hsl_rgb(h, s, l) {
        var m1, m2;
        h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
        s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
        l = l < 0 ? 0 : l > 1 ? 1 : l;
        m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
        m1 = 2 * l - m2;
        function v(h) {
            if (h > 360)
                h -= 360;
            else if (h < 0)
                h += 360;
            if (h < 60)
                return m1 + (m2 - m1) * h / 60;
            if (h < 180)
                return m2;
            if (h < 240)
                return m1 + (m2 - m1) * (240 - h) / 60;
            return m1;
        }
        function vv(h) {
            return Math.round(v(h) * 255);
        }
        return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
    }
    d3.hcl = d3_hcl;
    function d3_hcl(h, c, l) {
        return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
    }
    var d3_hclPrototype = d3_hcl.prototype = new d3_color();
    d3_hclPrototype.brighter = function (k) {
        return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.darker = function (k) {
        return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
    };
    d3_hclPrototype.rgb = function () {
        return d3_hcl_lab(this.h, this.c, this.l).rgb();
    };
    function d3_hcl_lab(h, c, l) {
        if (isNaN(h))
            h = 0;
        if (isNaN(c))
            c = 0;
        return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
    }
    d3.lab = d3_lab;
    function d3_lab(l, a, b) {
        return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
    }
    var d3_lab_K = 18;
    var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
    var d3_labPrototype = d3_lab.prototype = new d3_color();
    d3_labPrototype.brighter = function (k) {
        return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.darker = function (k) {
        return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
    };
    d3_labPrototype.rgb = function () {
        return d3_lab_rgb(this.l, this.a, this.b);
    };
    function d3_lab_rgb(l, a, b) {
        var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
        x = d3_lab_xyz(x) * d3_lab_X;
        y = d3_lab_xyz(y) * d3_lab_Y;
        z = d3_lab_xyz(z) * d3_lab_Z;
        return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
    }
    function d3_lab_hcl(l, a, b) {
        return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
    }
    function d3_lab_xyz(x) {
        return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
    }
    function d3_xyz_lab(x) {
        return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
    }
    function d3_xyz_rgb(r) {
        return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
    }
    d3.rgb = d3_rgb;
    function d3_rgb(r, g, b) {
        return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
    }
    function d3_rgbNumber(value) {
        return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
    }
    function d3_rgbString(value) {
        return d3_rgbNumber(value) + "";
    }
    var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
    d3_rgbPrototype.brighter = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        var r = this.r, g = this.g, b = this.b, i = 30;
        if (!r && !g && !b)
            return new d3_rgb(i, i, i);
        if (r && r < i)
            r = i;
        if (g && g < i)
            g = i;
        if (b && b < i)
            b = i;
        return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
    };
    d3_rgbPrototype.darker = function (k) {
        k = Math.pow(.7, arguments.length ? k : 1);
        return new d3_rgb(k * this.r, k * this.g, k * this.b);
    };
    d3_rgbPrototype.hsl = function () {
        return d3_rgb_hsl(this.r, this.g, this.b);
    };
    d3_rgbPrototype.toString = function () {
        return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
    };
    function d3_rgb_hex(v) {
        return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
    }
    function d3_rgb_parse(format, rgb, hsl) {
        var r = 0, g = 0, b = 0, m1, m2, color;
        m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
        if (m1) {
            m2 = m1[2].split(",");
            switch (m1[1]) {
                case "hsl":
                    {
                        return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
                    }
                case "rgb":
                    {
                        return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
                    }
            }
        }
        if (color = d3_rgb_names.get(format)) {
            return rgb(color.r, color.g, color.b);
        }
        if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
            if (format.length === 4) {
                r = (color & 3840) >> 4;
                r = r >> 4 | r;
                g = color & 240;
                g = g >> 4 | g;
                b = color & 15;
                b = b << 4 | b;
            }
            else if (format.length === 7) {
                r = (color & 16711680) >> 16;
                g = (color & 65280) >> 8;
                b = color & 255;
            }
        }
        return rgb(r, g, b);
    }
    function d3_rgb_hsl(r, g, b) {
        var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
        if (d) {
            s = l < .5 ? d / (max + min) : d / (2 - max - min);
            if (r == max)
                h = (g - b) / d + (g < b ? 6 : 0);
            else if (g == max)
                h = (b - r) / d + 2;
            else
                h = (r - g) / d + 4;
            h *= 60;
        }
        else {
            h = NaN;
            s = l > 0 && l < 1 ? 0 : h;
        }
        return new d3_hsl(h, s, l);
    }
    function d3_rgb_lab(r, g, b) {
        r = d3_rgb_xyz(r);
        g = d3_rgb_xyz(g);
        b = d3_rgb_xyz(b);
        var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
        return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
    }
    function d3_rgb_xyz(r) {
        return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
    }
    function d3_rgb_parseNumber(c) {
        var f = parseFloat(c);
        return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
    }
    var d3_rgb_names = d3.map({
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    });
    d3_rgb_names.forEach(function (key, value) {
        d3_rgb_names.set(key, d3_rgbNumber(value));
    });
    function d3_functor(v) {
        return typeof v === "function" ? v : function () {
            return v;
        };
    }
    d3.functor = d3_functor;
    d3.xhr = d3_xhrType(d3_identity);
    function d3_xhrType(response) {
        return function (url, mimeType, callback) {
            if (arguments.length === 2 && typeof mimeType === "function")
                callback = mimeType,
                    mimeType = null;
            return d3_xhr(url, mimeType, response, callback);
        };
    }
    function d3_xhr(url, mimeType, response, callback) {
        var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
        if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url))
            request = new XDomainRequest();
        "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function () {
            request.readyState > 3 && respond();
        };
        function respond() {
            var status = request.status, result;
            if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
                try {
                    result = response.call(xhr, request);
                }
                catch (e) {
                    dispatch.error.call(xhr, e);
                    return;
                }
                dispatch.load.call(xhr, result);
            }
            else {
                dispatch.error.call(xhr, request);
            }
        }
        request.onprogress = function (event) {
            var o = d3.event;
            d3.event = event;
            try {
                dispatch.progress.call(xhr, request);
            }
            finally {
                d3.event = o;
            }
        };
        xhr.header = function (name, value) {
            name = (name + "").toLowerCase();
            if (arguments.length < 2)
                return headers[name];
            if (value == null)
                delete headers[name];
            else
                headers[name] = value + "";
            return xhr;
        };
        xhr.mimeType = function (value) {
            if (!arguments.length)
                return mimeType;
            mimeType = value == null ? null : value + "";
            return xhr;
        };
        xhr.responseType = function (value) {
            if (!arguments.length)
                return responseType;
            responseType = value;
            return xhr;
        };
        xhr.response = function (value) {
            response = value;
            return xhr;
        };
        ["get", "post"].forEach(function (method) {
            xhr[method] = function () {
                return xhr.send.apply(xhr, [method].concat(d3_array(arguments)));
            };
        });
        xhr.send = function (method, data, callback) {
            if (arguments.length === 2 && typeof data === "function")
                callback = data, data = null;
            request.open(method, url, true);
            if (mimeType != null && !("accept" in headers))
                headers["accept"] = mimeType + ",*/*";
            if (request.setRequestHeader)
                for (var name in headers)
                    request.setRequestHeader(name, headers[name]);
            if (mimeType != null && request.overrideMimeType)
                request.overrideMimeType(mimeType);
            if (responseType != null)
                request.responseType = responseType;
            if (callback != null)
                xhr.on("error", callback).on("load", function (request) {
                    callback(null, request);
                });
            dispatch.beforesend.call(xhr, request);
            request.send(data == null ? null : data);
            return xhr;
        };
        xhr.abort = function () {
            request.abort();
            return xhr;
        };
        d3.rebind(xhr, dispatch, "on");
        return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
    }
    function d3_xhr_fixCallback(callback) {
        return callback.length === 1 ? function (error, request) {
            callback(error == null ? request : null);
        } : callback;
    }
    function d3_xhrHasResponse(request) {
        var type = request.responseType;
        return type && type !== "text" ? request.response : request.responseText;
    }
    d3.dsv = function (delimiter, mimeType) {
        var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
        function dsv(url, row, callback) {
            if (arguments.length < 3)
                callback = row, row = null;
            var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
            xhr.row = function (_) {
                return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
            };
            return xhr;
        }
        function response(request) {
            return dsv.parse(request.responseText);
        }
        function typedResponse(f) {
            return function (request) {
                return dsv.parse(request.responseText, f);
            };
        }
        dsv.parse = function (text, f) {
            var o;
            return dsv.parseRows(text, function (row, i) {
                if (o)
                    return o(row, i - 1);
                var a = new Function("d", "return {" + row.map(function (name, i) {
                    return JSON.stringify(name) + ": d[" + i + "]";
                }).join(",") + "}");
                o = f ? function (row, i) {
                    return f(a(row), i);
                } : a;
            });
        };
        dsv.parseRows = function (text, f) {
            var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
            function token() {
                if (I >= N)
                    return EOF;
                if (eol)
                    return eol = false, EOL;
                var j = I;
                if (text.charCodeAt(j) === 34) {
                    var i = j;
                    while (i++ < N) {
                        if (text.charCodeAt(i) === 34) {
                            if (text.charCodeAt(i + 1) !== 34)
                                break;
                            ++i;
                        }
                    }
                    I = i + 2;
                    var c = text.charCodeAt(i + 1);
                    if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(i + 2) === 10)
                            ++I;
                    }
                    else if (c === 10) {
                        eol = true;
                    }
                    return text.slice(j + 1, i).replace(/""/g, '"');
                }
                while (I < N) {
                    var c = text.charCodeAt(I++), k = 1;
                    if (c === 10)
                        eol = true;
                    else if (c === 13) {
                        eol = true;
                        if (text.charCodeAt(I) === 10)
                            ++I, ++k;
                    }
                    else if (c !== delimiterCode)
                        continue;
                    return text.slice(j, I - k);
                }
                return text.slice(j);
            }
            while ((t = token()) !== EOF) {
                var a = [];
                while (t !== EOL && t !== EOF) {
                    a.push(t);
                    t = token();
                }
                if (f && (a = f(a, n++)) == null)
                    continue;
                rows.push(a);
            }
            return rows;
        };
        dsv.format = function (rows) {
            if (Array.isArray(rows[0]))
                return dsv.formatRows(rows);
            var fieldSet = new d3_Set(), fields = [];
            rows.forEach(function (row) {
                for (var field in row) {
                    if (!fieldSet.has(field)) {
                        fields.push(fieldSet.add(field));
                    }
                }
            });
            return [fields.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
                return fields.map(function (field) {
                    return formatValue(row[field]);
                }).join(delimiter);
            })).join("\n");
        };
        dsv.formatRows = function (rows) {
            return rows.map(formatRow).join("\n");
        };
        function formatRow(row) {
            return row.map(formatValue).join(delimiter);
        }
        function formatValue(text) {
            return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
        }
        return dsv;
    };
    d3.csv = d3.dsv(",", "text/csv");
    d3.tsv = d3.dsv("	", "text/tab-separated-values");
    var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function (callback) {
        setTimeout(callback, 17);
    };
    d3.timer = function () {
        d3_timer.apply(this, arguments);
    };
    function d3_timer(callback, delay, then) {
        var n = arguments.length;
        if (n < 2)
            delay = 0;
        if (n < 3)
            then = Date.now();
        var time = then + delay, timer = {
            c: callback,
            t: time,
            n: null
        };
        if (d3_timer_queueTail)
            d3_timer_queueTail.n = timer;
        else
            d3_timer_queueHead = timer;
        d3_timer_queueTail = timer;
        if (!d3_timer_interval) {
            d3_timer_timeout = clearTimeout(d3_timer_timeout);
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
        return timer;
    }
    function d3_timer_step() {
        var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
        if (delay > 24) {
            if (isFinite(delay)) {
                clearTimeout(d3_timer_timeout);
                d3_timer_timeout = setTimeout(d3_timer_step, delay);
            }
            d3_timer_interval = 0;
        }
        else {
            d3_timer_interval = 1;
            d3_timer_frame(d3_timer_step);
        }
    }
    d3.timer.flush = function () {
        d3_timer_mark();
        d3_timer_sweep();
    };
    function d3_timer_mark() {
        var now = Date.now(), timer = d3_timer_queueHead;
        while (timer) {
            if (now >= timer.t && timer.c(now - timer.t))
                timer.c = null;
            timer = timer.n;
        }
        return now;
    }
    function d3_timer_sweep() {
        var t0, t1 = d3_timer_queueHead, time = Infinity;
        while (t1) {
            if (t1.c) {
                if (t1.t < time)
                    time = t1.t;
                t1 = (t0 = t1).n;
            }
            else {
                t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
            }
        }
        d3_timer_queueTail = t0;
        return time;
    }
    function d3_format_precision(x, p) {
        return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
    }
    d3.round = function (x, n) {
        return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
    };
    var d3_formatPrefixes = ["y", "z", "a", "f", "p", "n", "my", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"].map(d3_formatPrefix);
    d3.formatPrefix = function (value, precision) {
        var i = 0;
        if (value = +value) {
            if (value < 0)
                value *= -1;
            if (precision)
                value = d3.round(value, d3_format_precision(value, precision));
            i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
            i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
        }
        return d3_formatPrefixes[8 + i / 3];
    };
    function d3_formatPrefix(d, i) {
        var k = Math.pow(10, abs(8 - i) * 3);
        return {
            scale: i > 8 ? function (d) {
                return d / k;
            } : function (d) {
                return d * k;
            },
            symbol: d
        };
    }
    function d3_locale_numberFormat(locale) {
        var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function (value, width) {
            var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
            while (i > 0 && g > 0) {
                if (length + g + 1 > width)
                    g = Math.max(1, width - length);
                t.push(value.substring(i -= g, i + g));
                if ((length += g + 1) > width)
                    break;
                g = locale_grouping[j = (j + 1) % locale_grouping.length];
            }
            return t.reverse().join(locale_thousands);
        } : d3_identity;
        return function (specifier) {
            var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
            if (precision)
                precision = +precision.substring(1);
            if (zfill || fill === "0" && align === "=") {
                zfill = fill = "0";
                align = "=";
            }
            switch (type) {
                case "n":
                    comma = true;
                    type = "g";
                    break;
                case "%":
                    scale = 100;
                    suffix = "%";
                    type = "f";
                    break;
                case "p":
                    scale = 100;
                    suffix = "%";
                    type = "r";
                    break;
                case "b":
                case "o":
                case "x":
                case "X":
                    if (symbol === "#")
                        prefix = "0" + type.toLowerCase();
                case "c":
                    exponent = false;
                case "d":
                    integer = true;
                    precision = 0;
                    break;
                case "s":
                    scale = -1;
                    type = "r";
                    break;
            }
            if (symbol === "$")
                prefix = locale_currency[0], suffix = locale_currency[1];
            if (type == "r" && !precision)
                type = "g";
            if (precision != null) {
                if (type == "g")
                    precision = Math.max(1, Math.min(21, precision));
                else if (type == "e" || type == "f")
                    precision = Math.max(0, Math.min(20, precision));
            }
            type = d3_format_types.get(type) || d3_format_typeDefault;
            var zcomma = zfill && comma;
            return function (value) {
                var fullSuffix = suffix;
                if (integer && value % 1)
                    return "";
                var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
                if (scale < 0) {
                    var unit = d3.formatPrefix(value, precision);
                    value = unit.scale(value);
                    fullSuffix = unit.symbol + suffix;
                }
                else {
                    value *= scale;
                }
                value = type(value, precision);
                var i = value.lastIndexOf("."), before, after;
                if (i < 0) {
                    var j = exponent ? value.lastIndexOf("e") : -1;
                    if (j < 0)
                        before = value, after = "";
                    else
                        before = value.substring(0, j), after = value.substring(j);
                }
                else {
                    before = value.substring(0, i);
                    after = locale_decimal + value.substring(i + 1);
                }
                if (!zfill && comma)
                    before = formatGroup(before, Infinity);
                var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
                if (zcomma)
                    before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
                negative += prefix;
                value = before + after;
                return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
            };
        };
    }
    var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
    var d3_format_types = d3.map({
        b: function (x) {
            return x.toString(2);
        },
        c: function (x) {
            return String.fromCharCode(x);
        },
        o: function (x) {
            return x.toString(8);
        },
        x: function (x) {
            return x.toString(16);
        },
        X: function (x) {
            return x.toString(16).toUpperCase();
        },
        g: function (x, p) {
            return x.toPrecision(p);
        },
        e: function (x, p) {
            return x.toExponential(p);
        },
        f: function (x, p) {
            return x.toFixed(p);
        },
        r: function (x, p) {
            return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
        }
    });
    function d3_format_typeDefault(x) {
        return x + "";
    }
    var d3_time = d3.time = {}, d3_date = Date;
    function d3_date_utc() {
        this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
    }
    d3_date_utc.prototype = {
        getDate: function () {
            return this._.getUTCDate();
        },
        getDay: function () {
            return this._.getUTCDay();
        },
        getFullYear: function () {
            return this._.getUTCFullYear();
        },
        getHours: function () {
            return this._.getUTCHours();
        },
        getMilliseconds: function () {
            return this._.getUTCMilliseconds();
        },
        getMinutes: function () {
            return this._.getUTCMinutes();
        },
        getMonth: function () {
            return this._.getUTCMonth();
        },
        getSeconds: function () {
            return this._.getUTCSeconds();
        },
        getTime: function () {
            return this._.getTime();
        },
        getTimezoneOffset: function () {
            return 0;
        },
        valueOf: function () {
            return this._.valueOf();
        },
        setDate: function () {
            d3_time_prototype.setUTCDate.apply(this._, arguments);
        },
        setDay: function () {
            d3_time_prototype.setUTCDay.apply(this._, arguments);
        },
        setFullYear: function () {
            d3_time_prototype.setUTCFullYear.apply(this._, arguments);
        },
        setHours: function () {
            d3_time_prototype.setUTCHours.apply(this._, arguments);
        },
        setMilliseconds: function () {
            d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
        },
        setMinutes: function () {
            d3_time_prototype.setUTCMinutes.apply(this._, arguments);
        },
        setMonth: function () {
            d3_time_prototype.setUTCMonth.apply(this._, arguments);
        },
        setSeconds: function () {
            d3_time_prototype.setUTCSeconds.apply(this._, arguments);
        },
        setTime: function () {
            d3_time_prototype.setTime.apply(this._, arguments);
        }
    };
    var d3_time_prototype = Date.prototype;
    function d3_time_interval(local, step, number) {
        function round(date) {
            var d0 = local(date), d1 = offset(d0, 1);
            return date - d0 < d1 - date ? d0 : d1;
        }
        function ceil(date) {
            step(date = local(new d3_date(date - 1)), 1);
            return date;
        }
        function offset(date, k) {
            step(date = new d3_date(+date), k);
            return date;
        }
        function range(t0, t1, dt) {
            var time = ceil(t0), times = [];
            if (dt > 1) {
                while (time < t1) {
                    if (!(number(time) % dt))
                        times.push(new Date(+time));
                    step(time, 1);
                }
            }
            else {
                while (time < t1)
                    times.push(new Date(+time)), step(time, 1);
            }
            return times;
        }
        function range_utc(t0, t1, dt) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = t0;
                return range(utc, t1, dt);
            }
            finally {
                d3_date = Date;
            }
        }
        local.floor = local;
        local.round = round;
        local.ceil = ceil;
        local.offset = offset;
        local.range = range;
        var utc = local.utc = d3_time_interval_utc(local);
        utc.floor = utc;
        utc.round = d3_time_interval_utc(round);
        utc.ceil = d3_time_interval_utc(ceil);
        utc.offset = d3_time_interval_utc(offset);
        utc.range = range_utc;
        return local;
    }
    function d3_time_interval_utc(method) {
        return function (date, k) {
            try {
                d3_date = d3_date_utc;
                var utc = new d3_date_utc();
                utc._ = date;
                return method(utc, k)._;
            }
            finally {
                d3_date = Date;
            }
        };
    }
    d3_time.year = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setMonth(0, 1);
        return date;
    }, function (date, offset) {
        date.setFullYear(date.getFullYear() + offset);
    }, function (date) {
        return date.getFullYear();
    });
    d3_time.years = d3_time.year.range;
    d3_time.years.utc = d3_time.year.utc.range;
    d3_time.day = d3_time_interval(function (date) {
        var day = new d3_date(2e3, 0);
        day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
        return day;
    }, function (date, offset) {
        date.setDate(date.getDate() + offset);
    }, function (date) {
        return date.getDate() - 1;
    });
    d3_time.days = d3_time.day.range;
    d3_time.days.utc = d3_time.day.utc.range;
    d3_time.dayOfYear = function (date) {
        var year = d3_time.year(date);
        return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
    };
    ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"].forEach(function (day, i) {
        i = 7 - i;
        var interval = d3_time[day] = d3_time_interval(function (date) {
            (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
            return date;
        }, function (date, offset) {
            date.setDate(date.getDate() + Math.floor(offset) * 7);
        }, function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
        });
        d3_time[day + "s"] = interval.range;
        d3_time[day + "s"].utc = interval.utc.range;
        d3_time[day + "OfYear"] = function (date) {
            var day = d3_time.year(date).getDay();
            return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
        };
    });
    d3_time.week = d3_time.sunday;
    d3_time.weeks = d3_time.sunday.range;
    d3_time.weeks.utc = d3_time.sunday.utc.range;
    d3_time.weekOfYear = d3_time.sundayOfYear;
    function d3_locale_timeFormat(locale) {
        var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
        function d3_time_format(template) {
            var n = template.length;
            function format(date) {
                var string = [], i = -1, j = 0, c, p, f;
                while (++i < n) {
                    if (template.charCodeAt(i) === 37) {
                        string.push(template.slice(j, i));
                        if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null)
                            c = template.charAt(++i);
                        if (f = d3_time_formats[c])
                            c = f(date, p == null ? c === "e" ? " " : "0" : p);
                        string.push(c);
                        j = i + 1;
                    }
                }
                string.push(template.slice(j, i));
                return string.join("");
            }
            format.parse = function (string) {
                var d = {
                    y: 1900,
                    m: 0,
                    d: 1,
                    H: 0,
                    M: 0,
                    S: 0,
                    L: 0,
                    Z: null
                }, i = d3_time_parse(d, template, string, 0);
                if (i != string.length)
                    return null;
                if ("p" in d)
                    d.H = d.H % 12 + d.p * 12;
                var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
                if ("j" in d)
                    date.setFullYear(d.y, 0, d.j);
                else if ("W" in d || "U" in d) {
                    if (!("w" in d))
                        d.w = "W" in d ? 1 : 0;
                    date.setFullYear(d.y, 0, 1);
                    date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
                }
                else
                    date.setFullYear(d.y, d.m, d.d);
                date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
                return localZ ? date._ : date;
            };
            format.toString = function () {
                return template;
            };
            return format;
        }
        function d3_time_parse(date, template, string, j) {
            var c, p, t, i = 0, n = template.length, m = string.length;
            while (i < n) {
                if (j >= m)
                    return -1;
                c = template.charCodeAt(i++);
                if (c === 37) {
                    t = template.charAt(i++);
                    p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
                    if (!p || (j = p(date, string, j)) < 0)
                        return -1;
                }
                else if (c != string.charCodeAt(j++)) {
                    return -1;
                }
            }
            return j;
        }
        d3_time_format.utc = function (template) {
            var local = d3_time_format(template);
            function format(date) {
                try {
                    d3_date = d3_date_utc;
                    var utc = new d3_date();
                    utc._ = date;
                    return local(utc);
                }
                finally {
                    d3_date = Date;
                }
            }
            format.parse = function (string) {
                try {
                    d3_date = d3_date_utc;
                    var date = local.parse(string);
                    return date && date._;
                }
                finally {
                    d3_date = Date;
                }
            };
            format.toString = local.toString;
            return format;
        };
        d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
        var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
        locale_periods.forEach(function (p, i) {
            d3_time_periodLookup.set(p.toLowerCase(), i);
        });
        var d3_time_formats = {
            a: function (d) {
                return locale_shortDays[d.getDay()];
            },
            A: function (d) {
                return locale_days[d.getDay()];
            },
            b: function (d) {
                return locale_shortMonths[d.getMonth()];
            },
            B: function (d) {
                return locale_months[d.getMonth()];
            },
            c: d3_time_format(locale_dateTime),
            d: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            e: function (d, p) {
                return d3_time_formatPad(d.getDate(), p, 2);
            },
            H: function (d, p) {
                return d3_time_formatPad(d.getHours(), p, 2);
            },
            I: function (d, p) {
                return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
            },
            j: function (d, p) {
                return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
            },
            L: function (d, p) {
                return d3_time_formatPad(d.getMilliseconds(), p, 3);
            },
            m: function (d, p) {
                return d3_time_formatPad(d.getMonth() + 1, p, 2);
            },
            M: function (d, p) {
                return d3_time_formatPad(d.getMinutes(), p, 2);
            },
            p: function (d) {
                return locale_periods[+(d.getHours() >= 12)];
            },
            S: function (d, p) {
                return d3_time_formatPad(d.getSeconds(), p, 2);
            },
            U: function (d, p) {
                return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
            },
            w: function (d) {
                return d.getDay();
            },
            W: function (d, p) {
                return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
            },
            x: d3_time_format(locale_date),
            X: d3_time_format(locale_time),
            y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 100, p, 2);
            },
            Y: function (d, p) {
                return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
            },
            Z: d3_time_zone,
            "%": function () {
                return "%";
            }
        };
        var d3_time_parsers = {
            a: d3_time_parseWeekdayAbbrev,
            A: d3_time_parseWeekday,
            b: d3_time_parseMonthAbbrev,
            B: d3_time_parseMonth,
            c: d3_time_parseLocaleFull,
            d: d3_time_parseDay,
            e: d3_time_parseDay,
            H: d3_time_parseHour24,
            I: d3_time_parseHour24,
            j: d3_time_parseDayOfYear,
            L: d3_time_parseMilliseconds,
            m: d3_time_parseMonthNumber,
            M: d3_time_parseMinutes,
            p: d3_time_parseAmPm,
            S: d3_time_parseSeconds,
            U: d3_time_parseWeekNumberSunday,
            w: d3_time_parseWeekdayNumber,
            W: d3_time_parseWeekNumberMonday,
            x: d3_time_parseLocaleDate,
            X: d3_time_parseLocaleTime,
            y: d3_time_parseYear,
            Y: d3_time_parseFullYear,
            Z: d3_time_parseZone,
            "%": d3_time_parseLiteralPercent
        };
        function d3_time_parseWeekdayAbbrev(date, string, i) {
            d3_time_dayAbbrevRe.lastIndex = 0;
            var n = d3_time_dayAbbrevRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseWeekday(date, string, i) {
            d3_time_dayRe.lastIndex = 0;
            var n = d3_time_dayRe.exec(string.slice(i));
            return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonthAbbrev(date, string, i) {
            d3_time_monthAbbrevRe.lastIndex = 0;
            var n = d3_time_monthAbbrevRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseMonth(date, string, i) {
            d3_time_monthRe.lastIndex = 0;
            var n = d3_time_monthRe.exec(string.slice(i));
            return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
        }
        function d3_time_parseLocaleFull(date, string, i) {
            return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
        }
        function d3_time_parseLocaleDate(date, string, i) {
            return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
        }
        function d3_time_parseLocaleTime(date, string, i) {
            return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
        }
        function d3_time_parseAmPm(date, string, i) {
            var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
            return n == null ? -1 : (date.p = n, i);
        }
        return d3_time_format;
    }
    var d3_time_formatPads = {
        "-": "",
        _: " ",
        "0": "0"
    }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
    function d3_time_formatPad(value, fill, width) {
        var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
        return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }
    function d3_time_formatRe(names) {
        return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
    }
    function d3_time_formatLookup(names) {
        var map = new d3_Map(), i = -1, n = names.length;
        while (++i < n)
            map.set(names[i].toLowerCase(), i);
        return map;
    }
    function d3_time_parseWeekdayNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 1));
        return n ? (date.w = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberSunday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.U = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseWeekNumberMonday(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i));
        return n ? (date.W = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseFullYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 4));
        return n ? (date.y = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
    }
    function d3_time_parseZone(date, string, i) {
        return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string,
            i + 5) : -1;
    }
    function d3_time_expandYear(d) {
        return d + (d > 68 ? 1900 : 2e3);
    }
    function d3_time_parseMonthNumber(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
    }
    function d3_time_parseDay(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.d = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseDayOfYear(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.j = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseHour24(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.H = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMinutes(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.M = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseSeconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 2));
        return n ? (date.S = +n[0], i + n[0].length) : -1;
    }
    function d3_time_parseMilliseconds(date, string, i) {
        d3_time_numberRe.lastIndex = 0;
        var n = d3_time_numberRe.exec(string.slice(i, i + 3));
        return n ? (date.L = +n[0], i + n[0].length) : -1;
    }
    function d3_time_zone(d) {
        var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
        return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
    }
    function d3_time_parseLiteralPercent(date, string, i) {
        d3_time_percentRe.lastIndex = 0;
        var n = d3_time_percentRe.exec(string.slice(i, i + 1));
        return n ? i + n[0].length : -1;
    }
    function d3_time_formatMulti(formats) {
        var n = formats.length, i = -1;
        while (++i < n)
            formats[i][0] = this(formats[i][0]);
        return function (date) {
            var i = 0, f = formats[i];
            while (!f[1](date))
                f = formats[++i];
            return f[0](date);
        };
    }
    d3.locale = function (locale) {
        return {
            numberFormat: d3_locale_numberFormat(locale),
            timeFormat: d3_locale_timeFormat(locale)
        };
    };
    var d3_locale_enUS = d3.locale({
        decimal: ".",
        thousands: ",",
        grouping: [3],
        currency: ["$", ""],
        dateTime: "%a %b %e %X %Y",
        date: "%m/%d/%Y",
        time: "%H:%M:%S",
        periods: ["AM", "PM"],
        days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });
    d3.format = d3_locale_enUS.numberFormat;
    d3.geo = {};
    function d3_adder() { }
    d3_adder.prototype = {
        s: 0,
        t: 0,
        add: function (y) {
            d3_adderSum(y, this.t, d3_adderTemp);
            d3_adderSum(d3_adderTemp.s, this.s, this);
            if (this.s)
                this.t += d3_adderTemp.t;
            else
                this.s = d3_adderTemp.t;
        },
        reset: function () {
            this.s = this.t = 0;
        },
        valueOf: function () {
            return this.s;
        }
    };
    var d3_adderTemp = new d3_adder();
    function d3_adderSum(a, b, o) {
        var x = o.s = a + b, bv = x - a, av = x - bv;
        o.t = a - av + (b - bv);
    }
    d3.geo.stream = function (object, listener) {
        if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
            d3_geo_streamObjectType[object.type](object, listener);
        }
        else {
            d3_geo_streamGeometry(object, listener);
        }
    };
    function d3_geo_streamGeometry(geometry, listener) {
        if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
            d3_geo_streamGeometryType[geometry.type](geometry, listener);
        }
    }
    var d3_geo_streamObjectType = {
        Feature: function (feature, listener) {
            d3_geo_streamGeometry(feature.geometry, listener);
        },
        FeatureCollection: function (object, listener) {
            var features = object.features, i = -1, n = features.length;
            while (++i < n)
                d3_geo_streamGeometry(features[i].geometry, listener);
        }
    };
    var d3_geo_streamGeometryType = {
        Sphere: function (object, listener) {
            listener.sphere();
        },
        Point: function (object, listener) {
            object = object.coordinates;
            listener.point(object[0], object[1], object[2]);
        },
        MultiPoint: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                object = coordinates[i], listener.point(object[0], object[1], object[2]);
        },
        LineString: function (object, listener) {
            d3_geo_streamLine(object.coordinates, listener, 0);
        },
        MultiLineString: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamLine(coordinates[i], listener, 0);
        },
        Polygon: function (object, listener) {
            d3_geo_streamPolygon(object.coordinates, listener);
        },
        MultiPolygon: function (object, listener) {
            var coordinates = object.coordinates, i = -1, n = coordinates.length;
            while (++i < n)
                d3_geo_streamPolygon(coordinates[i], listener);
        },
        GeometryCollection: function (object, listener) {
            var geometries = object.geometries, i = -1, n = geometries.length;
            while (++i < n)
                d3_geo_streamGeometry(geometries[i], listener);
        }
    };
    function d3_geo_streamLine(coordinates, listener, closed) {
        var i = -1, n = coordinates.length - closed, coordinate;
        listener.lineStart();
        while (++i < n)
            coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
        listener.lineEnd();
    }
    function d3_geo_streamPolygon(coordinates, listener) {
        var i = -1, n = coordinates.length;
        listener.polygonStart();
        while (++i < n)
            d3_geo_streamLine(coordinates[i], listener, 1);
        listener.polygonEnd();
    }
    d3.geo.area = function (object) {
        d3_geo_areaSum = 0;
        d3.geo.stream(object, d3_geo_area);
        return d3_geo_areaSum;
    };
    var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
    var d3_geo_area = {
        sphere: function () {
            d3_geo_areaSum += 4 * pipipi;
        },
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
            d3_geo_areaRingSum.reset();
            d3_geo_area.lineStart = d3_geo_areaRingStart;
        },
        polygonEnd: function () {
            var area = 2 * d3_geo_areaRingSum;
            d3_geo_areaSum += area < 0 ? 4 * pipipi + area : area;
            d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
        }
    };
    function d3_geo_areaRingStart() {
        var lambda00, phi00, lambda0, cosphi0, sinphi0;
        d3_geo_area.point = function (lambda, phi) {
            d3_geo_area.point = nextPoint;
            lambda0 = (lambda00 = lambda) * d3_radians, cosphi0 = Math.cos(phi = (phi00 = phi) * d3_radians / 2 + pipipi / 4),
                sinphi0 = Math.sin(phi);
        };
        function nextPoint(lambda, phi) {
            lambda *= d3_radians;
            phi = phi * d3_radians / 2 + pipipi / 4;
            var dlambda = lambda - lambda0, sdlambda = dlambda >= 0 ? 1 : -1, adlambda = sdlambda * dlambda, cosphi = Math.cos(phi), sinphi = Math.sin(phi), k = sinphi0 * sinphi, u = cosphi0 * cosphi + k * Math.cos(adlambda), v = k * sdlambda * Math.sin(adlambda);
            d3_geo_areaRingSum.add(Math.atan2(v, u));
            lambda0 = lambda, cosphi0 = cosphi, sinphi0 = sinphi;
        }
        d3_geo_area.lineEnd = function () {
            nextPoint(lambda00, phi00);
        };
    }
    function d3_geo_cartesian(spherical) {
        var lambda = spherical[0], phi = spherical[1], cosphi = Math.cos(phi);
        return [cosphi * Math.cos(lambda), cosphi * Math.sin(lambda), Math.sin(phi)];
    }
    function d3_geo_cartesianDot(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }
    function d3_geo_cartesianCross(a, b) {
        return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }
    function d3_geo_cartesianAdd(a, b) {
        a[0] += b[0];
        a[1] += b[1];
        a[2] += b[2];
    }
    function d3_geo_cartesianScale(vector, k) {
        return [vector[0] * k, vector[1] * k, vector[2] * k];
    }
    function d3_geo_cartesianNormalize(d) {
        var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
        d[0] /= l;
        d[1] /= l;
        d[2] /= l;
    }
    function d3_geo_spherical(cartesian) {
        return [Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2])];
    }
    function d3_geo_sphericalEqual(a, b) {
        return abs(a[0] - b[0]) < epsilon && abs(a[1] - b[1]) < epsilon;
    }
    d3.geo.bounds = function () {
        var lambda0, phi0, lambda1, phi1, lambda_, lambda__, phi__, p0, dlambdaSum, ranges, range;
        var bound = {
            point: point,
            lineStart: lineStart,
            lineEnd: lineEnd,
            polygonStart: function () {
                bound.point = ringPoint;
                bound.lineStart = ringStart;
                bound.lineEnd = ringEnd;
                dlambdaSum = 0;
                d3_geo_area.polygonStart();
            },
            polygonEnd: function () {
                d3_geo_area.polygonEnd();
                bound.point = point;
                bound.lineStart = lineStart;
                bound.lineEnd = lineEnd;
                if (d3_geo_areaRingSum < 0)
                    lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);
                else if (dlambdaSum > epsilon)
                    phi1 = 90;
                else if (dlambdaSum < -epsilon)
                    phi0 = -90;
                range[0] = lambda0, range[1] = lambda1;
            }
        };
        function point(lambda, phi) {
            ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
            if (phi < phi0)
                phi0 = phi;
            if (phi > phi1)
                phi1 = phi;
        }
        function linePoint(lambda, phi) {
            var p = d3_geo_cartesian([lambda * d3_radians, phi * d3_radians]);
            if (p0) {
                var normal = d3_geo_cartesianCross(p0, p), equatorial = [normal[1], -normal[0], 0], inflection = d3_geo_cartesianCross(equatorial, normal);
                d3_geo_cartesianNormalize(inflection);
                inflection = d3_geo_spherical(inflection);
                var dlambda = lambda - lambda_, s = dlambda > 0 ? 1 : -1, lambdai = inflection[0] * d3_degrees * s, antimeridian = abs(dlambda) > 180;
                if (antimeridian ^ (s * lambda_ < lambdai && lambdai < s * lambda)) {
                    var phii = inflection[1] * d3_degrees;
                    if (phii > phi1)
                        phi1 = phii;
                }
                else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (s * lambda_ < lambdai && lambdai < s * lambda)) {
                    var phii = -inflection[1] * d3_degrees;
                    if (phii < phi0)
                        phi0 = phii;
                }
                else {
                    if (phi < phi0)
                        phi0 = phi;
                    if (phi > phi1)
                        phi1 = phi;
                }
                if (antimeridian) {
                    if (lambda < lambda_) {
                        if (angle(lambda0, lambda) > angle(lambda0, lambda1))
                            lambda1 = lambda;
                    }
                    else {
                        if (angle(lambda, lambda1) > angle(lambda0, lambda1))
                            lambda0 = lambda;
                    }
                }
                else {
                    if (lambda1 >= lambda0) {
                        if (lambda < lambda0)
                            lambda0 = lambda;
                        if (lambda > lambda1)
                            lambda1 = lambda;
                    }
                    else {
                        if (lambda > lambda_) {
                            if (angle(lambda0, lambda) > angle(lambda0, lambda1))
                                lambda1 = lambda;
                        }
                        else {
                            if (angle(lambda, lambda1) > angle(lambda0, lambda1))
                                lambda0 = lambda;
                        }
                    }
                }
            }
            else {
                point(lambda, phi);
            }
            p0 = p, lambda_ = lambda;
        }
        function lineStart() {
            bound.point = linePoint;
        }
        function lineEnd() {
            range[0] = lambda0, range[1] = lambda1;
            bound.point = point;
            p0 = null;
        }
        function ringPoint(lambda, phi) {
            if (p0) {
                var dlambda = lambda - lambda_;
                dlambdaSum += abs(dlambda) > 180 ? dlambda + (dlambda > 0 ? 360 : -360) : dlambda;
            }
            else
                lambda__ = lambda, phi__ = phi;
            d3_geo_area.point(lambda, phi);
            linePoint(lambda, phi);
        }
        function ringStart() {
            d3_geo_area.lineStart();
        }
        function ringEnd() {
            ringPoint(lambda__, phi__);
            d3_geo_area.lineEnd();
            if (abs(dlambdaSum) > epsilon)
                lambda0 = -(lambda1 = 180);
            range[0] = lambda0, range[1] = lambda1;
            p0 = null;
        }
        function angle(lambda0, lambda1) {
            return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
        }
        function compareRanges(a, b) {
            return a[0] - b[0];
        }
        function withinRange(x, range) {
            return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
        }
        return function (feature) {
            phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
            ranges = [];
            d3.geo.stream(feature, bound);
            var n = ranges.length;
            if (n) {
                ranges.sort(compareRanges);
                for (var i = 1, a = ranges[0], b, merged = [a]; i < n; ++i) {
                    b = ranges[i];
                    if (withinRange(b[0], a) || withinRange(b[1], a)) {
                        if (angle(a[0], b[1]) > angle(a[0], a[1]))
                            a[1] = b[1];
                        if (angle(b[0], a[1]) > angle(a[0], a[1]))
                            a[0] = b[0];
                    }
                    else {
                        merged.push(a = b);
                    }
                }
                var best = -Infinity, dlambda;
                for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
                    b = merged[i];
                    if ((dlambda = angle(a[1], b[0])) > best)
                        best = dlambda, lambda0 = b[0], lambda1 = a[1];
                }
            }
            ranges = range = null;
            return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
        };
    }();
    d3.geo.centroid = function (object) {
        d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
        d3.geo.stream(object, d3_geo_centroid);
        var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
        if (m < epsilon2) {
            x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
            if (d3_geo_centroidW1 < epsilon)
                x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
            m = x * x + y * y + z * z;
            if (m < epsilon2)
                return [NaN, NaN];
        }
        return [Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees];
    };
    var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
    var d3_geo_centroid = {
        sphere: d3_noop,
        point: d3_geo_centroidPoint,
        lineStart: d3_geo_centroidLineStart,
        lineEnd: d3_geo_centroidLineEnd,
        polygonStart: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
        }
    };
    function d3_geo_centroidPoint(lambda, phi) {
        lambda *= d3_radians;
        var cosphi = Math.cos(phi *= d3_radians);
        d3_geo_centroidPointXYZ(cosphi * Math.cos(lambda), cosphi * Math.sin(lambda), Math.sin(phi));
    }
    function d3_geo_centroidPointXYZ(x, y, z) {
        ++d3_geo_centroidW0;
        d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
        d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
        d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
    }
    function d3_geo_centroidLineStart() {
        var x0, y0, z0;
        d3_geo_centroid.point = function (lambda, phi) {
            lambda *= d3_radians;
            var cosphi = Math.cos(phi *= d3_radians);
            x0 = cosphi * Math.cos(lambda);
            y0 = cosphi * Math.sin(lambda);
            z0 = Math.sin(phi);
            d3_geo_centroid.point = nextPoint;
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        function nextPoint(lambda, phi) {
            lambda *= d3_radians;
            var cosphi = Math.cos(phi *= d3_radians), x = cosphi * Math.cos(lambda), y = cosphi * Math.sin(lambda), z = Math.sin(phi), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_centroidLineEnd() {
        d3_geo_centroid.point = d3_geo_centroidPoint;
    }
    function d3_geo_centroidRingStart() {
        var lambda00, phi00, x0, y0, z0;
        d3_geo_centroid.point = function (lambda, phi) {
            lambda00 = lambda, phi00 = phi;
            d3_geo_centroid.point = nextPoint;
            lambda *= d3_radians;
            var cosphi = Math.cos(phi *= d3_radians);
            x0 = cosphi * Math.cos(lambda);
            y0 = cosphi * Math.sin(lambda);
            z0 = Math.sin(phi);
            d3_geo_centroidPointXYZ(x0, y0, z0);
        };
        d3_geo_centroid.lineEnd = function () {
            nextPoint(lambda00, phi00);
            d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
            d3_geo_centroid.point = d3_geo_centroidPoint;
        };
        function nextPoint(lambda, phi) {
            lambda *= d3_radians;
            var cosphi = Math.cos(phi *= d3_radians), x = cosphi * Math.cos(lambda), y = cosphi * Math.sin(lambda), z = Math.sin(phi), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
            d3_geo_centroidX2 += v * cx;
            d3_geo_centroidY2 += v * cy;
            d3_geo_centroidZ2 += v * cz;
            d3_geo_centroidW1 += w;
            d3_geo_centroidX1 += w * (x0 + (x0 = x));
            d3_geo_centroidY1 += w * (y0 + (y0 = y));
            d3_geo_centroidZ1 += w * (z0 + (z0 = z));
            d3_geo_centroidPointXYZ(x0, y0, z0);
        }
    }
    function d3_geo_compose(a, b) {
        function compose(x, y) {
            return x = a(x, y), b(x[0], x[1]);
        }
        if (a.invert && b.invert)
            compose.invert = function (x, y) {
                return x = b.invert(x, y), x && a.invert(x[0], x[1]);
            };
        return compose;
    }
    function d3_true() {
        return true;
    }
    function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
        var subject = [], clip = [];
        segments.forEach(function (segment) {
            if ((n = segment.length - 1) <= 0)
                return;
            var n, p0 = segment[0], p1 = segment[n];
            if (d3_geo_sphericalEqual(p0, p1)) {
                listener.lineStart();
                for (var i = 0; i < n; ++i)
                    listener.point((p0 = segment[i])[0], p0[1]);
                listener.lineEnd();
                return;
            }
            var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
            a.o = b;
            subject.push(a);
            clip.push(b);
            a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
            b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
            a.o = b;
            subject.push(a);
            clip.push(b);
        });
        clip.sort(compare);
        d3_geo_clipPolygonLinkCircular(subject);
        d3_geo_clipPolygonLinkCircular(clip);
        if (!subject.length)
            return;
        for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
            clip[i].e = entry = !entry;
        }
        var start = subject[0], points, point;
        while (1) {
            var current = start, isSubject = true;
            while (current.v)
                if ((current = current.n) === start)
                    return;
            points = current.z;
            listener.lineStart();
            do {
                current.v = current.o.v = true;
                if (current.e) {
                    if (isSubject) {
                        for (var i = 0, n = points.length; i < n; ++i)
                            listener.point((point = points[i])[0], point[1]);
                    }
                    else {
                        interpolate(current.x, current.n.x, 1, listener);
                    }
                    current = current.n;
                }
                else {
                    if (isSubject) {
                        points = current.p.z;
                        for (var i = points.length - 1; i >= 0; --i)
                            listener.point((point = points[i])[0], point[1]);
                    }
                    else {
                        interpolate(current.x, current.p.x, -1, listener);
                    }
                    current = current.p;
                }
                current = current.o;
                points = current.z;
                isSubject = !isSubject;
            } while (!current.v);
            listener.lineEnd();
        }
    }
    function d3_geo_clipPolygonLinkCircular(array) {
        if (!(n = array.length))
            return;
        var n, i = 0, a = array[0], b;
        while (++i < n) {
            a.n = b = array[i];
            b.p = a;
            a = b;
        }
        a.n = b = array[0];
        b.p = a;
    }
    function d3_geo_clipPolygonIntersection(point, points, other, entry) {
        this.x = point;
        this.z = points;
        this.o = other;
        this.e = entry;
        this.v = false;
        this.n = this.p = null;
    }
    function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
        return function (rotate, listener) {
            var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    clip.point = pointRing;
                    clip.lineStart = ringStart;
                    clip.lineEnd = ringEnd;
                    segments = [];
                    polygon = [];
                },
                polygonEnd: function () {
                    clip.point = point;
                    clip.lineStart = lineStart;
                    clip.lineEnd = lineEnd;
                    segments = d3.merge(segments);
                    var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
                    if (segments.length) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
                    }
                    else if (clipStartInside) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        interpolate(null, null, 1, listener);
                        listener.lineEnd();
                    }
                    if (polygonStarted)
                        listener.polygonEnd(), polygonStarted = false;
                    segments = polygon = null;
                },
                sphere: function () {
                    listener.polygonStart();
                    listener.lineStart();
                    interpolate(null, null, 1, listener);
                    listener.lineEnd();
                    listener.polygonEnd();
                }
            };
            function point(lambda, phi) {
                var point = rotate(lambda, phi);
                if (pointVisible(lambda = point[0], phi = point[1]))
                    listener.point(lambda, phi);
            }
            function pointLine(lambda, phi) {
                var point = rotate(lambda, phi);
                line.point(point[0], point[1]);
            }
            function lineStart() {
                clip.point = pointLine;
                line.lineStart();
            }
            function lineEnd() {
                clip.point = point;
                line.lineEnd();
            }
            var segments;
            var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
            function pointRing(lambda, phi) {
                ring.push([lambda, phi]);
                var point = rotate(lambda, phi);
                ringListener.point(point[0], point[1]);
            }
            function ringStart() {
                ringListener.lineStart();
                ring = [];
            }
            function ringEnd() {
                pointRing(ring[0][0], ring[0][1]);
                ringListener.lineEnd();
                var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
                ring.pop();
                polygon.push(ring);
                ring = null;
                if (!n)
                    return;
                if (clean & 1) {
                    segment = ringSegments[0];
                    var n = segment.length - 1, i = -1, point;
                    if (n > 0) {
                        if (!polygonStarted)
                            listener.polygonStart(), polygonStarted = true;
                        listener.lineStart();
                        while (++i < n)
                            listener.point((point = segment[i])[0], point[1]);
                        listener.lineEnd();
                    }
                    return;
                }
                if (n > 1 && clean & 2)
                    ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
                segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
            }
            return clip;
        };
    }
    function d3_geo_clipSegmentLength1(segment) {
        return segment.length > 1;
    }
    function d3_geo_clipBufferListener() {
        var lines = [], line;
        return {
            lineStart: function () {
                lines.push(line = []);
            },
            point: function (lambda, phi) {
                line.push([lambda, phi]);
            },
            lineEnd: d3_noop,
            buffer: function () {
                var buffer = lines;
                lines = [];
                line = null;
                return buffer;
            },
            rejoin: function () {
                if (lines.length > 1)
                    lines.push(lines.pop().concat(lines.shift()));
            }
        };
    }
    function d3_geo_clipSort(a, b) {
        return ((a = a.x)[0] < 0 ? a[1] - halfpipipi - epsilon : halfpipipi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfpipipi - epsilon : halfpipipi - b[1]);
    }
    var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [-pipipi, -pipipi / 2]);
    function d3_geo_clipAntimeridianLine(listener) {
        var lambda0 = NaN, phi0 = NaN, slambda0 = NaN, clean;
        return {
            lineStart: function () {
                listener.lineStart();
                clean = 1;
            },
            point: function (lambda1, phi1) {
                var slambda1 = lambda1 > 0 ? pipipi : -pipipi, dlambda = abs(lambda1 - lambda0);
                if (abs(dlambda - pipipi) < epsilon) {
                    listener.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfpipipi : -halfpipipi);
                    listener.point(slambda0, phi0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(slambda1, phi0);
                    listener.point(lambda1, phi0);
                    clean = 0;
                }
                else if (slambda0 !== slambda1 && dlambda >= pipipi) {
                    if (abs(lambda0 - slambda0) < epsilon)
                        lambda0 -= slambda0 * epsilon;
                    if (abs(lambda1 - slambda1) < epsilon)
                        lambda1 -= slambda1 * epsilon;
                    phi0 = d3_geo_clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
                    listener.point(slambda0, phi0);
                    listener.lineEnd();
                    listener.lineStart();
                    listener.point(slambda1, phi0);
                    clean = 0;
                }
                listener.point(lambda0 = lambda1, phi0 = phi1);
                slambda0 = slambda1;
            },
            lineEnd: function () {
                listener.lineEnd();
                lambda0 = phi0 = NaN;
            },
            clean: function () {
                return 2 - clean;
            }
        };
    }
    function d3_geo_clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
        var cosphi0, cosphi1, sinlambda0_lambda1 = Math.sin(lambda0 - lambda1);
        return abs(sinlambda0_lambda1) > epsilon ? Math.atan((Math.sin(phi0) * (cosphi1 = Math.cos(phi1)) * Math.sin(lambda1) - Math.sin(phi1) * (cosphi0 = Math.cos(phi0)) * Math.sin(lambda0)) / (cosphi0 * cosphi1 * sinlambda0_lambda1)) : (phi0 + phi1) / 2;
    }
    function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
        var phi;
        if (from == null) {
            phi = direction * halfpipipi;
            listener.point(-pipipi, phi);
            listener.point(0, phi);
            listener.point(pipipi, phi);
            listener.point(pipipi, 0);
            listener.point(pipipi, -phi);
            listener.point(0, -phi);
            listener.point(-pipipi, -phi);
            listener.point(-pipipi, 0);
            listener.point(-pipipi, phi);
        }
        else if (abs(from[0] - to[0]) > epsilon) {
            var s = from[0] < to[0] ? pipipi : -pipipi;
            phi = direction * s / 2;
            listener.point(-s, phi);
            listener.point(0, phi);
            listener.point(s, phi);
        }
        else {
            listener.point(to[0], to[1]);
        }
    }
    function d3_geo_pointInPolygon(point, polygon) {
        var meridian = point[0], parallel = point[1], meridianNormal = [Math.sin(meridian), -Math.cos(meridian), 0], polarAngle = 0, winding = 0;
        d3_geo_areaRingSum.reset();
        for (var i = 0, n = polygon.length; i < n; ++i) {
            var ring = polygon[i], m = ring.length;
            if (!m)
                continue;
            var point0 = ring[0], lambda0 = point0[0], phi0 = point0[1] / 2 + pipipi / 4, sinphi0 = Math.sin(phi0), cosphi0 = Math.cos(phi0), j = 1;
            while (true) {
                if (j === m)
                    j = 0;
                point = ring[j];
                var lambda = point[0], phi = point[1] / 2 + pipipi / 4, sinphi = Math.sin(phi), cosphi = Math.cos(phi), dlambda = lambda - lambda0, sdlambda = dlambda >= 0 ? 1 : -1, adlambda = sdlambda * dlambda, antimeridian = adlambda > pipipi, k = sinphi0 * sinphi;
                d3_geo_areaRingSum.add(Math.atan2(k * sdlambda * Math.sin(adlambda), cosphi0 * cosphi + k * Math.cos(adlambda)));
                polarAngle += antimeridian ? dlambda + sdlambda * tau : dlambda;
                if (antimeridian ^ lambda0 >= meridian ^ lambda >= meridian) {
                    var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
                    d3_geo_cartesianNormalize(arc);
                    var intersection = d3_geo_cartesianCross(meridianNormal, arc);
                    d3_geo_cartesianNormalize(intersection);
                    var phiarc = (antimeridian ^ dlambda >= 0 ? -1 : 1) * d3_asin(intersection[2]);
                    if (parallel > phiarc || parallel === phiarc && (arc[0] || arc[1])) {
                        winding += antimeridian ^ dlambda >= 0 ? 1 : -1;
                    }
                }
                if (!j++)
                    break;
                lambda0 = lambda, sinphi0 = sinphi, cosphi0 = cosphi, point0 = point;
            }
        }
        return (polarAngle < -epsilon || polarAngle < epsilon && d3_geo_areaRingSum < -epsilon) ^ winding & 1;
    }
    function d3_geo_clipCircle(radius) {
        var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > epsilon, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
        return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pipipi, radius - pipipi]);
        function visible(lambda, phi) {
            return Math.cos(lambda) * Math.cos(phi) > cr;
        }
        function clipLine(listener) {
            var point0, c0, v0, v00, clean;
            return {
                lineStart: function () {
                    v00 = v0 = false;
                    clean = 1;
                },
                point: function (lambda, phi) {
                    var point1 = [lambda, phi], point2, v = visible(lambda, phi), c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pipipi : -pipipi), phi) : 0;
                    if (!point0 && (v00 = v0 = v))
                        listener.lineStart();
                    if (v !== v0) {
                        point2 = intersect(point0, point1);
                        if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
                            point1[0] += epsilon;
                            point1[1] += epsilon;
                            v = visible(point1[0], point1[1]);
                        }
                    }
                    if (v !== v0) {
                        clean = 0;
                        if (v) {
                            listener.lineStart();
                            point2 = intersect(point1, point0);
                            listener.point(point2[0], point2[1]);
                        }
                        else {
                            point2 = intersect(point0, point1);
                            listener.point(point2[0], point2[1]);
                            listener.lineEnd();
                        }
                        point0 = point2;
                    }
                    else if (notHemisphere && point0 && smallRadius ^ v) {
                        var t;
                        if (!(c & c0) && (t = intersect(point1, point0, true))) {
                            clean = 0;
                            if (smallRadius) {
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                            }
                            else {
                                listener.point(t[1][0], t[1][1]);
                                listener.lineEnd();
                                listener.lineStart();
                                listener.point(t[0][0], t[0][1]);
                            }
                        }
                    }
                    if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
                        listener.point(point1[0], point1[1]);
                    }
                    point0 = point1, v0 = v, c0 = c;
                },
                lineEnd: function () {
                    if (v0)
                        listener.lineEnd();
                    point0 = null;
                },
                clean: function () {
                    return clean | (v00 && v0) << 1;
                }
            };
        }
        function intersect(a, b, two) {
            var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
            var n1 = [1, 0, 0], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
            if (!determinant)
                return !two && a;
            var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
            d3_geo_cartesianAdd(A, B);
            var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
            if (t2 < 0)
                return;
            var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
            d3_geo_cartesianAdd(q, A);
            q = d3_geo_spherical(q);
            if (!two)
                return q;
            var lambda0 = a[0], lambda1 = b[0], phi0 = a[1], phi1 = b[1], z;
            if (lambda1 < lambda0)
                z = lambda0, lambda0 = lambda1, lambda1 = z;
            var deltalambda = lambda1 - lambda0, polar = abs(deltalambda - pipipi) < epsilon, meridian = polar || deltalambda < epsilon;
            if (!polar && phi1 < phi0)
                z = phi0, phi0 = phi1, phi1 = z;
            if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs(q[0] - lambda0) < epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : deltalambda > pipipi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
                var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
                d3_geo_cartesianAdd(q1, A);
                return [q, d3_geo_spherical(q1)];
            }
        }
        function code(lambda, phi) {
            var r = smallRadius ? radius : pipipi - radius, code = 0;
            if (lambda < -r)
                code |= 1;
            else if (lambda > r)
                code |= 2;
            if (phi < -r)
                code |= 4;
            else if (phi > r)
                code |= 8;
            return code;
        }
    }
    function d3_geom_clipLine(x0, y0, x1, y1) {
        return function (line) {
            var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
            r = x0 - ax;
            if (!dx && r > 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            else if (dx > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = x1 - ax;
            if (!dx && r < 0)
                return;
            r /= dx;
            if (dx < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            else if (dx > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            r = y0 - ay;
            if (!dy && r > 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            else if (dy > 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            r = y1 - ay;
            if (!dy && r < 0)
                return;
            r /= dy;
            if (dy < 0) {
                if (r > t1)
                    return;
                if (r > t0)
                    t0 = r;
            }
            else if (dy > 0) {
                if (r < t0)
                    return;
                if (r < t1)
                    t1 = r;
            }
            if (t0 > 0)
                line.a = {
                    x: ax + t0 * dx,
                    y: ay + t0 * dy
                };
            if (t1 < 1)
                line.b = {
                    x: ax + t1 * dx,
                    y: ay + t1 * dy
                };
            return line;
        };
    }
    var d3_geo_clipExtentMAX = 1e9;
    d3.geo.clipExtent = function () {
        var x0, y0, x1, y1, stream, clip, clipExtent = {
            stream: function (output) {
                if (stream)
                    stream.valid = false;
                stream = clip(output);
                stream.valid = true;
                return stream;
            },
            extent: function (_) {
                if (!arguments.length)
                    return [[x0, y0], [x1, y1]];
                clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
                if (stream)
                    stream.valid = false, stream = null;
                return clipExtent;
            }
        };
        return clipExtent.extent([[0, 0], [960, 500]]);
    };
    function d3_geo_clipExtent(x0, y0, x1, y1) {
        return function (listener) {
            var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
            var clip = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    listener = bufferListener;
                    segments = [];
                    polygon = [];
                    clean = true;
                },
                polygonEnd: function () {
                    listener = listener_;
                    segments = d3.merge(segments);
                    var clipStartInside = insidePolygon([x0, y1]), inside = clean && clipStartInside, visible = segments.length;
                    if (inside || visible) {
                        listener.polygonStart();
                        if (inside) {
                            listener.lineStart();
                            interpolate(null, null, 1, listener);
                            listener.lineEnd();
                        }
                        if (visible) {
                            d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
                        }
                        listener.polygonEnd();
                    }
                    segments = polygon = ring = null;
                }
            };
            function insidePolygon(p) {
                var wn = 0, n = polygon.length, y = p[1];
                for (var i = 0; i < n; ++i) {
                    for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
                        b = v[j];
                        if (a[1] <= y) {
                            if (b[1] > y && d3_cross2d(a, b, p) > 0)
                                ++wn;
                        }
                        else {
                            if (b[1] <= y && d3_cross2d(a, b, p) < 0)
                                --wn;
                        }
                        a = b;
                    }
                }
                return wn !== 0;
            }
            function interpolate(from, to, direction, listener) {
                var a = 0, a1 = 0;
                if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
                    do {
                        listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
                    } while ((a = (a + direction + 4) % 4) !== a1);
                }
                else {
                    listener.point(to[0], to[1]);
                }
            }
            function pointVisible(x, y) {
                return x0 <= x && x <= x1 && y0 <= y && y <= y1;
            }
            function point(x, y) {
                if (pointVisible(x, y))
                    listener.point(x, y);
            }
            var x__, y__, v__, x_, y_, v_, first, clean;
            function lineStart() {
                clip.point = linePoint;
                if (polygon)
                    polygon.push(ring = []);
                first = true;
                v_ = false;
                x_ = y_ = NaN;
            }
            function lineEnd() {
                if (segments) {
                    linePoint(x__, y__);
                    if (v__ && v_)
                        bufferListener.rejoin();
                    segments.push(bufferListener.buffer());
                }
                clip.point = point;
                if (v_)
                    listener.lineEnd();
            }
            function linePoint(x, y) {
                x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
                y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
                var v = pointVisible(x, y);
                if (polygon)
                    ring.push([x, y]);
                if (first) {
                    x__ = x, y__ = y, v__ = v;
                    first = false;
                    if (v) {
                        listener.lineStart();
                        listener.point(x, y);
                    }
                }
                else {
                    if (v && v_)
                        listener.point(x, y);
                    else {
                        var l = {
                            a: {
                                x: x_,
                                y: y_
                            },
                            b: {
                                x: x,
                                y: y
                            }
                        };
                        if (clipLine(l)) {
                            if (!v_) {
                                listener.lineStart();
                                listener.point(l.a.x, l.a.y);
                            }
                            listener.point(l.b.x, l.b.y);
                            if (!v)
                                listener.lineEnd();
                            clean = false;
                        }
                        else if (v) {
                            listener.lineStart();
                            listener.point(x, y);
                            clean = false;
                        }
                    }
                }
                x_ = x, y_ = y, v_ = v;
            }
            return clip;
        };
        function corner(p, direction) {
            return abs(p[0] - x0) < epsilon ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < epsilon ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
        }
        function compare(a, b) {
            return comparePoints(a.x, b.x);
        }
        function comparePoints(a, b) {
            var ca = corner(a, 1), cb = corner(b, 1);
            return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
        }
    }
    function d3_geo_conic(projectAt) {
        var phi0 = 0, phi1 = pipipi / 3, m = d3_geo_projectionMutator(projectAt), p = m(phi0, phi1);
        p.parallels = function (_) {
            if (!arguments.length)
                return [phi0 / pipipi * 180, phi1 / pipipi * 180];
            return m(phi0 = _[0] * pipipi / 180, phi1 = _[1] * pipipi / 180);
        };
        return p;
    }
    function d3_geo_conicEqualArea(phi0, phi1) {
        var sinphi0 = Math.sin(phi0), n = (sinphi0 + Math.sin(phi1)) / 2, C = 1 + sinphi0 * (2 * n - sinphi0), rho0 = Math.sqrt(C) / n;
        function forward(lambda, phi) {
            var rho = Math.sqrt(C - 2 * n * Math.sin(phi)) / n;
            return [rho * Math.sin(lambda *= n), rho0 - rho * Math.cos(lambda)];
        }
        forward.invert = function (x, y) {
            var rho0_y = rho0 - y;
            return [Math.atan2(x, rho0_y) / n, d3_asin((C - (x * x + rho0_y * rho0_y) * n * n) / (2 * n))];
        };
        return forward;
    }
    (d3.geo.conicEqualArea = function () {
        return d3_geo_conic(d3_geo_conicEqualArea);
    }).raw = d3_geo_conicEqualArea;
    d3.geo.albers = function () {
        return d3.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070);
    };
    d3.geo.albersUsa = function () {
        var lower48 = d3.geo.albers();
        var alaska = d3.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]);
        var hawaii = d3.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]);
        var point, pointStream = {
            point: function (x, y) {
                point = [x, y];
            }
        }, lower48Point, alaskaPoint, hawaiiPoint;
        function albersUsa(coordinates) {
            var x = coordinates[0], y = coordinates[1];
            point = null;
            (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
            return point;
        }
        albersUsa.invert = function (coordinates) {
            var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
            return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
        };
        albersUsa.stream = function (stream) {
            var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
            return {
                point: function (x, y) {
                    lower48Stream.point(x, y);
                    alaskaStream.point(x, y);
                    hawaiiStream.point(x, y);
                },
                sphere: function () {
                    lower48Stream.sphere();
                    alaskaStream.sphere();
                    hawaiiStream.sphere();
                },
                lineStart: function () {
                    lower48Stream.lineStart();
                    alaskaStream.lineStart();
                    hawaiiStream.lineStart();
                },
                lineEnd: function () {
                    lower48Stream.lineEnd();
                    alaskaStream.lineEnd();
                    hawaiiStream.lineEnd();
                },
                polygonStart: function () {
                    lower48Stream.polygonStart();
                    alaskaStream.polygonStart();
                    hawaiiStream.polygonStart();
                },
                polygonEnd: function () {
                    lower48Stream.polygonEnd();
                    alaskaStream.polygonEnd();
                    hawaiiStream.polygonEnd();
                }
            };
        };
        albersUsa.precision = function (_) {
            if (!arguments.length)
                return lower48.precision();
            lower48.precision(_);
            alaska.precision(_);
            hawaii.precision(_);
            return albersUsa;
        };
        albersUsa.scale = function (_) {
            if (!arguments.length)
                return lower48.scale();
            lower48.scale(_);
            alaska.scale(_ * .35);
            hawaii.scale(_);
            return albersUsa.translate(lower48.translate());
        };
        albersUsa.translate = function (_) {
            if (!arguments.length)
                return lower48.translate();
            var k = lower48.scale(), x = +_[0], y = +_[1];
            lower48Point = lower48.translate(_).clipExtent([[x - .455 * k, y - .238 * k], [x + .455 * k, y + .238 * k]]).stream(pointStream).point;
            alaskaPoint = alaska.translate([x - .307 * k, y + .201 * k]).clipExtent([[x - .425 * k + epsilon, y + .12 * k + epsilon], [x - .214 * k - epsilon, y + .234 * k - epsilon]]).stream(pointStream).point;
            hawaiiPoint = hawaii.translate([x - .205 * k, y + .212 * k]).clipExtent([[x - .214 * k + epsilon, y + .166 * k + epsilon], [x - .115 * k - epsilon, y + .234 * k - epsilon]]).stream(pointStream).point;
            return albersUsa;
        };
        return albersUsa.scale(1070);
    };
    var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
        point: d3_noop,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: function () {
            d3_geo_pathAreaPolygon = 0;
            d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
        },
        polygonEnd: function () {
            d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
            d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
        }
    };
    function d3_geo_pathAreaRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathArea.point = function (x, y) {
            d3_geo_pathArea.point = nextPoint;
            x00 = x0 = x, y00 = y0 = y;
        };
        function nextPoint(x, y) {
            d3_geo_pathAreaPolygon += y0 * x - x0 * y;
            x0 = x, y0 = y;
        }
        d3_geo_pathArea.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
    var d3_geo_pathBounds = {
        point: d3_geo_pathBoundsPoint,
        lineStart: d3_noop,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_pathBoundsPoint(x, y) {
        if (x < d3_geo_pathBoundsX0)
            d3_geo_pathBoundsX0 = x;
        if (x > d3_geo_pathBoundsX1)
            d3_geo_pathBoundsX1 = x;
        if (y < d3_geo_pathBoundsY0)
            d3_geo_pathBoundsY0 = y;
        if (y > d3_geo_pathBoundsY1)
            d3_geo_pathBoundsY1 = y;
    }
    function d3_geo_pathBuffer() {
        var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointCircle = d3_geo_pathBufferCircle(_);
                return stream;
            },
            result: function () {
                if (buffer.length) {
                    var result = buffer.join("");
                    buffer = [];
                    return result;
                }
            }
        };
        function point(x, y) {
            buffer.push("M", x, ",", y, pointCircle);
        }
        function pointLineStart(x, y) {
            buffer.push("M", x, ",", y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            buffer.push("L", x, ",", y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            buffer.push("Z");
        }
        return stream;
    }
    function d3_geo_pathBufferCircle(radius) {
        return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
    }
    var d3_geo_pathCentroid = {
        point: d3_geo_pathCentroidPoint,
        lineStart: d3_geo_pathCentroidLineStart,
        lineEnd: d3_geo_pathCentroidLineEnd,
        polygonStart: function () {
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
        },
        polygonEnd: function () {
            d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
            d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
            d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
        }
    };
    function d3_geo_pathCentroidPoint(x, y) {
        d3_geo_centroidX0 += x;
        d3_geo_centroidY0 += y;
        ++d3_geo_centroidZ0;
    }
    function d3_geo_pathCentroidLineStart() {
        var x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
    }
    function d3_geo_pathCentroidLineEnd() {
        d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
    }
    function d3_geo_pathCentroidRingStart() {
        var x00, y00, x0, y0;
        d3_geo_pathCentroid.point = function (x, y) {
            d3_geo_pathCentroid.point = nextPoint;
            d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
        };
        function nextPoint(x, y) {
            var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
            d3_geo_centroidX1 += z * (x0 + x) / 2;
            d3_geo_centroidY1 += z * (y0 + y) / 2;
            d3_geo_centroidZ1 += z;
            z = y0 * x - x0 * y;
            d3_geo_centroidX2 += z * (x0 + x);
            d3_geo_centroidY2 += z * (y0 + y);
            d3_geo_centroidZ2 += z * 3;
            d3_geo_pathCentroidPoint(x0 = x, y0 = y);
        }
        d3_geo_pathCentroid.lineEnd = function () {
            nextPoint(x00, y00);
        };
    }
    function d3_geo_pathContext(context) {
        var pointRadius = 4.5;
        var stream = {
            point: point,
            lineStart: function () {
                stream.point = pointLineStart;
            },
            lineEnd: lineEnd,
            polygonStart: function () {
                stream.lineEnd = lineEndPolygon;
            },
            polygonEnd: function () {
                stream.lineEnd = lineEnd;
                stream.point = point;
            },
            pointRadius: function (_) {
                pointRadius = _;
                return stream;
            },
            result: d3_noop
        };
        function point(x, y) {
            context.moveTo(x + pointRadius, y);
            context.arc(x, y, pointRadius, 0, tau);
        }
        function pointLineStart(x, y) {
            context.moveTo(x, y);
            stream.point = pointLine;
        }
        function pointLine(x, y) {
            context.lineTo(x, y);
        }
        function lineEnd() {
            stream.point = point;
        }
        function lineEndPolygon() {
            context.closePath();
        }
        return stream;
    }
    function d3_geo_resample(project) {
        var delta2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
        function resample(stream) {
            return (maxDepth ? resampleRecursive : resampleNone)(stream);
        }
        function resampleNone(stream) {
            return d3_geo_transformPoint(stream, function (x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            });
        }
        function resampleRecursive(stream) {
            var lambda00, phi00, x00, y00, a00, b00, c00, lambda0, x0, y0, a0, b0, c0;
            var resample = {
                point: point,
                lineStart: lineStart,
                lineEnd: lineEnd,
                polygonStart: function () {
                    stream.polygonStart();
                    resample.lineStart = ringStart;
                },
                polygonEnd: function () {
                    stream.polygonEnd();
                    resample.lineStart = lineStart;
                }
            };
            function point(x, y) {
                x = project(x, y);
                stream.point(x[0], x[1]);
            }
            function lineStart() {
                x0 = NaN;
                resample.point = linePoint;
                stream.lineStart();
            }
            function linePoint(lambda, phi) {
                var c = d3_geo_cartesian([lambda, phi]), p = project(lambda, phi);
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
                stream.point(x0, y0);
            }
            function lineEnd() {
                resample.point = point;
                stream.lineEnd();
            }
            function ringStart() {
                lineStart();
                resample.point = ringPoint;
                resample.lineEnd = ringEnd;
            }
            function ringPoint(lambda, phi) {
                linePoint(lambda00 = lambda, phi00 = phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
                resample.point = linePoint;
            }
            function ringEnd() {
                resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
                resample.lineEnd = lineEnd;
                lineEnd();
            }
            return resample;
        }
        function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
            var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
            if (d2 > 4 * delta2 && depth--) {
                var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), phi2 = Math.asin(c /= m), lambda2 = abs(abs(c) - 1) < epsilon || abs(lambda0 - lambda1) < epsilon ? (lambda0 + lambda1) / 2 : Math.atan2(b, a), p = project(lambda2, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
                if (dz * dz / d2 > delta2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
                    resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
                    stream.point(x2, y2);
                    resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
                }
            }
        }
        resample.precision = function (_) {
            if (!arguments.length)
                return Math.sqrt(delta2);
            maxDepth = (delta2 = _ * _) > 0 && 16;
            return resample;
        };
        return resample;
    }
    d3.geo.path = function () {
        var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
        function path(object) {
            if (object) {
                if (typeof pointRadius === "function")
                    contextStream.pointRadius(+pointRadius.apply(this, arguments));
                if (!cacheStream || !cacheStream.valid)
                    cacheStream = projectStream(contextStream);
                d3.geo.stream(object, cacheStream);
            }
            return contextStream.result();
        }
        path.area = function (object) {
            d3_geo_pathAreaSum = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathArea));
            return d3_geo_pathAreaSum;
        };
        path.centroid = function (object) {
            d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
            d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
            return d3_geo_centroidZ2 ? [d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2] : d3_geo_centroidZ1 ? [d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1] : d3_geo_centroidZ0 ? [d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0] : [NaN, NaN];
        };
        path.bounds = function (object) {
            d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
            d3.geo.stream(object, projectStream(d3_geo_pathBounds));
            return [[d3_geo_pathBoundsX0, d3_geo_pathBoundsY0], [d3_geo_pathBoundsX1, d3_geo_pathBoundsY1]];
        };
        path.projection = function (_) {
            if (!arguments.length)
                return projection;
            projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
            return reset();
        };
        path.context = function (_) {
            if (!arguments.length)
                return context;
            contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
            if (typeof pointRadius !== "function")
                contextStream.pointRadius(pointRadius);
            return reset();
        };
        path.pointRadius = function (_) {
            if (!arguments.length)
                return pointRadius;
            pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
            return path;
        };
        function reset() {
            cacheStream = null;
            return path;
        }
        return path.projection(d3.geo.albersUsa()).context(null);
    };
    function d3_geo_pathProjectStream(project) {
        var resample = d3_geo_resample(function (x, y) {
            return project([x * d3_degrees, y * d3_degrees]);
        });
        return function (stream) {
            return d3_geo_projectionRadians(resample(stream));
        };
    }
    d3.geo.transform = function (methods) {
        return {
            stream: function (stream) {
                var transform = new d3_geo_transform(stream);
                for (var k in methods)
                    transform[k] = methods[k];
                return transform;
            }
        };
    };
    function d3_geo_transform(stream) {
        this.stream = stream;
    }
    d3_geo_transform.prototype = {
        point: function (x, y) {
            this.stream.point(x, y);
        },
        sphere: function () {
            this.stream.sphere();
        },
        lineStart: function () {
            this.stream.lineStart();
        },
        lineEnd: function () {
            this.stream.lineEnd();
        },
        polygonStart: function () {
            this.stream.polygonStart();
        },
        polygonEnd: function () {
            this.stream.polygonEnd();
        }
    };
    function d3_geo_transformPoint(stream, point) {
        return {
            point: point,
            sphere: function () {
                stream.sphere();
            },
            lineStart: function () {
                stream.lineStart();
            },
            lineEnd: function () {
                stream.lineEnd();
            },
            polygonStart: function () {
                stream.polygonStart();
            },
            polygonEnd: function () {
                stream.polygonEnd();
            }
        };
    }
    d3.geo.projection = d3_geo_projection;
    d3.geo.projectionMutator = d3_geo_projectionMutator;
    function d3_geo_projection(project) {
        return d3_geo_projectionMutator(function () {
            return project;
        })();
    }
    function d3_geo_projectionMutator(projectAt) {
        var project, rotate, projectRotate, projectResample = d3_geo_resample(function (x, y) {
            x = project(x, y);
            return [x[0] * k + deltax, deltay - x[1] * k];
        }), k = 150, x = 480, y = 250, lambda = 0, phi = 0, deltalambda = 0, deltaphi = 0, deltagamma = 0, deltax, deltay, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
        function projection(point) {
            point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
            return [point[0] * k + deltax, deltay - point[1] * k];
        }
        function invert(point) {
            point = projectRotate.invert((point[0] - deltax) / k, (deltay - point[1]) / k);
            return point && [point[0] * d3_degrees, point[1] * d3_degrees];
        }
        projection.stream = function (output) {
            if (stream)
                stream.valid = false;
            stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
            stream.valid = true;
            return stream;
        };
        projection.clipAngle = function (_) {
            if (!arguments.length)
                return clipAngle;
            preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
            return invalidate();
        };
        projection.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent;
            clipExtent = _;
            postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
            return invalidate();
        };
        projection.scale = function (_) {
            if (!arguments.length)
                return k;
            k = +_;
            return reset();
        };
        projection.translate = function (_) {
            if (!arguments.length)
                return [x, y];
            x = +_[0];
            y = +_[1];
            return reset();
        };
        projection.center = function (_) {
            if (!arguments.length)
                return [lambda * d3_degrees, phi * d3_degrees];
            lambda = _[0] % 360 * d3_radians;
            phi = _[1] % 360 * d3_radians;
            return reset();
        };
        projection.rotate = function (_) {
            if (!arguments.length)
                return [deltalambda * d3_degrees, deltaphi * d3_degrees, deltagamma * d3_degrees];
            deltalambda = _[0] % 360 * d3_radians;
            deltaphi = _[1] % 360 * d3_radians;
            deltagamma = _.length > 2 ? _[2] % 360 * d3_radians : 0;
            return reset();
        };
        d3.rebind(projection, projectResample, "precision");
        function reset() {
            projectRotate = d3_geo_compose(rotate = d3_geo_rotation(deltalambda, deltaphi, deltagamma), project);
            var center = project(lambda, phi);
            deltax = x - center[0] * k;
            deltay = y + center[1] * k;
            return invalidate();
        }
        function invalidate() {
            if (stream)
                stream.valid = false, stream = null;
            return projection;
        }
        return function () {
            project = projectAt.apply(this, arguments);
            projection.invert = project.invert && invert;
            return reset();
        };
    }
    function d3_geo_projectionRadians(stream) {
        return d3_geo_transformPoint(stream, function (x, y) {
            stream.point(x * d3_radians, y * d3_radians);
        });
    }
    function d3_geo_equirectangular(lambda, phi) {
        return [lambda, phi];
    }
    (d3.geo.equirectangular = function () {
        return d3_geo_projection(d3_geo_equirectangular);
    }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
    d3.geo.rotation = function (rotate) {
        rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
        function forward(coordinates) {
            coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        }
        forward.invert = function (coordinates) {
            coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
            return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
        };
        return forward;
    };
    function d3_geo_identityRotation(lambda, phi) {
        return [lambda > pipipi ? lambda - tau : lambda < -pipipi ? lambda + tau : lambda, phi];
    }
    d3_geo_identityRotation.invert = d3_geo_equirectangular;
    function d3_geo_rotation(deltalambda, deltaphi, deltagamma) {
        return deltalambda ? deltaphi || deltagamma ? d3_geo_compose(d3_geo_rotationlambda(deltalambda), d3_geo_rotationphigamma(deltaphi, deltagamma)) : d3_geo_rotationlambda(deltalambda) : deltaphi || deltagamma ? d3_geo_rotationphigamma(deltaphi, deltagamma) : d3_geo_identityRotation;
    }
    function d3_geo_forwardRotationlambda(deltalambda) {
        return function (lambda, phi) {
            return lambda += deltalambda, [lambda > pipipi ? lambda - tau : lambda < -pipipi ? lambda + tau : lambda, phi];
        };
    }
    function d3_geo_rotationlambda(deltalambda) {
        var rotation = d3_geo_forwardRotationlambda(deltalambda);
        rotation.invert = d3_geo_forwardRotationlambda(-deltalambda);
        return rotation;
    }
    function d3_geo_rotationphigamma(deltaphi, deltagamma) {
        var cosdeltaphi = Math.cos(deltaphi), sindeltaphi = Math.sin(deltaphi), cosdeltagamma = Math.cos(deltagamma), sindeltagamma = Math.sin(deltagamma);
        function rotation(lambda, phi) {
            var cosphi = Math.cos(phi), x = Math.cos(lambda) * cosphi, y = Math.sin(lambda) * cosphi, z = Math.sin(phi), k = z * cosdeltaphi + x * sindeltaphi;
            return [Math.atan2(y * cosdeltagamma - k * sindeltagamma, x * cosdeltaphi - z * sindeltaphi), d3_asin(k * cosdeltagamma + y * sindeltagamma)];
        }
        rotation.invert = function (lambda, phi) {
            var cosphi = Math.cos(phi), x = Math.cos(lambda) * cosphi, y = Math.sin(lambda) * cosphi, z = Math.sin(phi), k = z * cosdeltagamma - y * sindeltagamma;
            return [Math.atan2(y * cosdeltagamma + z * sindeltagamma, x * cosdeltaphi + k * sindeltaphi), d3_asin(k * cosdeltaphi - x * sindeltaphi)];
        };
        return rotation;
    }
    d3.geo.circle = function () {
        var origin = [0, 0], angle, precision = 6, interpolate;
        function circle() {
            var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
            interpolate(null, null, 1, {
                point: function (x, y) {
                    ring.push(x = rotate(x, y));
                    x[0] *= d3_degrees, x[1] *= d3_degrees;
                }
            });
            return {
                type: "Polygon",
                coordinates: [ring]
            };
        }
        circle.origin = function (x) {
            if (!arguments.length)
                return origin;
            origin = x;
            return circle;
        };
        circle.angle = function (x) {
            if (!arguments.length)
                return angle;
            interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
            return circle;
        };
        circle.precision = function (_) {
            if (!arguments.length)
                return precision;
            interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
            return circle;
        };
        return circle.angle(90);
    };
    function d3_geo_circleInterpolate(radius, precision) {
        var cr = Math.cos(radius), sr = Math.sin(radius);
        return function (from, to, direction, listener) {
            var step = direction * precision;
            if (from != null) {
                from = d3_geo_circleAngle(cr, from);
                to = d3_geo_circleAngle(cr, to);
                if (direction > 0 ? from < to : from > to)
                    from += direction * tau;
            }
            else {
                from = radius + direction * tau;
                to = radius - .5 * step;
            }
            for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
                listener.point((point = d3_geo_spherical([cr, -sr * Math.cos(t), -sr * Math.sin(t)]))[0], point[1]);
            }
        };
    }
    function d3_geo_circleAngle(cr, point) {
        var a = d3_geo_cartesian(point);
        a[0] -= cr;
        d3_geo_cartesianNormalize(a);
        var angle = d3_acos(-a[1]);
        return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - epsilon) % (2 * Math.PI);
    }
    d3.geo.distance = function (a, b) {
        var deltalambda = (b[0] - a[0]) * d3_radians, phi0 = a[1] * d3_radians, phi1 = b[1] * d3_radians, sindeltalambda = Math.sin(deltalambda), cosdeltalambda = Math.cos(deltalambda), sinphi0 = Math.sin(phi0), cosphi0 = Math.cos(phi0), sinphi1 = Math.sin(phi1), cosphi1 = Math.cos(phi1), t;
        return Math.atan2(Math.sqrt((t = cosphi1 * sindeltalambda) * t + (t = cosphi0 * sinphi1 - sinphi0 * cosphi1 * cosdeltalambda) * t), sinphi0 * sinphi1 + cosphi0 * cosphi1 * cosdeltalambda);
    };
    d3.geo.graticule = function () {
        var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
        function graticule() {
            return {
                type: "MultiLineString",
                coordinates: lines()
            };
        }
        function lines() {
            return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function (x) {
                return abs(x % DX) > epsilon;
            }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function (y) {
                return abs(y % DY) > epsilon;
            }).map(y));
        }
        graticule.lines = function () {
            return lines().map(function (coordinates) {
                return {
                    type: "LineString",
                    coordinates: coordinates
                };
            });
        };
        graticule.outline = function () {
            return {
                type: "Polygon",
                coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
            };
        };
        graticule.extent = function (_) {
            if (!arguments.length)
                return graticule.minorExtent();
            return graticule.majorExtent(_).minorExtent(_);
        };
        graticule.majorExtent = function (_) {
            if (!arguments.length)
                return [[X0, Y0], [X1, Y1]];
            X0 = +_[0][0], X1 = +_[1][0];
            Y0 = +_[0][1], Y1 = +_[1][1];
            if (X0 > X1)
                _ = X0, X0 = X1, X1 = _;
            if (Y0 > Y1)
                _ = Y0, Y0 = Y1, Y1 = _;
            return graticule.precision(precision);
        };
        graticule.minorExtent = function (_) {
            if (!arguments.length)
                return [[x0, y0], [x1, y1]];
            x0 = +_[0][0], x1 = +_[1][0];
            y0 = +_[0][1], y1 = +_[1][1];
            if (x0 > x1)
                _ = x0, x0 = x1, x1 = _;
            if (y0 > y1)
                _ = y0, y0 = y1, y1 = _;
            return graticule.precision(precision);
        };
        graticule.step = function (_) {
            if (!arguments.length)
                return graticule.minorStep();
            return graticule.majorStep(_).minorStep(_);
        };
        graticule.majorStep = function (_) {
            if (!arguments.length)
                return [DX, DY];
            DX = +_[0], DY = +_[1];
            return graticule;
        };
        graticule.minorStep = function (_) {
            if (!arguments.length)
                return [dx, dy];
            dx = +_[0], dy = +_[1];
            return graticule;
        };
        graticule.precision = function (_) {
            if (!arguments.length)
                return precision;
            precision = +_;
            x = d3_geo_graticuleX(y0, y1, 90);
            y = d3_geo_graticuleY(x0, x1, precision);
            X = d3_geo_graticuleX(Y0, Y1, 90);
            Y = d3_geo_graticuleY(X0, X1, precision);
            return graticule;
        };
        return graticule.majorExtent([[-180, -90 + epsilon], [180, 90 - epsilon]]).minorExtent([[-180, -80 - epsilon], [180, 80 + epsilon]]);
    };
    function d3_geo_graticuleX(y0, y1, dy) {
        var y = d3.range(y0, y1 - epsilon, dy).concat(y1);
        return function (x) {
            return y.map(function (y) {
                return [x, y];
            });
        };
    }
    function d3_geo_graticuleY(x0, x1, dx) {
        var x = d3.range(x0, x1 - epsilon, dx).concat(x1);
        return function (y) {
            return x.map(function (x) {
                return [x, y];
            });
        };
    }
    function d3_source(d) {
        return d.source;
    }
    function d3_target(d) {
        return d.target;
    }
    d3.geo.greatArc = function () {
        var source = d3_source, source_, target = d3_target, target_;
        function greatArc() {
            return {
                type: "LineString",
                coordinates: [source_ || source.apply(this, arguments), target_ || target.apply(this, arguments)]
            };
        }
        greatArc.distance = function () {
            return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
        };
        greatArc.source = function (_) {
            if (!arguments.length)
                return source;
            source = _, source_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.target = function (_) {
            if (!arguments.length)
                return target;
            target = _, target_ = typeof _ === "function" ? null : _;
            return greatArc;
        };
        greatArc.precision = function () {
            return arguments.length ? greatArc : 0;
        };
        return greatArc;
    };
    d3.geo.interpolate = function (source, target) {
        return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
    };
    function d3_geo_interpolate(x0, y0, x1, y1) {
        var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
        var interpolate = d ? function (t) {
            var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
            return [Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees];
        } : function () {
            return [x0 * d3_degrees, y0 * d3_degrees];
        };
        interpolate.distance = d;
        return interpolate;
    }
    d3.geo.length = function (object) {
        d3_geo_lengthSum = 0;
        d3.geo.stream(object, d3_geo_length);
        return d3_geo_lengthSum;
    };
    var d3_geo_lengthSum;
    var d3_geo_length = {
        sphere: d3_noop,
        point: d3_noop,
        lineStart: d3_geo_lengthLineStart,
        lineEnd: d3_noop,
        polygonStart: d3_noop,
        polygonEnd: d3_noop
    };
    function d3_geo_lengthLineStart() {
        var lambda0, sinphi0, cosphi0;
        d3_geo_length.point = function (lambda, phi) {
            lambda0 = lambda * d3_radians, sinphi0 = Math.sin(phi *= d3_radians), cosphi0 = Math.cos(phi);
            d3_geo_length.point = nextPoint;
        };
        d3_geo_length.lineEnd = function () {
            d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
        };
        function nextPoint(lambda, phi) {
            var sinphi = Math.sin(phi *= d3_radians), cosphi = Math.cos(phi), t = abs((lambda *= d3_radians) - lambda0), cosdeltalambda = Math.cos(t);
            d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosphi * Math.sin(t)) * t + (t = cosphi0 * sinphi - sinphi0 * cosphi * cosdeltalambda) * t), sinphi0 * sinphi + cosphi0 * cosphi * cosdeltalambda);
            lambda0 = lambda, sinphi0 = sinphi, cosphi0 = cosphi;
        }
    }
    function d3_geo_azimuthal(scale, angle) {
        function azimuthal(lambda, phi) {
            var coslambda = Math.cos(lambda), cosphi = Math.cos(phi), k = scale(coslambda * cosphi);
            return [k * cosphi * Math.sin(lambda), k * Math.sin(phi)];
        }
        azimuthal.invert = function (x, y) {
            var rho = Math.sqrt(x * x + y * y), c = angle(rho), sinc = Math.sin(c), cosc = Math.cos(c);
            return [Math.atan2(x * sinc, rho * cosc), Math.asin(rho && y * sinc / rho)];
        };
        return azimuthal;
    }
    var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function (coslambdacosphi) {
        return Math.sqrt(2 / (1 + coslambdacosphi));
    }, function (rho) {
        return 2 * Math.asin(rho / 2);
    });
    (d3.geo.azimuthalEqualArea = function () {
        return d3_geo_projection(d3_geo_azimuthalEqualArea);
    }).raw = d3_geo_azimuthalEqualArea;
    var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function (coslambdacosphi) {
        var c = Math.acos(coslambdacosphi);
        return c && c / Math.sin(c);
    }, d3_identity);
    (d3.geo.azimuthalEquidistant = function () {
        return d3_geo_projection(d3_geo_azimuthalEquidistant);
    }).raw = d3_geo_azimuthalEquidistant;
    function d3_geo_conicConformal(phi0, phi1) {
        var cosphi0 = Math.cos(phi0), t = function (phi) {
            return Math.tan(pipipi / 4 + phi / 2);
        }, n = phi0 === phi1 ? Math.sin(phi0) : Math.log(cosphi0 / Math.cos(phi1)) / Math.log(t(phi1) / t(phi0)), F = cosphi0 * Math.pow(t(phi0), n) / n;
        if (!n)
            return d3_geo_mercator;
        function forward(lambda, phi) {
            if (F > 0) {
                if (phi < -halfpipipi + epsilon)
                    phi = -halfpipipi + epsilon;
            }
            else {
                if (phi > halfpipipi - epsilon)
                    phi = halfpipipi - epsilon;
            }
            var rho = F / Math.pow(t(phi), n);
            return [rho * Math.sin(n * lambda), F - rho * Math.cos(n * lambda)];
        }
        forward.invert = function (x, y) {
            var rho0_y = F - y, rho = d3_sgn(n) * Math.sqrt(x * x + rho0_y * rho0_y);
            return [Math.atan2(x, rho0_y) / n, 2 * Math.atan(Math.pow(F / rho, 1 / n)) - halfpipipi];
        };
        return forward;
    }
    (d3.geo.conicConformal = function () {
        return d3_geo_conic(d3_geo_conicConformal);
    }).raw = d3_geo_conicConformal;
    function d3_geo_conicEquidistant(phi0, phi1) {
        var cosphi0 = Math.cos(phi0), n = phi0 === phi1 ? Math.sin(phi0) : (cosphi0 - Math.cos(phi1)) / (phi1 - phi0), G = cosphi0 / n + phi0;
        if (abs(n) < epsilon)
            return d3_geo_equirectangular;
        function forward(lambda, phi) {
            var rho = G - phi;
            return [rho * Math.sin(n * lambda), G - rho * Math.cos(n * lambda)];
        }
        forward.invert = function (x, y) {
            var rho0_y = G - y;
            return [Math.atan2(x, rho0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + rho0_y * rho0_y)];
        };
        return forward;
    }
    (d3.geo.conicEquidistant = function () {
        return d3_geo_conic(d3_geo_conicEquidistant);
    }).raw = d3_geo_conicEquidistant;
    var d3_geo_gnomonic = d3_geo_azimuthal(function (coslambdacosphi) {
        return 1 / coslambdacosphi;
    }, Math.atan);
    (d3.geo.gnomonic = function () {
        return d3_geo_projection(d3_geo_gnomonic);
    }).raw = d3_geo_gnomonic;
    function d3_geo_mercator(lambda, phi) {
        return [lambda, Math.log(Math.tan(pipipi / 4 + phi / 2))];
    }
    d3_geo_mercator.invert = function (x, y) {
        return [x, 2 * Math.atan(Math.exp(y)) - halfpipipi];
    };
    function d3_geo_mercatorProjection(project) {
        var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
        m.scale = function () {
            var v = scale.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.translate = function () {
            var v = translate.apply(m, arguments);
            return v === m ? clipAuto ? m.clipExtent(null) : m : v;
        };
        m.clipExtent = function (_) {
            var v = clipExtent.apply(m, arguments);
            if (v === m) {
                if (clipAuto = _ == null) {
                    var k = pipipi * scale(), t = translate();
                    clipExtent([[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]]);
                }
            }
            else if (clipAuto) {
                v = null;
            }
            return v;
        };
        return m.clipExtent(null);
    }
    (d3.geo.mercator = function () {
        return d3_geo_mercatorProjection(d3_geo_mercator);
    }).raw = d3_geo_mercator;
    var d3_geo_orthographic = d3_geo_azimuthal(function () {
        return 1;
    }, Math.asin);
    (d3.geo.orthographic = function () {
        return d3_geo_projection(d3_geo_orthographic);
    }).raw = d3_geo_orthographic;
    var d3_geo_stereographic = d3_geo_azimuthal(function (coslambdacosphi) {
        return 1 / (1 + coslambdacosphi);
    }, function (rho) {
        return 2 * Math.atan(rho);
    });
    (d3.geo.stereographic = function () {
        return d3_geo_projection(d3_geo_stereographic);
    }).raw = d3_geo_stereographic;
    function d3_geo_transverseMercator(lambda, phi) {
        return [Math.log(Math.tan(pipipi / 4 + phi / 2)), -lambda];
    }
    d3_geo_transverseMercator.invert = function (x, y) {
        return [-y, 2 * Math.atan(Math.exp(x)) - halfpipipi];
    };
    (d3.geo.transverseMercator = function () {
        var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
        projection.center = function (_) {
            return _ ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
        };
        projection.rotate = function (_) {
            return _ ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(),
                [_[0], _[1], _[2] - 90]);
        };
        return rotate([0, 0, 90]);
    }).raw = d3_geo_transverseMercator;
    d3.geom = {};
    function d3_geom_pointX(d) {
        return d[0];
    }
    function d3_geom_pointY(d) {
        return d[1];
    }
    d3.geom.hull = function (vertices) {
        var x = d3_geom_pointX, y = d3_geom_pointY;
        if (arguments.length)
            return hull(vertices);
        function hull(data) {
            if (data.length < 3)
                return [];
            var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
            for (i = 0; i < n; i++) {
                points.push([+fx.call(this, data[i], i), +fy.call(this, data[i], i), i]);
            }
            points.sort(d3_geom_hullOrder);
            for (i = 0; i < n; i++)
                flippedPoints.push([points[i][0], -points[i][1]]);
            var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
            var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
            for (i = upper.length - 1; i >= 0; --i)
                polygon.push(data[points[upper[i]][2]]);
            for (i = +skipLeft; i < lower.length - skipRight; ++i)
                polygon.push(data[points[lower[i]][2]]);
            return polygon;
        }
        hull.x = function (_) {
            return arguments.length ? (x = _, hull) : x;
        };
        hull.y = function (_) {
            return arguments.length ? (y = _, hull) : y;
        };
        return hull;
    };
    function d3_geom_hullUpper(points) {
        var n = points.length, hull = [0, 1], hs = 2;
        for (var i = 2; i < n; i++) {
            while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0)
                --hs;
            hull[hs++] = i;
        }
        return hull.slice(0, hs);
    }
    function d3_geom_hullOrder(a, b) {
        return a[0] - b[0] || a[1] - b[1];
    }
    d3.geom.polygon = function (coordinates) {
        d3_subclass(coordinates, d3_geom_polygonPrototype);
        return coordinates;
    };
    var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
    d3_geom_polygonPrototype.area = function () {
        var i = -1, n = this.length, a, b = this[n - 1], area = 0;
        while (++i < n) {
            a = b;
            b = this[i];
            area += a[1] * b[0] - a[0] * b[1];
        }
        return area * .5;
    };
    d3_geom_polygonPrototype.centroid = function (k) {
        var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
        if (!arguments.length)
            k = -1 / (6 * this.area());
        while (++i < n) {
            a = b;
            b = this[i];
            c = a[0] * b[1] - b[0] * a[1];
            x += (a[0] + b[0]) * c;
            y += (a[1] + b[1]) * c;
        }
        return [x * k, y * k];
    };
    d3_geom_polygonPrototype.clip = function (subject) {
        var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
        while (++i < n) {
            input = subject.slice();
            subject.length = 0;
            b = this[i];
            c = input[(m = input.length - closed) - 1];
            j = -1;
            while (++j < m) {
                d = input[j];
                if (d3_geom_polygonInside(d, a, b)) {
                    if (!d3_geom_polygonInside(c, a, b)) {
                        subject.push(d3_geom_polygonIntersect(c, d, a, b));
                    }
                    subject.push(d);
                }
                else if (d3_geom_polygonInside(c, a, b)) {
                    subject.push(d3_geom_polygonIntersect(c, d, a, b));
                }
                c = d;
            }
            if (closed)
                subject.push(subject[0]);
            a = b;
        }
        return subject;
    };
    function d3_geom_polygonInside(p, a, b) {
        return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
    }
    function d3_geom_polygonIntersect(c, d, a, b) {
        var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
        return [x1 + ua * x21, y1 + ua * y21];
    }
    function d3_geom_polygonClosed(coordinates) {
        var a = coordinates[0], b = coordinates[coordinates.length - 1];
        return !(a[0] - b[0] || a[1] - b[1]);
    }
    var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
    function d3_geom_voronoiBeach() {
        d3_geom_voronoiRedBlackNode(this);
        this.edge = this.site = this.circle = null;
    }
    function d3_geom_voronoiCreateBeach(site) {
        var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
        beach.site = site;
        return beach;
    }
    function d3_geom_voronoiDetachBeach(beach) {
        d3_geom_voronoiDetachCircle(beach);
        d3_geom_voronoiBeaches.remove(beach);
        d3_geom_voronoiBeachPool.push(beach);
        d3_geom_voronoiRedBlackNode(beach);
    }
    function d3_geom_voronoiRemoveBeach(beach) {
        var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
            x: x,
            y: y
        }, previous = beach.P, next = beach.N, disappearing = [beach];
        d3_geom_voronoiDetachBeach(beach);
        var lArc = previous;
        while (lArc.circle && abs(x - lArc.circle.x) < epsilon && abs(y - lArc.circle.cy) < epsilon) {
            previous = lArc.P;
            disappearing.unshift(lArc);
            d3_geom_voronoiDetachBeach(lArc);
            lArc = previous;
        }
        disappearing.unshift(lArc);
        d3_geom_voronoiDetachCircle(lArc);
        var rArc = next;
        while (rArc.circle && abs(x - rArc.circle.x) < epsilon && abs(y - rArc.circle.cy) < epsilon) {
            next = rArc.N;
            disappearing.push(rArc);
            d3_geom_voronoiDetachBeach(rArc);
            rArc = next;
        }
        disappearing.push(rArc);
        d3_geom_voronoiDetachCircle(rArc);
        var nArcs = disappearing.length, iArc;
        for (iArc = 1; iArc < nArcs; ++iArc) {
            rArc = disappearing[iArc];
            lArc = disappearing[iArc - 1];
            d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
        }
        lArc = disappearing[0];
        rArc = disappearing[nArcs - 1];
        rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiAddBeach(site) {
        var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
        while (node) {
            dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
            if (dxl > epsilon)
                node = node.L;
            else {
                dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
                if (dxr > epsilon) {
                    if (!node.R) {
                        lArc = node;
                        break;
                    }
                    node = node.R;
                }
                else {
                    if (dxl > -epsilon) {
                        lArc = node.P;
                        rArc = node;
                    }
                    else if (dxr > -epsilon) {
                        lArc = node;
                        rArc = node.N;
                    }
                    else {
                        lArc = rArc = node;
                    }
                    break;
                }
            }
        }
        var newArc = d3_geom_voronoiCreateBeach(site);
        d3_geom_voronoiBeaches.insert(lArc, newArc);
        if (!lArc && !rArc)
            return;
        if (lArc === rArc) {
            d3_geom_voronoiDetachCircle(lArc);
            rArc = d3_geom_voronoiCreateBeach(lArc.site);
            d3_geom_voronoiBeaches.insert(newArc, rArc);
            newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            d3_geom_voronoiAttachCircle(lArc);
            d3_geom_voronoiAttachCircle(rArc);
            return;
        }
        if (!rArc) {
            newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
            return;
        }
        d3_geom_voronoiDetachCircle(lArc);
        d3_geom_voronoiDetachCircle(rArc);
        var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
            x: (cy * hb - by * hc) / d + ax,
            y: (bx * hc - cx * hb) / d + ay
        };
        d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
        newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
        rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
        d3_geom_voronoiAttachCircle(lArc);
        d3_geom_voronoiAttachCircle(rArc);
    }
    function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
        var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
        if (!pby2)
            return rfocx;
        var lArc = arc.P;
        if (!lArc)
            return -Infinity;
        site = lArc.site;
        var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
        if (!plby2)
            return lfocx;
        var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
        if (aby2)
            return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
        return (rfocx + lfocx) / 2;
    }
    function d3_geom_voronoiRightBreakPoint(arc, directrix) {
        var rArc = arc.N;
        if (rArc)
            return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
        var site = arc.site;
        return site.y === directrix ? site.x : Infinity;
    }
    function d3_geom_voronoiCell(site) {
        this.site = site;
        this.edges = [];
    }
    d3_geom_voronoiCell.prototype.prepare = function () {
        var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
        while (iHalfEdge--) {
            edge = halfEdges[iHalfEdge].edge;
            if (!edge.b || !edge.a)
                halfEdges.splice(iHalfEdge, 1);
        }
        halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
        return halfEdges.length;
    };
    function d3_geom_voronoiCloseCells(extent) {
        var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
        while (iCell--) {
            cell = cells[iCell];
            if (!cell || !cell.prepare())
                continue;
            halfEdges = cell.edges;
            nHalfEdges = halfEdges.length;
            iHalfEdge = 0;
            while (iHalfEdge < nHalfEdges) {
                end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
                start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
                if (abs(x3 - x2) > epsilon || abs(y3 - y2) > epsilon) {
                    halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < epsilon && y1 - y3 > epsilon ? {
                        x: x0,
                        y: abs(x2 - x0) < epsilon ? y2 : y1
                    } : abs(y3 - y1) < epsilon && x1 - x3 > epsilon ? {
                        x: abs(y2 - y1) < epsilon ? x2 : x1,
                        y: y1
                    } : abs(x3 - x1) < epsilon && y3 - y0 > epsilon ? {
                        x: x1,
                        y: abs(x2 - x1) < epsilon ? y2 : y0
                    } : abs(y3 - y0) < epsilon && x3 - x0 > epsilon ? {
                        x: abs(y2 - y0) < epsilon ? x2 : x0,
                        y: y0
                    } : null), cell.site, null));
                    ++nHalfEdges;
                }
            }
        }
    }
    function d3_geom_voronoiHalfEdgeOrder(a, b) {
        return b.angle - a.angle;
    }
    function d3_geom_voronoiCircle() {
        d3_geom_voronoiRedBlackNode(this);
        this.x = this.y = this.arc = this.site = this.cy = null;
    }
    function d3_geom_voronoiAttachCircle(arc) {
        var lArc = arc.P, rArc = arc.N;
        if (!lArc || !rArc)
            return;
        var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
        if (lSite === rSite)
            return;
        var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
        var d = 2 * (ax * cy - ay * cx);
        if (d >= -epsilon2)
            return;
        var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
        var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
        circle.arc = arc;
        circle.site = cSite;
        circle.x = x + bx;
        circle.y = cy + Math.sqrt(x * x + y * y);
        circle.cy = cy;
        arc.circle = circle;
        var before = null, node = d3_geom_voronoiCircles._;
        while (node) {
            if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
                if (node.L)
                    node = node.L;
                else {
                    before = node.P;
                    break;
                }
            }
            else {
                if (node.R)
                    node = node.R;
                else {
                    before = node;
                    break;
                }
            }
        }
        d3_geom_voronoiCircles.insert(before, circle);
        if (!before)
            d3_geom_voronoiFirstCircle = circle;
    }
    function d3_geom_voronoiDetachCircle(arc) {
        var circle = arc.circle;
        if (circle) {
            if (!circle.P)
                d3_geom_voronoiFirstCircle = circle.N;
            d3_geom_voronoiCircles.remove(circle);
            d3_geom_voronoiCirclePool.push(circle);
            d3_geom_voronoiRedBlackNode(circle);
            arc.circle = null;
        }
    }
    function d3_geom_voronoiClipEdges(extent) {
        var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
        while (i--) {
            e = edges[i];
            if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < epsilon && abs(e.a.y - e.b.y) < epsilon) {
                e.a = e.b = null;
                edges.splice(i, 1);
            }
        }
    }
    function d3_geom_voronoiConnectEdge(edge, extent) {
        var vb = edge.b;
        if (vb)
            return true;
        var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
        if (ry === ly) {
            if (fx < x0 || fx >= x1)
                return;
            if (lx > rx) {
                if (!va)
                    va = {
                        x: fx,
                        y: y0
                    };
                else if (va.y >= y1)
                    return;
                vb = {
                    x: fx,
                    y: y1
                };
            }
            else {
                if (!va)
                    va = {
                        x: fx,
                        y: y1
                    };
                else if (va.y < y0)
                    return;
                vb = {
                    x: fx,
                    y: y0
                };
            }
        }
        else {
            fm = (lx - rx) / (ry - ly);
            fb = fy - fm * fx;
            if (fm < -1 || fm > 1) {
                if (lx > rx) {
                    if (!va)
                        va = {
                            x: (y0 - fb) / fm,
                            y: y0
                        };
                    else if (va.y >= y1)
                        return;
                    vb = {
                        x: (y1 - fb) / fm,
                        y: y1
                    };
                }
                else {
                    if (!va)
                        va = {
                            x: (y1 - fb) / fm,
                            y: y1
                        };
                    else if (va.y < y0)
                        return;
                    vb = {
                        x: (y0 - fb) / fm,
                        y: y0
                    };
                }
            }
            else {
                if (ly < ry) {
                    if (!va)
                        va = {
                            x: x0,
                            y: fm * x0 + fb
                        };
                    else if (va.x >= x1)
                        return;
                    vb = {
                        x: x1,
                        y: fm * x1 + fb
                    };
                }
                else {
                    if (!va)
                        va = {
                            x: x1,
                            y: fm * x1 + fb
                        };
                    else if (va.x < x0)
                        return;
                    vb = {
                        x: x0,
                        y: fm * x0 + fb
                    };
                }
            }
        }
        edge.a = va;
        edge.b = vb;
        return true;
    }
    function d3_geom_voronoiEdge(lSite, rSite) {
        this.l = lSite;
        this.r = rSite;
        this.a = this.b = null;
    }
    function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, rSite);
        d3_geom_voronoiEdges.push(edge);
        if (va)
            d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
        if (vb)
            d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
        d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
        d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
        return edge;
    }
    function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
        var edge = new d3_geom_voronoiEdge(lSite, null);
        edge.a = va;
        edge.b = vb;
        d3_geom_voronoiEdges.push(edge);
        return edge;
    }
    function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
        if (!edge.a && !edge.b) {
            edge.a = vertex;
            edge.l = lSite;
            edge.r = rSite;
        }
        else if (edge.l === rSite) {
            edge.b = vertex;
        }
        else {
            edge.a = vertex;
        }
    }
    function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
        var va = edge.a, vb = edge.b;
        this.edge = edge;
        this.site = lSite;
        this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
    }
    d3_geom_voronoiHalfEdge.prototype = {
        start: function () {
            return this.edge.l === this.site ? this.edge.a : this.edge.b;
        },
        end: function () {
            return this.edge.l === this.site ? this.edge.b : this.edge.a;
        }
    };
    function d3_geom_voronoiRedBlackTree() {
        this._ = null;
    }
    function d3_geom_voronoiRedBlackNode(node) {
        node.U = node.C = node.L = node.R = node.P = node.N = null;
    }
    d3_geom_voronoiRedBlackTree.prototype = {
        insert: function (after, node) {
            var parent, grandpa, uncle;
            if (after) {
                node.P = after;
                node.N = after.N;
                if (after.N)
                    after.N.P = node;
                after.N = node;
                if (after.R) {
                    after = after.R;
                    while (after.L)
                        after = after.L;
                    after.L = node;
                }
                else {
                    after.R = node;
                }
                parent = after;
            }
            else if (this._) {
                after = d3_geom_voronoiRedBlackFirst(this._);
                node.P = null;
                node.N = after;
                after.P = after.L = node;
                parent = after;
            }
            else {
                node.P = node.N = null;
                this._ = node;
                parent = null;
            }
            node.L = node.R = null;
            node.U = parent;
            node.C = true;
            after = node;
            while (parent && parent.C) {
                grandpa = parent.U;
                if (parent === grandpa.L) {
                    uncle = grandpa.R;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    }
                    else {
                        if (after === parent.R) {
                            d3_geom_voronoiRedBlackRotateLeft(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, grandpa);
                    }
                }
                else {
                    uncle = grandpa.L;
                    if (uncle && uncle.C) {
                        parent.C = uncle.C = false;
                        grandpa.C = true;
                        after = grandpa;
                    }
                    else {
                        if (after === parent.L) {
                            d3_geom_voronoiRedBlackRotateRight(this, parent);
                            after = parent;
                            parent = after.U;
                        }
                        parent.C = false;
                        grandpa.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
                    }
                }
                parent = after.U;
            }
            this._.C = false;
        },
        remove: function (node) {
            if (node.N)
                node.N.P = node.P;
            if (node.P)
                node.P.N = node.N;
            node.N = node.P = null;
            var parent = node.U, sibling, left = node.L, right = node.R, next, red;
            if (!left)
                next = right;
            else if (!right)
                next = left;
            else
                next = d3_geom_voronoiRedBlackFirst(right);
            if (parent) {
                if (parent.L === node)
                    parent.L = next;
                else
                    parent.R = next;
            }
            else {
                this._ = next;
            }
            if (left && right) {
                red = next.C;
                next.C = node.C;
                next.L = left;
                left.U = next;
                if (next !== right) {
                    parent = next.U;
                    next.U = node.U;
                    node = next.R;
                    parent.L = node;
                    next.R = right;
                    right.U = next;
                }
                else {
                    next.U = parent;
                    parent = next;
                    node = next.R;
                }
            }
            else {
                red = node.C;
                node = next;
            }
            if (node)
                node.U = parent;
            if (red)
                return;
            if (node && node.C) {
                node.C = false;
                return;
            }
            do {
                if (node === this._)
                    break;
                if (node === parent.L) {
                    sibling = parent.R;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        sibling = parent.R;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.R || !sibling.R.C) {
                            sibling.L.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateRight(this, sibling);
                            sibling = parent.R;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.R.C = false;
                        d3_geom_voronoiRedBlackRotateLeft(this, parent);
                        node = this._;
                        break;
                    }
                }
                else {
                    sibling = parent.L;
                    if (sibling.C) {
                        sibling.C = false;
                        parent.C = true;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        sibling = parent.L;
                    }
                    if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
                        if (!sibling.L || !sibling.L.C) {
                            sibling.R.C = false;
                            sibling.C = true;
                            d3_geom_voronoiRedBlackRotateLeft(this, sibling);
                            sibling = parent.L;
                        }
                        sibling.C = parent.C;
                        parent.C = sibling.L.C = false;
                        d3_geom_voronoiRedBlackRotateRight(this, parent);
                        node = this._;
                        break;
                    }
                }
                sibling.C = true;
                node = parent;
                parent = parent.U;
            } while (!node.C);
            if (node)
                node.C = false;
        }
    };
    function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
        var p = node, q = node.R, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        }
        else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.R = q.L;
        if (p.R)
            p.R.U = p;
        q.L = p;
    }
    function d3_geom_voronoiRedBlackRotateRight(tree, node) {
        var p = node, q = node.L, parent = p.U;
        if (parent) {
            if (parent.L === p)
                parent.L = q;
            else
                parent.R = q;
        }
        else {
            tree._ = q;
        }
        q.U = parent;
        p.U = q;
        p.L = q.R;
        if (p.L)
            p.L.U = p;
        q.R = p;
    }
    function d3_geom_voronoiRedBlackFirst(node) {
        while (node.L)
            node = node.L;
        return node;
    }
    function d3_geom_voronoi(sites, bbox) {
        var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
        d3_geom_voronoiEdges = [];
        d3_geom_voronoiCells = new Array(sites.length);
        d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
        d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
        while (true) {
            circle = d3_geom_voronoiFirstCircle;
            if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
                if (site.x !== x0 || site.y !== y0) {
                    d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
                    d3_geom_voronoiAddBeach(site);
                    x0 = site.x, y0 = site.y;
                }
                site = sites.pop();
            }
            else if (circle) {
                d3_geom_voronoiRemoveBeach(circle.arc);
            }
            else {
                break;
            }
        }
        if (bbox)
            d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
        var diagram = {
            cells: d3_geom_voronoiCells,
            edges: d3_geom_voronoiEdges
        };
        d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
        return diagram;
    }
    function d3_geom_voronoiVertexOrder(a, b) {
        return b.y - a.y || b.x - a.x;
    }
    d3.geom.voronoi = function (points) {
        var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
        if (points)
            return voronoi(points);
        function voronoi(data) {
            var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
            d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function (cell, i) {
                var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function (e) {
                    var s = e.start();
                    return [s.x, s.y];
                }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [[x0, y1], [x1, y1], [x1, y0], [x0, y0]] : [];
                polygon.point = data[i];
            });
            return polygons;
        }
        function sites(data) {
            return data.map(function (d, i) {
                return {
                    x: Math.round(fx(d, i) / epsilon) * epsilon,
                    y: Math.round(fy(d, i) / epsilon) * epsilon,
                    i: i
                };
            });
        }
        voronoi.links = function (data) {
            return d3_geom_voronoi(sites(data)).edges.filter(function (edge) {
                return edge.l && edge.r;
            }).map(function (edge) {
                return {
                    source: data[edge.l.i],
                    target: data[edge.r.i]
                };
            });
        };
        voronoi.triangles = function (data) {
            var triangles = [];
            d3_geom_voronoi(sites(data)).cells.forEach(function (cell, i) {
                var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
                while (++j < m) {
                    e0 = e1;
                    s0 = s1;
                    e1 = edges[j].edge;
                    s1 = e1.l === site ? e1.r : e1.l;
                    if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
                        triangles.push([data[i], data[s0.i], data[s1.i]]);
                    }
                }
            });
            return triangles;
        };
        voronoi.x = function (_) {
            return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
        };
        voronoi.y = function (_) {
            return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
        };
        voronoi.clipExtent = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
            clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
            return voronoi;
        };
        voronoi.size = function (_) {
            if (!arguments.length)
                return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
            return voronoi.clipExtent(_ && [[0, 0], _]);
        };
        return voronoi;
    };
    var d3_geom_voronoiClipExtent = [[-1e6, -1e6], [1e6, 1e6]];
    function d3_geom_voronoiTriangleArea(a, b, c) {
        return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
    }
    d3.geom.delaunay = function (vertices) {
        return d3.geom.voronoi().triangles(vertices);
    };
    d3.geom.quadtree = function (points, x1, y1, x2, y2) {
        var x = d3_geom_pointX, y = d3_geom_pointY, compat;
        if (compat = arguments.length) {
            x = d3_geom_quadtreeCompatX;
            y = d3_geom_quadtreeCompatY;
            if (compat === 3) {
                y2 = y1;
                x2 = x1;
                y1 = x1 = 0;
            }
            return quadtree(points);
        }
        function quadtree(data) {
            var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
            if (x1 != null) {
                x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
            }
            else {
                x2_ = y2_ = -(x1_ = y1_ = Infinity);
                xs = [], ys = [];
                n = data.length;
                if (compat)
                    for (i = 0; i < n; ++i) {
                        d = data[i];
                        if (d.x < x1_)
                            x1_ = d.x;
                        if (d.y < y1_)
                            y1_ = d.y;
                        if (d.x > x2_)
                            x2_ = d.x;
                        if (d.y > y2_)
                            y2_ = d.y;
                        xs.push(d.x);
                        ys.push(d.y);
                    }
                else
                    for (i = 0; i < n; ++i) {
                        var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
                        if (x_ < x1_)
                            x1_ = x_;
                        if (y_ < y1_)
                            y1_ = y_;
                        if (x_ > x2_)
                            x2_ = x_;
                        if (y_ > y2_)
                            y2_ = y_;
                        xs.push(x_);
                        ys.push(y_);
                    }
            }
            var dx = x2_ - x1_, dy = y2_ - y1_;
            if (dx > dy)
                y2_ = y1_ + dx;
            else
                x2_ = x1_ + dy;
            function insert(n, d, x, y, x1, y1, x2, y2) {
                if (isNaN(x) || isNaN(y))
                    return;
                if (n.leaf) {
                    var nx = n.x, ny = n.y;
                    if (nx != null) {
                        if (abs(nx - x) + abs(ny - y) < .01) {
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                        else {
                            var nPoint = n.point;
                            n.x = n.y = n.point = null;
                            insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
                            insertChild(n, d, x, y, x1, y1, x2, y2);
                        }
                    }
                    else {
                        n.x = x, n.y = y, n.point = d;
                    }
                }
                else {
                    insertChild(n, d, x, y, x1, y1, x2, y2);
                }
            }
            function insertChild(n, d, x, y, x1, y1, x2, y2) {
                var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
                n.leaf = false;
                n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
                if (right)
                    x1 = xm;
                else
                    x2 = xm;
                if (below)
                    y1 = ym;
                else
                    y2 = ym;
                insert(n, d, x, y, x1, y1, x2, y2);
            }
            var root = d3_geom_quadtreeNode();
            root.add = function (d) {
                insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
            };
            root.visit = function (f) {
                d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
            };
            root.find = function (point) {
                return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
            };
            i = -1;
            if (x1 == null) {
                while (++i < n) {
                    insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
                }
                --i;
            }
            else
                data.forEach(root.add);
            xs = ys = data = d = null;
            return root;
        }
        quadtree.x = function (_) {
            return arguments.length ? (x = _, quadtree) : x;
        };
        quadtree.y = function (_) {
            return arguments.length ? (y = _, quadtree) : y;
        };
        quadtree.extent = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [[x1, y1], [x2, y2]];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0],
                    y2 = +_[1][1];
            return quadtree;
        };
        quadtree.size = function (_) {
            if (!arguments.length)
                return x1 == null ? null : [x2 - x1, y2 - y1];
            if (_ == null)
                x1 = y1 = x2 = y2 = null;
            else
                x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
            return quadtree;
        };
        return quadtree;
    };
    function d3_geom_quadtreeCompatX(d) {
        return d.x;
    }
    function d3_geom_quadtreeCompatY(d) {
        return d.y;
    }
    function d3_geom_quadtreeNode() {
        return {
            leaf: true,
            nodes: [],
            point: null,
            x: null,
            y: null
        };
    }
    function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
        if (!f(node, x1, y1, x2, y2)) {
            var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
            if (children[0])
                d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
            if (children[1])
                d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
            if (children[2])
                d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
            if (children[3])
                d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
        }
    }
    function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
        var minDistance2 = Infinity, closestPoint;
        (function find(node, x1, y1, x2, y2) {
            if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0)
                return;
            if (point = node.point) {
                var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
                if (distance2 < minDistance2) {
                    var distance = Math.sqrt(minDistance2 = distance2);
                    x0 = x - distance, y0 = y - distance;
                    x3 = x + distance, y3 = y + distance;
                    closestPoint = point;
                }
            }
            var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
            for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
                if (node = children[i & 3])
                    switch (i & 3) {
                        case 0:
                            find(node, x1, y1, xm, ym);
                            break;
                        case 1:
                            find(node, xm, y1, x2, ym);
                            break;
                        case 2:
                            find(node, x1, ym, xm, y2);
                            break;
                        case 3:
                            find(node, xm, ym, x2, y2);
                            break;
                    }
            }
        })(root, x0, y0, x3, y3);
        return closestPoint;
    }
    d3.interpolateRgb = d3_interpolateRgb;
    function d3_interpolateRgb(a, b) {
        a = d3.rgb(a);
        b = d3.rgb(b);
        var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
        return function (t) {
            return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
        };
    }
    d3.interpolateObject = d3_interpolateObject;
    function d3_interpolateObject(a, b) {
        var i = {}, c = {}, k;
        for (k in a) {
            if (k in b) {
                i[k] = d3_interpolate(a[k], b[k]);
            }
            else {
                c[k] = a[k];
            }
        }
        for (k in b) {
            if (!(k in a)) {
                c[k] = b[k];
            }
        }
        return function (t) {
            for (k in i)
                c[k] = i[k](t);
            return c;
        };
    }
    d3.interpolateNumber = d3_interpolateNumber;
    function d3_interpolateNumber(a, b) {
        a = +a, b = +b;
        return function (t) {
            return a * (1 - t) + b * t;
        };
    }
    d3.interpolateString = d3_interpolateString;
    function d3_interpolateString(a, b) {
        var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
        a = a + "", b = b + "";
        while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
            if ((bs = bm.index) > bi) {
                bs = b.slice(bi, bs);
                if (s[i])
                    s[i] += bs;
                else
                    s[++i] = bs;
            }
            if ((am = am[0]) === (bm = bm[0])) {
                if (s[i])
                    s[i] += bm;
                else
                    s[++i] = bm;
            }
            else {
                s[++i] = null;
                q.push({
                    i: i,
                    x: d3_interpolateNumber(am, bm)
                });
            }
            bi = d3_interpolate_numberB.lastIndex;
        }
        if (bi < b.length) {
            bs = b.slice(bi);
            if (s[i])
                s[i] += bs;
            else
                s[++i] = bs;
        }
        return s.length < 2 ? q[0] ? (b = q[0].x, function (t) {
            return b(t) + "";
        }) : function () {
            return b;
        } : (b = q.length, function (t) {
            for (var i = 0, o; i < b; ++i)
                s[(o = q[i]).i] = o.x(t);
            return s.join("");
        });
    }
    var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
    d3.interpolate = d3_interpolate;
    function d3_interpolate(a, b) {
        var i = d3.interpolators.length, f;
        while (--i >= 0 && !(f = d3.interpolators[i](a, b)))
            ;
        return f;
    }
    d3.interpolators = [function (a, b) {
            var t = typeof b;
            return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
        }];
    d3.interpolateArray = d3_interpolateArray;
    function d3_interpolateArray(a, b) {
        var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
        for (i = 0; i < n0; ++i)
            x.push(d3_interpolate(a[i], b[i]));
        for (; i < na; ++i)
            c[i] = a[i];
        for (; i < nb; ++i)
            c[i] = b[i];
        return function (t) {
            for (i = 0; i < n0; ++i)
                c[i] = x[i](t);
            return c;
        };
    }
    var d3_ease_default = function () {
        return d3_identity;
    };
    var d3_ease = d3.map({
        linear: d3_ease_default,
        poly: d3_ease_poly,
        quad: function () {
            return d3_ease_quad;
        },
        cubic: function () {
            return d3_ease_cubic;
        },
        sin: function () {
            return d3_ease_sin;
        },
        exp: function () {
            return d3_ease_exp;
        },
        circle: function () {
            return d3_ease_circle;
        },
        elastic: d3_ease_elastic,
        back: d3_ease_back,
        bounce: function () {
            return d3_ease_bounce;
        }
    });
    var d3_ease_mode = d3.map({
        "in": d3_identity,
        out: d3_ease_reverse,
        "in-out": d3_ease_reflect,
        "out-in": function (f) {
            return d3_ease_reflect(d3_ease_reverse(f));
        }
    });
    d3.ease = function (name) {
        var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
        t = d3_ease.get(t) || d3_ease_default;
        m = d3_ease_mode.get(m) || d3_identity;
        return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
    };
    function d3_ease_clamp(f) {
        return function (t) {
            return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
        };
    }
    function d3_ease_reverse(f) {
        return function (t) {
            return 1 - f(1 - t);
        };
    }
    function d3_ease_reflect(f) {
        return function (t) {
            return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
        };
    }
    function d3_ease_quad(t) {
        return t * t;
    }
    function d3_ease_cubic(t) {
        return t * t * t;
    }
    function d3_ease_cubicInOut(t) {
        if (t <= 0)
            return 0;
        if (t >= 1)
            return 1;
        var t2 = t * t, t3 = t2 * t;
        return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
    }
    function d3_ease_poly(e) {
        return function (t) {
            return Math.pow(t, e);
        };
    }
    function d3_ease_sin(t) {
        return 1 - Math.cos(t * halfpipipi);
    }
    function d3_ease_exp(t) {
        return Math.pow(2, 10 * (t - 1));
    }
    function d3_ease_circle(t) {
        return 1 - Math.sqrt(1 - t * t);
    }
    function d3_ease_elastic(a, p) {
        var s;
        if (arguments.length < 2)
            p = .45;
        if (arguments.length)
            s = p / tau * Math.asin(1 / a);
        else
            a = 1, s = p / 4;
        return function (t) {
            return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * tau / p);
        };
    }
    function d3_ease_back(s) {
        if (!s)
            s = 1.70158;
        return function (t) {
            return t * t * ((s + 1) * t - s);
        };
    }
    function d3_ease_bounce(t) {
        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
    }
    d3.interpolateHcl = d3_interpolateHcl;
    function d3_interpolateHcl(a, b) {
        a = d3.hcl(a);
        b = d3.hcl(b);
        var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
        if (isNaN(bc))
            bc = 0, ac = isNaN(ac) ? b.c : ac;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
        };
    }
    d3.interpolateHsl = d3_interpolateHsl;
    function d3_interpolateHsl(a, b) {
        a = d3.hsl(a);
        b = d3.hsl(b);
        var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
        if (isNaN(bs))
            bs = 0, as = isNaN(as) ? b.s : as;
        if (isNaN(bh))
            bh = 0, ah = isNaN(ah) ? b.h : ah;
        else if (bh > 180)
            bh -= 360;
        else if (bh < -180)
            bh += 360;
        return function (t) {
            return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
        };
    }
    d3.interpolateLab = d3_interpolateLab;
    function d3_interpolateLab(a, b) {
        a = d3.lab(a);
        b = d3.lab(b);
        var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
        return function (t) {
            return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
        };
    }
    d3.interpolateRound = d3_interpolateRound;
    function d3_interpolateRound(a, b) {
        b -= a;
        return function (t) {
            return Math.round(a + b * t);
        };
    }
    d3.transform = function (string) {
        var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
        return (d3.transform = function (string) {
            if (string != null) {
                g.setAttribute("transform", string);
                var t = g.transform.baseVal.consolidate();
            }
            return new d3_transform(t ? t.matrix : d3_transformIdentity);
        })(string);
    };
    function d3_transform(m) {
        var r0 = [m.a, m.b], r1 = [m.c, m.d], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
        if (r0[0] * r1[1] < r1[0] * r0[1]) {
            r0[0] *= -1;
            r0[1] *= -1;
            kx *= -1;
            kz *= -1;
        }
        this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
        this.translate = [m.e, m.f];
        this.scale = [kx, ky];
        this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
    }
    d3_transform.prototype.toString = function () {
        return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
    };
    function d3_transformDot(a, b) {
        return a[0] * b[0] + a[1] * b[1];
    }
    function d3_transformNormalize(a) {
        var k = Math.sqrt(d3_transformDot(a, a));
        if (k) {
            a[0] /= k;
            a[1] /= k;
        }
        return k;
    }
    function d3_transformCombine(a, b, k) {
        a[0] += k * b[0];
        a[1] += k * b[1];
        return a;
    }
    var d3_transformIdentity = {
        a: 1,
        b: 0,
        c: 0,
        d: 1,
        e: 0,
        f: 0
    };
    d3.interpolateTransform = d3_interpolateTransform;
    function d3_interpolateTransformPop(s) {
        return s.length ? s.pop() + "," : "";
    }
    function d3_interpolateTranslate(ta, tb, s, q) {
        if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
            var i = s.push("translate(", null, ",", null, ")");
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ta[0], tb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ta[1], tb[1])
            });
        }
        else if (tb[0] || tb[1]) {
            s.push("translate(" + tb + ")");
        }
    }
    function d3_interpolateRotate(ra, rb, s, q) {
        if (ra !== rb) {
            if (ra - rb > 180)
                rb += 360;
            else if (rb - ra > 180)
                ra += 360;
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
                x: d3_interpolateNumber(ra, rb)
            });
        }
        else if (rb) {
            s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
        }
    }
    function d3_interpolateSkew(wa, wb, s, q) {
        if (wa !== wb) {
            q.push({
                i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
                x: d3_interpolateNumber(wa, wb)
            });
        }
        else if (wb) {
            s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
        }
    }
    function d3_interpolateScale(ka, kb, s, q) {
        if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
            var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
            q.push({
                i: i - 4,
                x: d3_interpolateNumber(ka[0], kb[0])
            }, {
                i: i - 2,
                x: d3_interpolateNumber(ka[1], kb[1])
            });
        }
        else if (kb[0] !== 1 || kb[1] !== 1) {
            s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
        }
    }
    function d3_interpolateTransform(a, b) {
        var s = [], q = [];
        a = d3.transform(a), b = d3.transform(b);
        d3_interpolateTranslate(a.translate, b.translate, s, q);
        d3_interpolateRotate(a.rotate, b.rotate, s, q);
        d3_interpolateSkew(a.skew, b.skew, s, q);
        d3_interpolateScale(a.scale, b.scale, s, q);
        a = b = null;
        return function (t) {
            var i = -1, n = q.length, o;
            while (++i < n)
                s[(o = q[i]).i] = o.x(t);
            return s.join("");
        };
    }
    function d3_uninterpolateNumber(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return (x - a) / b;
        };
    }
    function d3_uninterpolateClamp(a, b) {
        b = (b -= a = +a) || 1 / b;
        return function (x) {
            return Math.max(0, Math.min(1, (x - a) / b));
        };
    }
    d3.layout = {};
    d3.layout.bundle = function () {
        return function (links) {
            var paths = [], i = -1, n = links.length;
            while (++i < n)
                paths.push(d3_layout_bundlePath(links[i]));
            return paths;
        };
    };
    function d3_layout_bundlePath(link) {
        var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [start];
        while (start !== lca) {
            start = start.parent;
            points.push(start);
        }
        var k = points.length;
        while (end !== lca) {
            points.splice(k, 0, end);
            end = end.parent;
        }
        return points;
    }
    function d3_layout_bundleAncestors(node) {
        var ancestors = [], parent = node.parent;
        while (parent != null) {
            ancestors.push(node);
            node = parent;
            parent = parent.parent;
        }
        ancestors.push(node);
        return ancestors;
    }
    function d3_layout_bundleLeastCommonAncestor(a, b) {
        if (a === b)
            return a;
        var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
        while (aNode === bNode) {
            sharedNode = aNode;
            aNode = aNodes.pop();
            bNode = bNodes.pop();
        }
        return sharedNode;
    }
    d3.layout.chord = function () {
        var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
        function relayout() {
            var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
            chords = [];
            groups = [];
            k = 0, i = -1;
            while (++i < n) {
                x = 0, j = -1;
                while (++j < n) {
                    x += matrix[i][j];
                }
                groupSums.push(x);
                subgroupIndex.push(d3.range(n));
                k += x;
            }
            if (sortGroups) {
                groupIndex.sort(function (a, b) {
                    return sortGroups(groupSums[a], groupSums[b]);
                });
            }
            if (sortSubgroups) {
                subgroupIndex.forEach(function (d, i) {
                    d.sort(function (a, b) {
                        return sortSubgroups(matrix[i][a], matrix[i][b]);
                    });
                });
            }
            k = (tau - padding * n) / k;
            x = 0, i = -1;
            while (++i < n) {
                x0 = x, j = -1;
                while (++j < n) {
                    var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
                    subgroups[di + "-" + dj] = {
                        index: di,
                        subindex: dj,
                        startAngle: a0,
                        endAngle: a1,
                        value: v
                    };
                }
                groups[di] = {
                    index: di,
                    startAngle: x0,
                    endAngle: x,
                    value: groupSums[di]
                };
                x += padding;
            }
            i = -1;
            while (++i < n) {
                j = i - 1;
                while (++j < n) {
                    var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
                    if (source.value || target.value) {
                        chords.push(source.value < target.value ? {
                            source: target,
                            target: source
                        } : {
                            source: source,
                            target: target
                        });
                    }
                }
            }
            if (sortChords)
                resort();
        }
        function resort() {
            chords.sort(function (a, b) {
                return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
            });
        }
        chord.matrix = function (x) {
            if (!arguments.length)
                return matrix;
            n = (matrix = x) && matrix.length;
            chords = groups = null;
            return chord;
        };
        chord.padding = function (x) {
            if (!arguments.length)
                return padding;
            padding = x;
            chords = groups = null;
            return chord;
        };
        chord.sortGroups = function (x) {
            if (!arguments.length)
                return sortGroups;
            sortGroups = x;
            chords = groups = null;
            return chord;
        };
        chord.sortSubgroups = function (x) {
            if (!arguments.length)
                return sortSubgroups;
            sortSubgroups = x;
            chords = null;
            return chord;
        };
        chord.sortChords = function (x) {
            if (!arguments.length)
                return sortChords;
            sortChords = x;
            if (chords)
                resort();
            return chord;
        };
        chord.chords = function () {
            if (!chords)
                relayout();
            return chords;
        };
        chord.groups = function () {
            if (!groups)
                relayout();
            return groups;
        };
        return chord;
    };
    d3.layout.force = function () {
        var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [1, 1], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
        function repulse(node) {
            return function (quad, x1, _, x2) {
                if (quad.point !== node) {
                    var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
                    if (dw * dw / theta2 < dn) {
                        if (dn < chargeDistance2) {
                            var k = quad.charge / dn;
                            node.px -= dx * k;
                            node.py -= dy * k;
                        }
                        return true;
                    }
                    if (quad.point && dn && dn < chargeDistance2) {
                        var k = quad.pointCharge / dn;
                        node.px -= dx * k;
                        node.py -= dy * k;
                    }
                }
                return !quad.charge;
            };
        }
        force.tick = function () {
            if ((alpha *= .99) < .005) {
                timer = null;
                event.end({
                    type: "end",
                    alpha: alpha = 0
                });
                return true;
            }
            var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
            for (i = 0; i < m; ++i) {
                o = links[i];
                s = o.source;
                t = o.target;
                x = t.x - s.x;
                y = t.y - s.y;
                if (l = x * x + y * y) {
                    l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
                    x *= l;
                    y *= l;
                    t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
                    t.y -= y * k;
                    s.x += x * (k = 1 - k);
                    s.y += y * k;
                }
            }
            if (k = alpha * gravity) {
                x = size[0] / 2;
                y = size[1] / 2;
                i = -1;
                if (k)
                    while (++i < n) {
                        o = nodes[i];
                        o.x += (x - o.x) * k;
                        o.y += (y - o.y) * k;
                    }
            }
            if (charge) {
                d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
                i = -1;
                while (++i < n) {
                    if (!(o = nodes[i]).fixed) {
                        q.visit(repulse(o));
                    }
                }
            }
            i = -1;
            while (++i < n) {
                o = nodes[i];
                if (o.fixed) {
                    o.x = o.px;
                    o.y = o.py;
                }
                else {
                    o.x -= (o.px - (o.px = o.x)) * friction;
                    o.y -= (o.py - (o.py = o.y)) * friction;
                }
            }
            event.tick({
                type: "tick",
                alpha: alpha
            });
        };
        force.nodes = function (x) {
            if (!arguments.length)
                return nodes;
            nodes = x;
            return force;
        };
        force.links = function (x) {
            if (!arguments.length)
                return links;
            links = x;
            return force;
        };
        force.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return force;
        };
        force.linkDistance = function (x) {
            if (!arguments.length)
                return linkDistance;
            linkDistance = typeof x === "function" ? x : +x;
            return force;
        };
        force.distance = force.linkDistance;
        force.linkStrength = function (x) {
            if (!arguments.length)
                return linkStrength;
            linkStrength = typeof x === "function" ? x : +x;
            return force;
        };
        force.friction = function (x) {
            if (!arguments.length)
                return friction;
            friction = +x;
            return force;
        };
        force.charge = function (x) {
            if (!arguments.length)
                return charge;
            charge = typeof x === "function" ? x : +x;
            return force;
        };
        force.chargeDistance = function (x) {
            if (!arguments.length)
                return Math.sqrt(chargeDistance2);
            chargeDistance2 = x * x;
            return force;
        };
        force.gravity = function (x) {
            if (!arguments.length)
                return gravity;
            gravity = +x;
            return force;
        };
        force.theta = function (x) {
            if (!arguments.length)
                return Math.sqrt(theta2);
            theta2 = x * x;
            return force;
        };
        force.alpha = function (x) {
            if (!arguments.length)
                return alpha;
            x = +x;
            if (alpha) {
                if (x > 0) {
                    alpha = x;
                }
                else {
                    timer.c = null, timer.t = NaN, timer = null;
                    event.end({
                        type: "end",
                        alpha: alpha = 0
                    });
                }
            }
            else if (x > 0) {
                event.start({
                    type: "start",
                    alpha: alpha = x
                });
                timer = d3_timer(force.tick);
            }
            return force;
        };
        force.start = function () {
            var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
            for (i = 0; i < n; ++i) {
                (o = nodes[i]).index = i;
                o.weight = 0;
            }
            for (i = 0; i < m; ++i) {
                o = links[i];
                if (typeof o.source == "number")
                    o.source = nodes[o.source];
                if (typeof o.target == "number")
                    o.target = nodes[o.target];
                ++o.source.weight;
                ++o.target.weight;
            }
            for (i = 0; i < n; ++i) {
                o = nodes[i];
                if (isNaN(o.x))
                    o.x = position("x", w);
                if (isNaN(o.y))
                    o.y = position("y", h);
                if (isNaN(o.px))
                    o.px = o.x;
                if (isNaN(o.py))
                    o.py = o.y;
            }
            distances = [];
            if (typeof linkDistance === "function")
                for (i = 0; i < m; ++i)
                    distances[i] = +linkDistance.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    distances[i] = linkDistance;
            strengths = [];
            if (typeof linkStrength === "function")
                for (i = 0; i < m; ++i)
                    strengths[i] = +linkStrength.call(this, links[i], i);
            else
                for (i = 0; i < m; ++i)
                    strengths[i] = linkStrength;
            charges = [];
            if (typeof charge === "function")
                for (i = 0; i < n; ++i)
                    charges[i] = +charge.call(this, nodes[i], i);
            else
                for (i = 0; i < n; ++i)
                    charges[i] = charge;
            function position(dimension, size) {
                if (!neighbors) {
                    neighbors = new Array(n);
                    for (j = 0; j < n; ++j) {
                        neighbors[j] = [];
                    }
                    for (j = 0; j < m; ++j) {
                        var o = links[j];
                        neighbors[o.source.index].push(o.target);
                        neighbors[o.target.index].push(o.source);
                    }
                }
                var candidates = neighbors[i], j = -1, l = candidates.length, x;
                while (++j < l)
                    if (!isNaN(x = candidates[j][dimension]))
                        return x;
                return Math.random() * size;
            }
            return force.resume();
        };
        force.resume = function () {
            return force.alpha(.1);
        };
        force.stop = function () {
            return force.alpha(0);
        };
        force.drag = function () {
            if (!drag)
                drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
            if (!arguments.length)
                return drag;
            this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
        };
        function dragmove(d) {
            d.px = d3.event.x, d.py = d3.event.y;
            force.resume();
        }
        return d3.rebind(force, event, "on");
    };
    function d3_layout_forceDragstart(d) {
        d.fixed |= 2;
    }
    function d3_layout_forceDragend(d) {
        d.fixed &= ~6;
    }
    function d3_layout_forceMouseover(d) {
        d.fixed |= 4;
        d.px = d.x, d.py = d.y;
    }
    function d3_layout_forceMouseout(d) {
        d.fixed &= ~4;
    }
    function d3_layout_forceAccumulate(quad, alpha, charges) {
        var cx = 0, cy = 0;
        quad.charge = 0;
        if (!quad.leaf) {
            var nodes = quad.nodes, n = nodes.length, i = -1, c;
            while (++i < n) {
                c = nodes[i];
                if (c == null)
                    continue;
                d3_layout_forceAccumulate(c, alpha, charges);
                quad.charge += c.charge;
                cx += c.charge * c.cx;
                cy += c.charge * c.cy;
            }
        }
        if (quad.point) {
            if (!quad.leaf) {
                quad.point.x += Math.random() - .5;
                quad.point.y += Math.random() - .5;
            }
            var k = alpha * charges[quad.point.index];
            quad.charge += quad.pointCharge = k;
            cx += k * quad.point.x;
            cy += k * quad.point.y;
        }
        quad.cx = cx / quad.charge;
        quad.cy = cy / quad.charge;
    }
    var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
    d3.layout.hierarchy = function () {
        var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
        function hierarchy(root) {
            var stack = [root], nodes = [], node;
            root.depth = 0;
            while ((node = stack.pop()) != null) {
                nodes.push(node);
                if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
                    var n, childs, child;
                    while (--n >= 0) {
                        stack.push(child = childs[n]);
                        child.parent = node;
                        child.depth = node.depth + 1;
                    }
                    if (value)
                        node.value = 0;
                    node.children = childs;
                }
                else {
                    if (value)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    delete node.children;
                }
            }
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var childs, parent;
                if (sort && (childs = node.children))
                    childs.sort(sort);
                if (value && (parent = node.parent))
                    parent.value += node.value;
            });
            return nodes;
        }
        hierarchy.sort = function (x) {
            if (!arguments.length)
                return sort;
            sort = x;
            return hierarchy;
        };
        hierarchy.children = function (x) {
            if (!arguments.length)
                return children;
            children = x;
            return hierarchy;
        };
        hierarchy.value = function (x) {
            if (!arguments.length)
                return value;
            value = x;
            return hierarchy;
        };
        hierarchy.revalue = function (root) {
            if (value) {
                d3_layout_hierarchyVisitBefore(root, function (node) {
                    if (node.children)
                        node.value = 0;
                });
                d3_layout_hierarchyVisitAfter(root, function (node) {
                    var parent;
                    if (!node.children)
                        node.value = +value.call(hierarchy, node, node.depth) || 0;
                    if (parent = node.parent)
                        parent.value += node.value;
                });
            }
            return root;
        };
        return hierarchy;
    };
    function d3_layout_hierarchyRebind(object, hierarchy) {
        d3.rebind(object, hierarchy, "sort", "children", "value");
        object.nodes = object;
        object.links = d3_layout_hierarchyLinks;
        return object;
    }
    function d3_layout_hierarchyVisitBefore(node, callback) {
        var nodes = [node];
        while ((node = nodes.pop()) != null) {
            callback(node);
            if ((children = node.children) && (n = children.length)) {
                var n, children;
                while (--n >= 0)
                    nodes.push(children[n]);
            }
        }
    }
    function d3_layout_hierarchyVisitAfter(node, callback) {
        var nodes = [node], nodes2 = [];
        while ((node = nodes.pop()) != null) {
            nodes2.push(node);
            if ((children = node.children) && (n = children.length)) {
                var i = -1, n, children;
                while (++i < n)
                    nodes.push(children[i]);
            }
        }
        while ((node = nodes2.pop()) != null) {
            callback(node);
        }
    }
    function d3_layout_hierarchyChildren(d) {
        return d.children;
    }
    function d3_layout_hierarchyValue(d) {
        return d.value;
    }
    function d3_layout_hierarchySort(a, b) {
        return b.value - a.value;
    }
    function d3_layout_hierarchyLinks(nodes) {
        return d3.merge(nodes.map(function (parent) {
            return (parent.children || []).map(function (child) {
                return {
                    source: parent,
                    target: child
                };
            });
        }));
    }
    d3.layout.partition = function () {
        var hierarchy = d3.layout.hierarchy(), size = [1, 1];
        function position(node, x, dx, dy) {
            var children = node.children;
            node.x = x;
            node.y = node.depth * dy;
            node.dx = dx;
            node.dy = dy;
            if (children && (n = children.length)) {
                var i = -1, n, c, d;
                dx = node.value ? dx / node.value : 0;
                while (++i < n) {
                    position(c = children[i], x, d = c.value * dx, dy);
                    x += d;
                }
            }
        }
        function depth(node) {
            var children = node.children, d = 0;
            if (children && (n = children.length)) {
                var i = -1, n;
                while (++i < n)
                    d = Math.max(d, depth(children[i]));
            }
            return 1 + d;
        }
        function partition(d, i) {
            var nodes = hierarchy.call(this, d, i);
            position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
            return nodes;
        }
        partition.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return partition;
        };
        return d3_layout_hierarchyRebind(partition, hierarchy);
    };
    d3.layout.pie = function () {
        var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = tau, padAngle = 0;
        function pie(data) {
            var n = data.length, values = data.map(function (d, i) {
                return +value.call(pie, d, i);
            }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
            if (sort != null)
                index.sort(sort === d3_layout_pieSortByValue ? function (i, j) {
                    return values[j] - values[i];
                } : function (i, j) {
                    return sort(data[i], data[j]);
                });
            index.forEach(function (i) {
                arcs[i] = {
                    data: data[i],
                    value: v = values[i],
                    startAngle: a,
                    endAngle: a += v * k + pa,
                    padAngle: p
                };
            });
            return arcs;
        }
        pie.value = function (_) {
            if (!arguments.length)
                return value;
            value = _;
            return pie;
        };
        pie.sort = function (_) {
            if (!arguments.length)
                return sort;
            sort = _;
            return pie;
        };
        pie.startAngle = function (_) {
            if (!arguments.length)
                return startAngle;
            startAngle = _;
            return pie;
        };
        pie.endAngle = function (_) {
            if (!arguments.length)
                return endAngle;
            endAngle = _;
            return pie;
        };
        pie.padAngle = function (_) {
            if (!arguments.length)
                return padAngle;
            padAngle = _;
            return pie;
        };
        return pie;
    };
    var d3_layout_pieSortByValue = {};
    d3.layout.stack = function () {
        var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
        function stack(data, index) {
            if (!(n = data.length))
                return data;
            var series = data.map(function (d, i) {
                return values.call(stack, d, i);
            });
            var points = series.map(function (d) {
                return d.map(function (v, i) {
                    return [x.call(stack, v, i), y.call(stack, v, i)];
                });
            });
            var orders = order.call(stack, points, index);
            series = d3.permute(series, orders);
            points = d3.permute(points, orders);
            var offsets = offset.call(stack, points, index);
            var m = series[0].length, n, i, j, o;
            for (j = 0; j < m; ++j) {
                out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
                for (i = 1; i < n; ++i) {
                    out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
                }
            }
            return data;
        }
        stack.values = function (x) {
            if (!arguments.length)
                return values;
            values = x;
            return stack;
        };
        stack.order = function (x) {
            if (!arguments.length)
                return order;
            order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
            return stack;
        };
        stack.offset = function (x) {
            if (!arguments.length)
                return offset;
            offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
            return stack;
        };
        stack.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            return stack;
        };
        stack.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            return stack;
        };
        stack.out = function (z) {
            if (!arguments.length)
                return out;
            out = z;
            return stack;
        };
        return stack;
    };
    function d3_layout_stackX(d) {
        return d.x;
    }
    function d3_layout_stackY(d) {
        return d.y;
    }
    function d3_layout_stackOut(d, y0, y) {
        d.y0 = y0;
        d.y = y;
    }
    var d3_layout_stackOrders = d3.map({
        "inside-out": function (data) {
            var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function (a, b) {
                return max[a] - max[b];
            }), top = 0, bottom = 0, tops = [], bottoms = [];
            for (i = 0; i < n; ++i) {
                j = index[i];
                if (top < bottom) {
                    top += sums[j];
                    tops.push(j);
                }
                else {
                    bottom += sums[j];
                    bottoms.push(j);
                }
            }
            return bottoms.reverse().concat(tops);
        },
        reverse: function (data) {
            return d3.range(data.length).reverse();
        },
        "default": d3_layout_stackOrderDefault
    });
    var d3_layout_stackOffsets = d3.map({
        silhouette: function (data) {
            var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o > max)
                    max = o;
                sums.push(o);
            }
            for (j = 0; j < m; ++j) {
                y0[j] = (max - sums[j]) / 2;
            }
            return y0;
        },
        wiggle: function (data) {
            var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
            y0[0] = o = o0 = 0;
            for (j = 1; j < m; ++j) {
                for (i = 0, s1 = 0; i < n; ++i)
                    s1 += data[i][j][1];
                for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
                    for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
                        s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
                    }
                    s2 += s3 * data[i][j][1];
                }
                y0[j] = o -= s1 ? s2 / s1 * dx : 0;
                if (o < o0)
                    o0 = o;
            }
            for (j = 0; j < m; ++j)
                y0[j] -= o0;
            return y0;
        },
        expand: function (data) {
            var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
            for (j = 0; j < m; ++j) {
                for (i = 0, o = 0; i < n; i++)
                    o += data[i][j][1];
                if (o)
                    for (i = 0; i < n; i++)
                        data[i][j][1] /= o;
                else
                    for (i = 0; i < n; i++)
                        data[i][j][1] = k;
            }
            for (j = 0; j < m; ++j)
                y0[j] = 0;
            return y0;
        },
        zero: d3_layout_stackOffsetZero
    });
    function d3_layout_stackOrderDefault(data) {
        return d3.range(data.length);
    }
    function d3_layout_stackOffsetZero(data) {
        var j = -1, m = data[0].length, y0 = [];
        while (++j < m)
            y0[j] = 0;
        return y0;
    }
    function d3_layout_stackMaxIndex(array) {
        var i = 1, j = 0, v = array[0][1], k, n = array.length;
        for (; i < n; ++i) {
            if ((k = array[i][1]) > v) {
                j = i;
                v = k;
            }
        }
        return j;
    }
    function d3_layout_stackReduceSum(d) {
        return d.reduce(d3_layout_stackSum, 0);
    }
    function d3_layout_stackSum(p, d) {
        return p + d[1];
    }
    d3.layout.histogram = function () {
        var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
        function histogram(data, i) {
            var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
            while (++i < m) {
                bin = bins[i] = [];
                bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
                bin.y = 0;
            }
            if (m > 0) {
                i = -1;
                while (++i < n) {
                    x = values[i];
                    if (x >= range[0] && x <= range[1]) {
                        bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
                        bin.y += k;
                        bin.push(data[i]);
                    }
                }
            }
            return bins;
        }
        histogram.value = function (x) {
            if (!arguments.length)
                return valuer;
            valuer = x;
            return histogram;
        };
        histogram.range = function (x) {
            if (!arguments.length)
                return ranger;
            ranger = d3_functor(x);
            return histogram;
        };
        histogram.bins = function (x) {
            if (!arguments.length)
                return binner;
            binner = typeof x === "number" ? function (range) {
                return d3_layout_histogramBinFixed(range, x);
            } : d3_functor(x);
            return histogram;
        };
        histogram.frequency = function (x) {
            if (!arguments.length)
                return frequency;
            frequency = !!x;
            return histogram;
        };
        return histogram;
    };
    function d3_layout_histogramBinSturges(range, values) {
        return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
    }
    function d3_layout_histogramBinFixed(range, n) {
        var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
        while (++x <= n)
            f[x] = m * x + b;
        return f;
    }
    function d3_layout_histogramRange(values) {
        return [d3.min(values), d3.max(values)];
    }
    d3.layout.pack = function () {
        var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [1, 1], radius;
        function pack(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function () {
                return radius;
            };
            root.x = root.y = 0;
            d3_layout_hierarchyVisitAfter(root, function (d) {
                d.r = +r(d.value);
            });
            d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
            if (padding) {
                var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r += dr;
                });
                d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
                d3_layout_hierarchyVisitAfter(root, function (d) {
                    d.r -= dr;
                });
            }
            d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
            return nodes;
        }
        pack.size = function (_) {
            if (!arguments.length)
                return size;
            size = _;
            return pack;
        };
        pack.radius = function (_) {
            if (!arguments.length)
                return radius;
            radius = _ == null || typeof _ === "function" ? _ : +_;
            return pack;
        };
        pack.padding = function (_) {
            if (!arguments.length)
                return padding;
            padding = +_;
            return pack;
        };
        return d3_layout_hierarchyRebind(pack, hierarchy);
    };
    function d3_layout_packSort(a, b) {
        return a.value - b.value;
    }
    function d3_layout_packInsert(a, b) {
        var c = a._pack_next;
        a._pack_next = b;
        b._pack_prev = a;
        b._pack_next = c;
        c._pack_prev = b;
    }
    function d3_layout_packSplice(a, b) {
        a._pack_next = b;
        b._pack_prev = a;
    }
    function d3_layout_packIntersects(a, b) {
        var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
        return .999 * dr * dr > dx * dx + dy * dy;
    }
    function d3_layout_packSiblings(node) {
        if (!(nodes = node.children) || !(n = nodes.length))
            return;
        var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
        function bound(node) {
            xMin = Math.min(node.x - node.r, xMin);
            xMax = Math.max(node.x + node.r, xMax);
            yMin = Math.min(node.y - node.r, yMin);
            yMax = Math.max(node.y + node.r, yMax);
        }
        nodes.forEach(d3_layout_packLink);
        a = nodes[0];
        a.x = -a.r;
        a.y = 0;
        bound(a);
        if (n > 1) {
            b = nodes[1];
            b.x = b.r;
            b.y = 0;
            bound(b);
            if (n > 2) {
                c = nodes[2];
                d3_layout_packPlace(a, b, c);
                bound(c);
                d3_layout_packInsert(a, c);
                a._pack_prev = c;
                d3_layout_packInsert(c, b);
                b = a._pack_next;
                for (i = 3; i < n; i++) {
                    d3_layout_packPlace(a, b, c = nodes[i]);
                    var isect = 0, s1 = 1, s2 = 1;
                    for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
                        if (d3_layout_packIntersects(j, c)) {
                            isect = 1;
                            break;
                        }
                    }
                    if (isect == 1) {
                        for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
                            if (d3_layout_packIntersects(k, c)) {
                                break;
                            }
                        }
                    }
                    if (isect) {
                        if (s1 < s2 || s1 == s2 && b.r < a.r)
                            d3_layout_packSplice(a, b = j);
                        else
                            d3_layout_packSplice(a = k, b);
                        i--;
                    }
                    else {
                        d3_layout_packInsert(a, c);
                        b = c;
                        bound(c);
                    }
                }
            }
        }
        var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
        for (i = 0; i < n; i++) {
            c = nodes[i];
            c.x -= cx;
            c.y -= cy;
            cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
        }
        node.r = cr;
        nodes.forEach(d3_layout_packUnlink);
    }
    function d3_layout_packLink(node) {
        node._pack_next = node._pack_prev = node;
    }
    function d3_layout_packUnlink(node) {
        delete node._pack_next;
        delete node._pack_prev;
    }
    function d3_layout_packTransform(node, x, y, k) {
        var children = node.children;
        node.x = x += k * node.x;
        node.y = y += k * node.y;
        node.r *= k;
        if (children) {
            var i = -1, n = children.length;
            while (++i < n)
                d3_layout_packTransform(children[i], x, y, k);
        }
    }
    function d3_layout_packPlace(a, b, c) {
        var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
        if (db && (dx || dy)) {
            var da = b.r + c.r, dc = dx * dx + dy * dy;
            da *= da;
            db *= db;
            var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
            c.x = a.x + x * dx + y * dy;
            c.y = a.y + x * dy - y * dx;
        }
        else {
            c.x = a.x + db;
            c.y = a.y;
        }
    }
    d3.layout.tree = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = null;
        function tree(d, i) {
            var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
            d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
            d3_layout_hierarchyVisitBefore(root1, secondWalk);
            if (nodeSize)
                d3_layout_hierarchyVisitBefore(root0, sizeNode);
            else {
                var left = root0, right = root0, bottom = root0;
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    if (node.x < left.x)
                        left = node;
                    if (node.x > right.x)
                        right = node;
                    if (node.depth > bottom.depth)
                        bottom = node;
                });
                var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
                d3_layout_hierarchyVisitBefore(root0, function (node) {
                    node.x = (node.x + tx) * kx;
                    node.y = node.depth * ky;
                });
            }
            return nodes;
        }
        function wrapTree(root0) {
            var root1 = {
                A: null,
                children: [root0]
            }, queue = [root1], node1;
            while ((node1 = queue.pop()) != null) {
                for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
                    queue.push((children[i] = child = {
                        _: children[i],
                        parent: node1,
                        children: (child = children[i].children) && child.slice() || [],
                        A: null,
                        a: null,
                        z: 0,
                        m: 0,
                        c: 0,
                        s: 0,
                        t: null,
                        i: i
                    }).a = child);
                }
            }
            return root1.children[0];
        }
        function firstWalk(v) {
            var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
            if (children.length) {
                d3_layout_treeShift(v);
                var midpoint = (children[0].z + children[children.length - 1].z) / 2;
                if (w) {
                    v.z = w.z + separation(v._, w._);
                    v.m = v.z - midpoint;
                }
                else {
                    v.z = midpoint;
                }
            }
            else if (w) {
                v.z = w.z + separation(v._, w._);
            }
            v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
        }
        function secondWalk(v) {
            v._.x = v.z + v.parent.m;
            v.m += v.parent.m;
        }
        function apportion(v, w, ancestor) {
            if (w) {
                var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
                while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
                    vom = d3_layout_treeLeft(vom);
                    vop = d3_layout_treeRight(vop);
                    vop.a = v;
                    shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
                    if (shift > 0) {
                        d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
                        sip += shift;
                        sop += shift;
                    }
                    sim += vim.m;
                    sip += vip.m;
                    som += vom.m;
                    sop += vop.m;
                }
                if (vim && !d3_layout_treeRight(vop)) {
                    vop.t = vim;
                    vop.m += sim - sop;
                }
                if (vip && !d3_layout_treeLeft(vom)) {
                    vom.t = vip;
                    vom.m += sip - som;
                    ancestor = v;
                }
            }
            return ancestor;
        }
        function sizeNode(node) {
            node.x *= size[0];
            node.y = node.depth * size[1];
        }
        tree.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return tree;
        };
        tree.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null ? sizeNode : null;
            return tree;
        };
        tree.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) == null ? null : sizeNode;
            return tree;
        };
        return d3_layout_hierarchyRebind(tree, hierarchy);
    };
    function d3_layout_treeSeparation(a, b) {
        return a.parent == b.parent ? 1 : 2;
    }
    function d3_layout_treeLeft(v) {
        var children = v.children;
        return children.length ? children[0] : v.t;
    }
    function d3_layout_treeRight(v) {
        var children = v.children, n;
        return (n = children.length) ? children[n - 1] : v.t;
    }
    function d3_layout_treeMove(wm, wp, shift) {
        var change = shift / (wp.i - wm.i);
        wp.c -= change;
        wp.s += shift;
        wm.c += change;
        wp.z += shift;
        wp.m += shift;
    }
    function d3_layout_treeShift(v) {
        var shift = 0, change = 0, children = v.children, i = children.length, w;
        while (--i >= 0) {
            w = children[i];
            w.z += shift;
            w.m += shift;
            shift += w.s + (change += w.c);
        }
    }
    function d3_layout_treeAncestor(vim, v, ancestor) {
        return vim.a.parent === v.parent ? vim.a : ancestor;
    }
    d3.layout.cluster = function () {
        var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [1, 1], nodeSize = false;
        function cluster(d, i) {
            var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
            d3_layout_hierarchyVisitAfter(root, function (node) {
                var children = node.children;
                if (children && children.length) {
                    node.x = d3_layout_clusterX(children);
                    node.y = d3_layout_clusterY(children);
                }
                else {
                    node.x = previousNode ? x += separation(node, previousNode) : 0;
                    node.y = 0;
                    previousNode = node;
                }
            });
            var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
            d3_layout_hierarchyVisitAfter(root, nodeSize ? function (node) {
                node.x = (node.x - root.x) * size[0];
                node.y = (root.y - node.y) * size[1];
            } : function (node) {
                node.x = (node.x - x0) / (x1 - x0) * size[0];
                node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
            });
            return nodes;
        }
        cluster.separation = function (x) {
            if (!arguments.length)
                return separation;
            separation = x;
            return cluster;
        };
        cluster.size = function (x) {
            if (!arguments.length)
                return nodeSize ? null : size;
            nodeSize = (size = x) == null;
            return cluster;
        };
        cluster.nodeSize = function (x) {
            if (!arguments.length)
                return nodeSize ? size : null;
            nodeSize = (size = x) != null;
            return cluster;
        };
        return d3_layout_hierarchyRebind(cluster, hierarchy);
    };
    function d3_layout_clusterY(children) {
        return 1 + d3.max(children, function (child) {
            return child.y;
        });
    }
    function d3_layout_clusterX(children) {
        return children.reduce(function (x, child) {
            return x + child.x;
        }, 0) / children.length;
    }
    function d3_layout_clusterLeft(node) {
        var children = node.children;
        return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
    }
    function d3_layout_clusterRight(node) {
        var children = node.children, n;
        return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
    }
    d3.layout.treemap = function () {
        var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [1, 1], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
        function scale(children, k) {
            var i = -1, n = children.length, child, area;
            while (++i < n) {
                area = (child = children[i]).value * (k < 0 ? 0 : k);
                child.area = isNaN(area) || area <= 0 ? 0 : area;
            }
        }
        function squarify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while ((n = remaining.length) > 0) {
                    row.push(child = remaining[n - 1]);
                    row.area += child.area;
                    if (mode !== "squarify" || (score = worst(row, u)) <= best) {
                        remaining.pop();
                        best = score;
                    }
                    else {
                        row.area -= row.pop().area;
                        position(row, u, rect, false);
                        u = Math.min(rect.dx, rect.dy);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, u, rect, true);
                    row.length = row.area = 0;
                }
                children.forEach(squarify);
            }
        }
        function stickify(node) {
            var children = node.children;
            if (children && children.length) {
                var rect = pad(node), remaining = children.slice(), child, row = [];
                scale(remaining, rect.dx * rect.dy / node.value);
                row.area = 0;
                while (child = remaining.pop()) {
                    row.push(child);
                    row.area += child.area;
                    if (child.z != null) {
                        position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
                        row.length = row.area = 0;
                    }
                }
                children.forEach(stickify);
            }
        }
        function worst(row, u) {
            var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
            while (++i < n) {
                if (!(r = row[i].area))
                    continue;
                if (r < rmin)
                    rmin = r;
                if (r > rmax)
                    rmax = r;
            }
            s *= s;
            u *= u;
            return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
        }
        function position(row, u, rect, flush) {
            var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
            if (u == rect.dx) {
                if (flush || v > rect.dy)
                    v = rect.dy;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dy = v;
                    x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
                }
                o.z = true;
                o.dx += rect.x + rect.dx - x;
                rect.y += v;
                rect.dy -= v;
            }
            else {
                if (flush || v > rect.dx)
                    v = rect.dx;
                while (++i < n) {
                    o = row[i];
                    o.x = x;
                    o.y = y;
                    o.dx = v;
                    y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
                }
                o.z = false;
                o.dy += rect.y + rect.dy - y;
                rect.x += v;
                rect.dx -= v;
            }
        }
        function treemap(d) {
            var nodes = stickies || hierarchy(d), root = nodes[0];
            root.x = root.y = 0;
            if (root.value)
                root.dx = size[0], root.dy = size[1];
            else
                root.dx = root.dy = 0;
            if (stickies)
                hierarchy.revalue(root);
            scale([root], root.dx * root.dy / root.value);
            (stickies ? stickify : squarify)(root);
            if (sticky)
                stickies = nodes;
            return nodes;
        }
        treemap.size = function (x) {
            if (!arguments.length)
                return size;
            size = x;
            return treemap;
        };
        treemap.padding = function (x) {
            if (!arguments.length)
                return padding;
            function padFunction(node) {
                var p = x.call(treemap, node, node.depth);
                return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [p, p, p, p] : p);
            }
            function padConstant(node) {
                return d3_layout_treemapPad(node, x);
            }
            var type;
            pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [x, x, x, x],
                padConstant) : padConstant;
            return treemap;
        };
        treemap.round = function (x) {
            if (!arguments.length)
                return round != Number;
            round = x ? Math.round : Number;
            return treemap;
        };
        treemap.sticky = function (x) {
            if (!arguments.length)
                return sticky;
            sticky = x;
            stickies = null;
            return treemap;
        };
        treemap.ratio = function (x) {
            if (!arguments.length)
                return ratio;
            ratio = x;
            return treemap;
        };
        treemap.mode = function (x) {
            if (!arguments.length)
                return mode;
            mode = x + "";
            return treemap;
        };
        return d3_layout_hierarchyRebind(treemap, hierarchy);
    };
    function d3_layout_treemapPadNull(node) {
        return {
            x: node.x,
            y: node.y,
            dx: node.dx,
            dy: node.dy
        };
    }
    function d3_layout_treemapPad(node, padding) {
        var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
        if (dx < 0) {
            x += dx / 2;
            dx = 0;
        }
        if (dy < 0) {
            y += dy / 2;
            dy = 0;
        }
        return {
            x: x,
            y: y,
            dx: dx,
            dy: dy
        };
    }
    d3.random = {
        normal: function (my, sigma) {
            var n = arguments.length;
            if (n < 2)
                sigma = 1;
            if (n < 1)
                my = 0;
            return function () {
                var x, y, r;
                do {
                    x = Math.random() * 2 - 1;
                    y = Math.random() * 2 - 1;
                    r = x * x + y * y;
                } while (!r || r > 1);
                return my + sigma * x * Math.sqrt(-2 * Math.log(r) / r);
            };
        },
        logNormal: function () {
            var random = d3.random.normal.apply(d3, arguments);
            return function () {
                return Math.exp(random());
            };
        },
        bates: function (m) {
            var random = d3.random.irwinHall(m);
            return function () {
                return random() / m;
            };
        },
        irwinHall: function (m) {
            return function () {
                for (var s = 0, j = 0; j < m; j++)
                    s += Math.random();
                return s;
            };
        }
    };
    d3.scale = {};
    function d3_scaleExtent(domain) {
        var start = domain[0], stop = domain[domain.length - 1];
        return start < stop ? [start, stop] : [stop, start];
    }
    function d3_scaleRange(scale) {
        return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
    }
    function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
        var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
        return function (x) {
            return i(u(x));
        };
    }
    function d3_scale_nice(domain, nice) {
        var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
        if (x1 < x0) {
            dx = i0, i0 = i1, i1 = dx;
            dx = x0, x0 = x1, x1 = dx;
        }
        domain[i0] = nice.floor(x0);
        domain[i1] = nice.ceil(x1);
        return domain;
    }
    function d3_scale_niceStep(step) {
        return step ? {
            floor: function (x) {
                return Math.floor(x / step) * step;
            },
            ceil: function (x) {
                return Math.ceil(x / step) * step;
            }
        } : d3_scale_niceIdentity;
    }
    var d3_scale_niceIdentity = {
        floor: d3_identity,
        ceil: d3_identity
    };
    function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
        var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
        if (domain[k] < domain[0]) {
            domain = domain.slice().reverse();
            range = range.slice().reverse();
        }
        while (++j <= k) {
            u.push(uninterpolate(domain[j - 1], domain[j]));
            i.push(interpolate(range[j - 1], range[j]));
        }
        return function (x) {
            var j = d3.bisect(domain, x, 1, k) - 1;
            return i[j](u[j](x));
        };
    }
    d3.scale.linear = function () {
        return d3_scale_linear([0, 1], [0, 1], d3_interpolate, false);
    };
    function d3_scale_linear(domain, range, interpolate, clamp) {
        var output, input;
        function rescale() {
            var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
            output = linear(domain, range, uninterpolate, interpolate);
            input = linear(range, domain, uninterpolate, d3_interpolate);
            return scale;
        }
        function scale(x) {
            return output(x);
        }
        scale.invert = function (y) {
            return input(y);
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(Number);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.rangeRound = function (x) {
            return scale.range(x).interpolate(d3_interpolateRound);
        };
        scale.clamp = function (x) {
            if (!arguments.length)
                return clamp;
            clamp = x;
            return rescale();
        };
        scale.interpolate = function (x) {
            if (!arguments.length)
                return interpolate;
            interpolate = x;
            return rescale();
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            d3_scale_linearNice(domain, m);
            return rescale();
        };
        scale.copy = function () {
            return d3_scale_linear(domain, range, interpolate, clamp);
        };
        return rescale();
    }
    function d3_scale_linearRebind(scale, linear) {
        return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
    }
    function d3_scale_linearNice(domain, m) {
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
        return domain;
    }
    function d3_scale_linearTickRange(domain, m) {
        if (m == null)
            m = 10;
        var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
        if (err <= .15)
            step *= 10;
        else if (err <= .35)
            step *= 5;
        else if (err <= .75)
            step *= 2;
        extent[0] = Math.ceil(extent[0] / step) * step;
        extent[1] = Math.floor(extent[1] / step) * step + step * .5;
        extent[2] = step;
        return extent;
    }
    function d3_scale_linearTicks(domain, m) {
        return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
    }
    function d3_scale_linearTickFormat(domain, m, format) {
        var range = d3_scale_linearTickRange(domain, m);
        if (format) {
            var match = d3_format_re.exec(format);
            match.shift();
            if (match[8] === "s") {
                var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
                if (!match[7])
                    match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
                match[8] = "f";
                format = d3.format(match.join(""));
                return function (d) {
                    return format(prefix.scale(d)) + prefix.symbol;
                };
            }
            if (!match[7])
                match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
            format = match.join("");
        }
        else {
            format = ",." + d3_scale_linearPrecision(range[2]) + "f";
        }
        return d3.format(format);
    }
    var d3_scale_linearFormatSignificant = {
        s: 1,
        g: 1,
        p: 1,
        r: 1,
        e: 1
    };
    function d3_scale_linearPrecision(value) {
        return -Math.floor(Math.log(value) / Math.LN10 + .01);
    }
    function d3_scale_linearFormatPrecision(type, range) {
        var p = d3_scale_linearPrecision(range[2]);
        return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
    }
    d3.scale.log = function () {
        return d3_scale_log(d3.scale.linear().domain([0, 1]), 10, true, [1, 10]);
    };
    function d3_scale_log(linear, base, positive, domain) {
        function log(x) {
            return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
        }
        function pow(x) {
            return positive ? Math.pow(base, x) : -Math.pow(base, -x);
        }
        function scale(x) {
            return linear(log(x));
        }
        scale.invert = function (x) {
            return pow(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            positive = x[0] >= 0;
            linear.domain((domain = x.map(Number)).map(log));
            return scale;
        };
        scale.base = function (_) {
            if (!arguments.length)
                return base;
            base = +_;
            linear.domain(domain.map(log));
            return scale;
        };
        scale.nice = function () {
            var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
            linear.domain(niced);
            domain = niced.map(pow);
            return scale;
        };
        scale.ticks = function () {
            var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
            if (isFinite(j - i)) {
                if (positive) {
                    for (; i < j; i++)
                        for (var k = 1; k < n; k++)
                            ticks.push(pow(i) * k);
                    ticks.push(pow(i));
                }
                else {
                    ticks.push(pow(i));
                    for (; i++ < j;)
                        for (var k = n - 1; k > 0; k--)
                            ticks.push(pow(i) * k);
                }
                for (i = 0; ticks[i] < u; i++) { }
                for (j = ticks.length; ticks[j - 1] > v; j--) { }
                ticks = ticks.slice(i, j);
            }
            return ticks;
        };
        scale.tickFormat = function (n, format) {
            if (!arguments.length)
                return d3_scale_logFormat;
            if (arguments.length < 2)
                format = d3_scale_logFormat;
            else if (typeof format !== "function")
                format = d3.format(format);
            var k = Math.max(1, base * n / scale.ticks().length);
            return function (d) {
                var i = d / pow(Math.round(log(d)));
                if (i * base < base - .5)
                    i *= base;
                return i <= k ? format(d) : "";
            };
        };
        scale.copy = function () {
            return d3_scale_log(linear.copy(), base, positive, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
        floor: function (x) {
            return -Math.ceil(-x);
        },
        ceil: function (x) {
            return -Math.floor(-x);
        }
    };
    d3.scale.pow = function () {
        return d3_scale_pow(d3.scale.linear(), 1, [0, 1]);
    };
    function d3_scale_pow(linear, exponent, domain) {
        var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
        function scale(x) {
            return linear(powp(x));
        }
        scale.invert = function (x) {
            return powb(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            linear.domain((domain = x.map(Number)).map(powp));
            return scale;
        };
        scale.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        scale.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        scale.nice = function (m) {
            return scale.domain(d3_scale_linearNice(domain, m));
        };
        scale.exponent = function (x) {
            if (!arguments.length)
                return exponent;
            powp = d3_scale_powPow(exponent = x);
            powb = d3_scale_powPow(1 / exponent);
            linear.domain(domain.map(powp));
            return scale;
        };
        scale.copy = function () {
            return d3_scale_pow(linear.copy(), exponent, domain);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_scale_powPow(e) {
        return function (x) {
            return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
        };
    }
    d3.scale.sqrt = function () {
        return d3.scale.pow().exponent(.5);
    };
    d3.scale.ordinal = function () {
        return d3_scale_ordinal([], {
            t: "range",
            a: [[]]
        });
    };
    function d3_scale_ordinal(domain, ranger) {
        var index, range, rangeBand;
        function scale(x) {
            return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
        }
        function steps(start, step) {
            return d3.range(domain.length).map(function (i) {
                return start + step * i;
            });
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = [];
            index = new d3_Map();
            var i = -1, n = x.length, xi;
            while (++i < n)
                if (!index.has(xi = x[i]))
                    index.set(xi, domain.push(xi));
            return scale[ranger.t].apply(scale, ranger.a);
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            rangeBand = 0;
            ranger = {
                t: "range",
                a: arguments
            };
            return scale;
        };
        scale.rangePoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2,
                0) : (stop - start) / (domain.length - 1 + padding);
            range = steps(start + step * padding / 2, step);
            rangeBand = 0;
            ranger = {
                t: "rangePoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundPoints = function (x, padding) {
            if (arguments.length < 2)
                padding = 0;
            var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2),
                0) : (stop - start) / (domain.length - 1 + padding) | 0;
            range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
            rangeBand = 0;
            ranger = {
                t: "rangeRoundPoints",
                a: arguments
            };
            return scale;
        };
        scale.rangeBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
            range = steps(start + step * outerPadding, step);
            if (reverse)
                range.reverse();
            rangeBand = step * (1 - padding);
            ranger = {
                t: "rangeBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeRoundBands = function (x, padding, outerPadding) {
            if (arguments.length < 2)
                padding = 0;
            if (arguments.length < 3)
                outerPadding = padding;
            var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
            range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
            if (reverse)
                range.reverse();
            rangeBand = Math.round(step * (1 - padding));
            ranger = {
                t: "rangeRoundBands",
                a: arguments
            };
            return scale;
        };
        scale.rangeBand = function () {
            return rangeBand;
        };
        scale.rangeExtent = function () {
            return d3_scaleExtent(ranger.a[0]);
        };
        scale.copy = function () {
            return d3_scale_ordinal(domain, ranger);
        };
        return scale.domain(domain);
    }
    d3.scale.category10 = function () {
        return d3.scale.ordinal().range(d3_category10);
    };
    d3.scale.category20 = function () {
        return d3.scale.ordinal().range(d3_category20);
    };
    d3.scale.category20b = function () {
        return d3.scale.ordinal().range(d3_category20b);
    };
    d3.scale.category20c = function () {
        return d3.scale.ordinal().range(d3_category20c);
    };
    var d3_category10 = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(d3_rgbString);
    var d3_category20 = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(d3_rgbString);
    var d3_category20b = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654].map(d3_rgbString);
    var d3_category20c = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(d3_rgbString);
    d3.scale.quantile = function () {
        return d3_scale_quantile([], []);
    };
    function d3_scale_quantile(domain, range) {
        var thresholds;
        function rescale() {
            var k = 0, q = range.length;
            thresholds = [];
            while (++k < q)
                thresholds[k - 1] = d3.quantile(domain, k / q);
            return scale;
        }
        function scale(x) {
            if (!isNaN(x = +x))
                return range[d3.bisect(thresholds, x)];
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.quantiles = function () {
            return thresholds;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return y < 0 ? [NaN, NaN] : [y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1]];
        };
        scale.copy = function () {
            return d3_scale_quantile(domain, range);
        };
        return rescale();
    }
    d3.scale.quantize = function () {
        return d3_scale_quantize(0, 1, [0, 1]);
    };
    function d3_scale_quantize(x0, x1, range) {
        var kx, i;
        function scale(x) {
            return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
        }
        function rescale() {
            kx = range.length / (x1 - x0);
            i = range.length - 1;
            return scale;
        }
        scale.domain = function (x) {
            if (!arguments.length)
                return [x0, x1];
            x0 = +x[0];
            x1 = +x[x.length - 1];
            return rescale();
        };
        scale.range = function (x) {
            if (!arguments.length)
                return range;
            range = x;
            return rescale();
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            y = y < 0 ? NaN : y / kx + x0;
            return [y, y + 1 / kx];
        };
        scale.copy = function () {
            return d3_scale_quantize(x0, x1, range);
        };
        return rescale();
    }
    d3.scale.threshold = function () {
        return d3_scale_threshold([.5], [0, 1]);
    };
    function d3_scale_threshold(domain, range) {
        function scale(x) {
            if (x <= x)
                return range[d3.bisect(domain, x)];
        }
        scale.domain = function (_) {
            if (!arguments.length)
                return domain;
            domain = _;
            return scale;
        };
        scale.range = function (_) {
            if (!arguments.length)
                return range;
            range = _;
            return scale;
        };
        scale.invertExtent = function (y) {
            y = range.indexOf(y);
            return [domain[y - 1], domain[y]];
        };
        scale.copy = function () {
            return d3_scale_threshold(domain, range);
        };
        return scale;
    }
    d3.scale.identity = function () {
        return d3_scale_identity([0, 1]);
    };
    function d3_scale_identity(domain) {
        function identity(x) {
            return +x;
        }
        identity.invert = identity;
        identity.domain = identity.range = function (x) {
            if (!arguments.length)
                return domain;
            domain = x.map(identity);
            return identity;
        };
        identity.ticks = function (m) {
            return d3_scale_linearTicks(domain, m);
        };
        identity.tickFormat = function (m, format) {
            return d3_scale_linearTickFormat(domain, m, format);
        };
        identity.copy = function () {
            return d3_scale_identity(domain);
        };
        return identity;
    }
    d3.svg = {};
    function d3_zero() {
        return 0;
    }
    d3.svg.arc = function () {
        var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
        function arc() {
            var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfpipipi, a1 = endAngle.apply(this, arguments) - halfpipipi, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
            if (r1 < r0)
                rc = r1, r1 = r0, r0 = rc;
            if (da >= tauepsilon)
                return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
            var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
            if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
                rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
                if (!cw)
                    p1 *= -1;
                if (r1)
                    p1 = d3_asin(rp / r1 * Math.sin(ap));
                if (r0)
                    p0 = d3_asin(rp / r0 * Math.sin(ap));
            }
            if (r1) {
                x0 = r1 * Math.cos(a0 + p1);
                y0 = r1 * Math.sin(a0 + p1);
                x1 = r1 * Math.cos(a1 - p1);
                y1 = r1 * Math.sin(a1 - p1);
                var l1 = Math.abs(a1 - a0 - 2 * p1) <= pipipi ? 0 : 1;
                if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
                    var h1 = (a0 + a1) / 2;
                    x0 = r1 * Math.cos(h1);
                    y0 = r1 * Math.sin(h1);
                    x1 = y1 = null;
                }
            }
            else {
                x0 = y0 = 0;
            }
            if (r0) {
                x2 = r0 * Math.cos(a1 - p0);
                y2 = r0 * Math.sin(a1 - p0);
                x3 = r0 * Math.cos(a0 + p0);
                y3 = r0 * Math.sin(a0 + p0);
                var l0 = Math.abs(a0 - a1 + 2 * p0) <= pipipi ? 0 : 1;
                if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
                    var h0 = (a0 + a1) / 2;
                    x2 = r0 * Math.cos(h0);
                    y2 = r0 * Math.sin(h0);
                    x3 = y3 = null;
                }
            }
            else {
                x2 = y2 = 0;
            }
            if (da > epsilon && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
                cr = r0 < r1 ^ cw ? 0 : 1;
                var rc1 = rc, rc0 = rc;
                if (da < pipipi) {
                    var oc = x3 == null ? [x2, y2] : x1 == null ? [x0, y0] : d3_geom_polygonIntersect([x0, y0], [x3, y3], [x1, y1], [x2, y2]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
                    rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
                    rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
                }
                if (x1 != null) {
                    var t30 = d3_svg_arcCornerTangents(x3 == null ? [x2, y2] : [x3, y3], [x0, y0], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([x1, y1], [x2, y2], r1, rc1, cw);
                    if (rc === rc1) {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
                    }
                    else {
                        path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
                    }
                }
                else {
                    path.push("M", x0, ",", y0);
                }
                if (x3 != null) {
                    var t03 = d3_svg_arcCornerTangents([x0, y0], [x3, y3], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([x2, y2], x1 == null ? [x0, y0] : [x1, y1], r0, -rc0, cw);
                    if (rc === rc0) {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    }
                    else {
                        path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
                    }
                }
                else {
                    path.push("L", x2, ",", y2);
                }
            }
            else {
                path.push("M", x0, ",", y0);
                if (x1 != null)
                    path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
                path.push("L", x2, ",", y2);
                if (x3 != null)
                    path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
            }
            path.push("Z");
            return path.join("");
        }
        function circleSegment(r1, cw) {
            return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
        }
        arc.innerRadius = function (v) {
            if (!arguments.length)
                return innerRadius;
            innerRadius = d3_functor(v);
            return arc;
        };
        arc.outerRadius = function (v) {
            if (!arguments.length)
                return outerRadius;
            outerRadius = d3_functor(v);
            return arc;
        };
        arc.cornerRadius = function (v) {
            if (!arguments.length)
                return cornerRadius;
            cornerRadius = d3_functor(v);
            return arc;
        };
        arc.padRadius = function (v) {
            if (!arguments.length)
                return padRadius;
            padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
            return arc;
        };
        arc.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return arc;
        };
        arc.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return arc;
        };
        arc.padAngle = function (v) {
            if (!arguments.length)
                return padAngle;
            padAngle = d3_functor(v);
            return arc;
        };
        arc.centroid = function () {
            var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfpipipi;
            return [Math.cos(a) * r, Math.sin(a) * r];
        };
        return arc;
    };
    var d3_svg_arcAuto = "auto";
    function d3_svg_arcInnerRadius(d) {
        return d.innerRadius;
    }
    function d3_svg_arcOuterRadius(d) {
        return d.outerRadius;
    }
    function d3_svg_arcStartAngle(d) {
        return d.startAngle;
    }
    function d3_svg_arcEndAngle(d) {
        return d.endAngle;
    }
    function d3_svg_arcPadAngle(d) {
        return d && d.padAngle;
    }
    function d3_svg_arcSweep(x0, y0, x1, y1) {
        return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
    }
    function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
        var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
        if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
            cx0 = cx1, cy0 = cy1;
        return [[cx0 - ox, cy0 - oy], [cx0 * r1 / r, cy0 * r1 / r]];
    }
    function d3_svg_line(projection) {
        var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
        function line(data) {
            var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
            function segment() {
                segments.push("M", interpolate(projection(points), tension));
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points.push([+fx.call(this, d, i), +fy.call(this, d, i)]);
                }
                else if (points.length) {
                    segment();
                    points = [];
                }
            }
            if (points.length)
                segment();
            return segments.length ? segments.join("") : null;
        }
        line.x = function (_) {
            if (!arguments.length)
                return x;
            x = _;
            return line;
        };
        line.y = function (_) {
            if (!arguments.length)
                return y;
            y = _;
            return line;
        };
        line.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return line;
        };
        line.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === "function")
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            return line;
        };
        line.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return line;
        };
        return line;
    }
    d3.svg.line = function () {
        return d3_svg_line(d3_identity);
    };
    var d3_svg_lineInterpolators = d3.map({
        linear: d3_svg_lineLinear,
        "linear-closed": d3_svg_lineLinearClosed,
        step: d3_svg_lineStep,
        "step-before": d3_svg_lineStepBefore,
        "step-after": d3_svg_lineStepAfter,
        basis: d3_svg_lineBasis,
        "basis-open": d3_svg_lineBasisOpen,
        "basis-closed": d3_svg_lineBasisClosed,
        bundle: d3_svg_lineBundle,
        cardinal: d3_svg_lineCardinal,
        "cardinal-open": d3_svg_lineCardinalOpen,
        "cardinal-closed": d3_svg_lineCardinalClosed,
        monotone: d3_svg_lineMonotone
    });
    d3_svg_lineInterpolators.forEach(function (key, value) {
        value.key = key;
        value.closed = /-closed$/.test(key);
    });
    function d3_svg_lineLinear(points) {
        return points.length > 1 ? points.join("L") : points + "Z";
    }
    function d3_svg_lineLinearClosed(points) {
        return points.join("L") + "Z";
    }
    function d3_svg_lineStep(points) {
        var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
        while (++i < n)
            path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
        if (n > 1)
            path.push("H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepBefore(points) {
        var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
        while (++i < n)
            path.push("V", (p = points[i])[1], "H", p[0]);
        return path.join("");
    }
    function d3_svg_lineStepAfter(points) {
        var i = 0, n = points.length, p = points[0], path = [p[0], ",", p[1]];
        while (++i < n)
            path.push("H", (p = points[i])[0], "V", p[1]);
        return path.join("");
    }
    function d3_svg_lineCardinalOpen(points, tension) {
        return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineCardinalClosed(points, tension) {
        return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]),
            points), d3_svg_lineCardinalTangents([points[points.length - 2]].concat(points, [points[1]]), tension));
    }
    function d3_svg_lineCardinal(points, tension) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
    }
    function d3_svg_lineHermite(points, tangents) {
        if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
            return d3_svg_lineLinear(points);
        }
        var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
        if (quad) {
            path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
            p0 = points[1];
            pi = 2;
        }
        if (tangents.length > 1) {
            t = tangents[1];
            p = points[pi];
            pi++;
            path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            for (var i = 2; i < tangents.length; i++, pi++) {
                p = points[pi];
                t = tangents[i];
                path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
            }
        }
        if (quad) {
            var lp = points[pi];
            path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
        }
        return path;
    }
    function d3_svg_lineCardinalTangents(points, tension) {
        var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
        while (++i < n) {
            p0 = p1;
            p1 = p2;
            p2 = points[i];
            tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);
        }
        return tangents;
    }
    function d3_svg_lineBasis(points) {
        if (points.length < 3)
            return d3_svg_lineLinear(points);
        var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [x0, x0, x0, (pi = points[1])[0]], py = [y0, y0, y0, pi[1]], path = [x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        points.push(points[n - 1]);
        while (++i <= n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        points.pop();
        path.push("L", pi);
        return path.join("");
    }
    function d3_svg_lineBasisOpen(points) {
        if (points.length < 4)
            return d3_svg_lineLinear(points);
        var path = [], i = -1, n = points.length, pi, px = [0], py = [0];
        while (++i < 3) {
            pi = points[i];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
        --i;
        while (++i < n) {
            pi = points[i];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBasisClosed(points) {
        var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
        while (++i < 4) {
            pi = points[i % n];
            px.push(pi[0]);
            py.push(pi[1]);
        }
        path = [d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py)];
        --i;
        while (++i < m) {
            pi = points[i % n];
            px.shift();
            px.push(pi[0]);
            py.shift();
            py.push(pi[1]);
            d3_svg_lineBasisBezier(path, px, py);
        }
        return path.join("");
    }
    function d3_svg_lineBundle(points, tension) {
        var n = points.length - 1;
        if (n) {
            var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
            while (++i <= n) {
                p = points[i];
                t = i / n;
                p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
                p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
            }
        }
        return d3_svg_lineBasis(points);
    }
    function d3_svg_lineDot4(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    }
    var d3_svg_lineBasisBezier1 = [0, 2 / 3, 1 / 3, 0], d3_svg_lineBasisBezier2 = [0, 1 / 3, 2 / 3, 0], d3_svg_lineBasisBezier3 = [0, 1 / 6, 2 / 3, 1 / 6];
    function d3_svg_lineBasisBezier(path, x, y) {
        path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
    }
    function d3_svg_lineSlope(p0, p1) {
        return (p1[1] - p0[1]) / (p1[0] - p0[0]);
    }
    function d3_svg_lineFiniteDifferences(points) {
        var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
        while (++i < j) {
            m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
        }
        m[i] = d;
        return m;
    }
    function d3_svg_lineMonotoneTangents(points) {
        var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
        while (++i < j) {
            d = d3_svg_lineSlope(points[i], points[i + 1]);
            if (abs(d) < epsilon) {
                m[i] = m[i + 1] = 0;
            }
            else {
                a = m[i] / d;
                b = m[i + 1] / d;
                s = a * a + b * b;
                if (s > 9) {
                    s = d * 3 / Math.sqrt(s);
                    m[i] = s * a;
                    m[i + 1] = s * b;
                }
            }
        }
        i = -1;
        while (++i <= j) {
            s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
            tangents.push([s || 0, m[i] * s || 0]);
        }
        return tangents;
    }
    function d3_svg_lineMonotone(points) {
        return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
    }
    d3.svg.line.radial = function () {
        var line = d3_svg_line(d3_svg_lineRadial);
        line.radius = line.x, delete line.x;
        line.angle = line.y, delete line.y;
        return line;
    };
    function d3_svg_lineRadial(points) {
        var point, i = -1, n = points.length, r, a;
        while (++i < n) {
            point = points[i];
            r = point[0];
            a = point[1] - halfpipipi;
            point[0] = r * Math.cos(a);
            point[1] = r * Math.sin(a);
        }
        return points;
    }
    function d3_svg_area(projection) {
        var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
        function area(data) {
            var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function () {
                return x;
            } : d3_functor(x1), fy1 = y0 === y1 ? function () {
                return y;
            } : d3_functor(y1), x, y;
            function segment() {
                segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
            }
            while (++i < n) {
                if (defined.call(this, d = data[i], i)) {
                    points0.push([x = +fx0.call(this, d, i), y = +fy0.call(this, d, i)]);
                    points1.push([+fx1.call(this, d, i), +fy1.call(this, d, i)]);
                }
                else if (points0.length) {
                    segment();
                    points0 = [];
                    points1 = [];
                }
            }
            if (points0.length)
                segment();
            return segments.length ? segments.join("") : null;
        }
        area.x = function (_) {
            if (!arguments.length)
                return x1;
            x0 = x1 = _;
            return area;
        };
        area.x0 = function (_) {
            if (!arguments.length)
                return x0;
            x0 = _;
            return area;
        };
        area.x1 = function (_) {
            if (!arguments.length)
                return x1;
            x1 = _;
            return area;
        };
        area.y = function (_) {
            if (!arguments.length)
                return y1;
            y0 = y1 = _;
            return area;
        };
        area.y0 = function (_) {
            if (!arguments.length)
                return y0;
            y0 = _;
            return area;
        };
        area.y1 = function (_) {
            if (!arguments.length)
                return y1;
            y1 = _;
            return area;
        };
        area.defined = function (_) {
            if (!arguments.length)
                return defined;
            defined = _;
            return area;
        };
        area.interpolate = function (_) {
            if (!arguments.length)
                return interpolateKey;
            if (typeof _ === "function")
                interpolateKey = interpolate = _;
            else
                interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
            interpolateReverse = interpolate.reverse || interpolate;
            L = interpolate.closed ? "M" : "L";
            return area;
        };
        area.tension = function (_) {
            if (!arguments.length)
                return tension;
            tension = _;
            return area;
        };
        return area;
    }
    d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
    d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
    d3.svg.area = function () {
        return d3_svg_area(d3_identity);
    };
    d3.svg.area.radial = function () {
        var area = d3_svg_area(d3_svg_lineRadial);
        area.radius = area.x, delete area.x;
        area.innerRadius = area.x0, delete area.x0;
        area.outerRadius = area.x1, delete area.x1;
        area.angle = area.y, delete area.y;
        area.startAngle = area.y0, delete area.y0;
        area.endAngle = area.y1, delete area.y1;
        return area;
    };
    d3.svg.chord = function () {
        var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
        function chord(d, i) {
            var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
            return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
        }
        function subgroup(self, f, d, i) {
            var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfpipipi, a1 = endAngle.call(self, subgroup, i) - halfpipipi;
            return {
                r: r,
                a0: a0,
                a1: a1,
                p0: [r * Math.cos(a0), r * Math.sin(a0)],
                p1: [r * Math.cos(a1), r * Math.sin(a1)]
            };
        }
        function equals(a, b) {
            return a.a0 == b.a0 && a.a1 == b.a1;
        }
        function arc(r, p, a) {
            return "A" + r + "," + r + " 0 " + +(a > pipipi) + ",1 " + p;
        }
        function curve(r0, p0, r1, p1) {
            return "Q 0,0 " + p1;
        }
        chord.radius = function (v) {
            if (!arguments.length)
                return radius;
            radius = d3_functor(v);
            return chord;
        };
        chord.source = function (v) {
            if (!arguments.length)
                return source;
            source = d3_functor(v);
            return chord;
        };
        chord.target = function (v) {
            if (!arguments.length)
                return target;
            target = d3_functor(v);
            return chord;
        };
        chord.startAngle = function (v) {
            if (!arguments.length)
                return startAngle;
            startAngle = d3_functor(v);
            return chord;
        };
        chord.endAngle = function (v) {
            if (!arguments.length)
                return endAngle;
            endAngle = d3_functor(v);
            return chord;
        };
        return chord;
    };
    function d3_svg_chordRadius(d) {
        return d.radius;
    }
    d3.svg.diagonal = function () {
        var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
        function diagonal(d, i) {
            var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [p0, {
                    x: p0.x,
                    y: m
                }, {
                    x: p3.x,
                    y: m
                }, p3];
            p = p.map(projection);
            return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
        }
        diagonal.source = function (x) {
            if (!arguments.length)
                return source;
            source = d3_functor(x);
            return diagonal;
        };
        diagonal.target = function (x) {
            if (!arguments.length)
                return target;
            target = d3_functor(x);
            return diagonal;
        };
        diagonal.projection = function (x) {
            if (!arguments.length)
                return projection;
            projection = x;
            return diagonal;
        };
        return diagonal;
    };
    function d3_svg_diagonalProjection(d) {
        return [d.x, d.y];
    }
    d3.svg.diagonal.radial = function () {
        var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
        diagonal.projection = function (x) {
            return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
        };
        return diagonal;
    };
    function d3_svg_diagonalRadialProjection(projection) {
        return function () {
            var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfpipipi;
            return [r * Math.cos(a), r * Math.sin(a)];
        };
    }
    d3.svg.symbol = function () {
        var type = d3_svg_symbolType, size = d3_svg_symbolSize;
        function symbol(d, i) {
            return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
        }
        symbol.type = function (x) {
            if (!arguments.length)
                return type;
            type = d3_functor(x);
            return symbol;
        };
        symbol.size = function (x) {
            if (!arguments.length)
                return size;
            size = d3_functor(x);
            return symbol;
        };
        return symbol;
    };
    function d3_svg_symbolSize() {
        return 64;
    }
    function d3_svg_symbolType() {
        return "circle";
    }
    function d3_svg_symbolCircle(size) {
        var r = Math.sqrt(size / pipipi);
        return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
    }
    var d3_svg_symbols = d3.map({
        circle: d3_svg_symbolCircle,
        cross: function (size) {
            var r = Math.sqrt(size / 5) / 2;
            return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
        },
        diamond: function (size) {
            var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
            return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
        },
        square: function (size) {
            var r = Math.sqrt(size) / 2;
            return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        },
        "triangle-down": function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
        },
        "triangle-up": function (size) {
            var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
            return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
        }
    });
    d3.svg.symbolTypes = d3_svg_symbols.keys();
    var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
    d3_selectionPrototype.transition = function (name) {
        var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
            time: Date.now(),
            ease: d3_ease_cubicInOut,
            delay: 0,
            duration: 250
        };
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i])
                    d3_transitionNode(node, i, ns, id, transition);
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_selectionPrototype.interrupt = function (name) {
        return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
    };
    var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
    function d3_selection_interruptNS(ns) {
        return function () {
            var lock, activeId, active;
            if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
                active.timer.c = null;
                active.timer.t = NaN;
                if (--lock.count)
                    delete lock[activeId];
                else
                    delete this[ns];
                lock.active += .5;
                active.event && active.event.interrupt.call(this, this.__data__, active.index);
            }
        };
    }
    function d3_transition(groups, ns, id) {
        d3_subclass(groups, d3_transitionPrototype);
        groups.namespace = ns;
        groups.id = id;
        return groups;
    }
    var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
    d3_transitionPrototype.call = d3_selectionPrototype.call;
    d3_transitionPrototype.empty = d3_selectionPrototype.empty;
    d3_transitionPrototype.node = d3_selectionPrototype.node;
    d3_transitionPrototype.size = d3_selectionPrototype.size;
    d3.transition = function (selection, name) {
        return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
    };
    d3.transition.prototype = d3_transitionPrototype;
    d3_transitionPrototype.select = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
        selector = d3_selection_selector(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
                    if ("__data__" in node)
                        subnode.__data__ = node.__data__;
                    d3_transitionNode(subnode, i, ns, id, node[ns][id]);
                    subgroup.push(subnode);
                }
                else {
                    subgroup.push(null);
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.selectAll = function (selector) {
        var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
        selector = d3_selection_selectorAll(selector);
        for (var j = -1, m = this.length; ++j < m;) {
            for (var group = this[j], i = -1, n = group.length; ++i < n;) {
                if (node = group[i]) {
                    transition = node[ns][id];
                    subnodes = selector.call(node, node.__data__, i, j);
                    subgroups.push(subgroup = []);
                    for (var k = -1, o = subnodes.length; ++k < o;) {
                        if (subnode = subnodes[k])
                            d3_transitionNode(subnode, k, ns, id, transition);
                        subgroup.push(subnode);
                    }
                }
            }
        }
        return d3_transition(subgroups, ns, id);
    };
    d3_transitionPrototype.filter = function (filter) {
        var subgroups = [], subgroup, group, node;
        if (typeof filter !== "function")
            filter = d3_selection_filter(filter);
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
                    subgroup.push(node);
                }
            }
        }
        return d3_transition(subgroups, this.namespace, this.id);
    };
    d3_transitionPrototype.tween = function (name, tween) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2)
            return this.node()[ns][id].tween.get(name);
        return d3_selection_each(this, tween == null ? function (node) {
            node[ns][id].tween.remove(name);
        } : function (node) {
            node[ns][id].tween.set(name, tween);
        });
    };
    function d3_transition_tween(groups, name, value, tween) {
        var id = groups.id, ns = groups.namespace;
        return d3_selection_each(groups, typeof value === "function" ? function (node, i, j) {
            node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
        } : (value = tween(value), function (node) {
            node[ns][id].tween.set(name, value);
        }));
    }
    d3_transitionPrototype.attr = function (nameNS, value) {
        if (arguments.length < 2) {
            for (value in nameNS)
                this.attr(value, nameNS[value]);
            return this;
        }
        var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
        function attrNull() {
            this.removeAttribute(name);
        }
        function attrNullNS() {
            this.removeAttributeNS(name.space, name.local);
        }
        function attrTween(b) {
            return b == null ? attrNull : (b += "", function () {
                var a = this.getAttribute(name), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttribute(name, i(t));
                });
            });
        }
        function attrTweenNS(b) {
            return b == null ? attrNullNS : (b += "", function () {
                var a = this.getAttributeNS(name.space, name.local), i;
                return a !== b && (i = interpolate(a, b), function (t) {
                    this.setAttributeNS(name.space, name.local, i(t));
                });
            });
        }
        return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.attrTween = function (nameNS, tween) {
        var name = d3.ns.qualify(nameNS);
        function attrTween(d, i) {
            var f = tween.call(this, d, i, this.getAttribute(name));
            return f && function (t) {
                this.setAttribute(name, f(t));
            };
        }
        function attrTweenNS(d, i) {
            var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
            return f && function (t) {
                this.setAttributeNS(name.space, name.local, f(t));
            };
        }
        return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
    };
    d3_transitionPrototype.style = function (name, value, priority) {
        var n = arguments.length;
        if (n < 3) {
            if (typeof name !== "string") {
                if (n < 2)
                    value = "";
                for (priority in name)
                    this.style(priority, name[priority], value);
                return this;
            }
            priority = "";
        }
        function styleNull() {
            this.style.removeProperty(name);
        }
        function styleString(b) {
            return b == null ? styleNull : (b += "", function () {
                var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
                return a !== b && (i = d3_interpolate(a, b), function (t) {
                    this.style.setProperty(name, i(t), priority);
                });
            });
        }
        return d3_transition_tween(this, "style." + name, value, styleString);
    };
    d3_transitionPrototype.styleTween = function (name, tween, priority) {
        if (arguments.length < 3)
            priority = "";
        function styleTween(d, i) {
            var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
            return f && function (t) {
                this.style.setProperty(name, f(t), priority);
            };
        }
        return this.tween("style." + name, styleTween);
    };
    d3_transitionPrototype.text = function (value) {
        return d3_transition_tween(this, "text", value, d3_transition_text);
    };
    function d3_transition_text(b) {
        if (b == null)
            b = "";
        return function () {
            this.textContent = b;
        };
    }
    d3_transitionPrototype.remove = function () {
        var ns = this.namespace;
        return this.each("end.transition", function () {
            var p;
            if (this[ns].count < 2 && (p = this.parentNode))
                p.removeChild(this);
        });
    };
    d3_transitionPrototype.ease = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].ease;
        if (typeof value !== "function")
            value = d3.ease.apply(d3, arguments);
        return d3_selection_each(this, function (node) {
            node[ns][id].ease = value;
        });
    };
    d3_transitionPrototype.delay = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].delay;
        return d3_selection_each(this, typeof value === "function" ? function (node, i, j) {
            node[ns][id].delay = +value.call(node, node.__data__, i, j);
        } : (value = +value, function (node) {
            node[ns][id].delay = value;
        }));
    };
    d3_transitionPrototype.duration = function (value) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 1)
            return this.node()[ns][id].duration;
        return d3_selection_each(this, typeof value === "function" ? function (node, i, j) {
            node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
        } : (value = Math.max(1, value), function (node) {
            node[ns][id].duration = value;
        }));
    };
    d3_transitionPrototype.each = function (type, listener) {
        var id = this.id, ns = this.namespace;
        if (arguments.length < 2) {
            var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
            try {
                d3_transitionInheritId = id;
                d3_selection_each(this, function (node, i, j) {
                    d3_transitionInherit = node[ns][id];
                    type.call(node, node.__data__, i, j);
                });
            }
            finally {
                d3_transitionInherit = inherit;
                d3_transitionInheritId = inheritId;
            }
        }
        else {
            d3_selection_each(this, function (node) {
                var transition = node[ns][id];
                (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
            });
        }
        return this;
    };
    d3_transitionPrototype.transition = function () {
        var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
        for (var j = 0, m = this.length; j < m; j++) {
            subgroups.push(subgroup = []);
            for (var group = this[j], i = 0, n = group.length; i < n; i++) {
                if (node = group[i]) {
                    transition = node[ns][id0];
                    d3_transitionNode(node, i, ns, id1, {
                        time: transition.time,
                        ease: transition.ease,
                        delay: transition.delay + transition.duration,
                        duration: transition.duration
                    });
                }
                subgroup.push(node);
            }
        }
        return d3_transition(subgroups, ns, id1);
    };
    function d3_transitionNamespace(name) {
        return name == null ? "__transition__" : "__transition_" + name + "__";
    }
    function d3_transitionNode(node, i, ns, id, inherit) {
        var lock = node[ns] || (node[ns] = {
            active: 0,
            count: 0
        }), transition = lock[id], time, timer, duration, ease, tweens;
        function schedule(elapsed) {
            var delay = transition.delay;
            timer.t = delay + time;
            if (delay <= elapsed)
                return start(elapsed - delay);
            timer.c = start;
        }
        function start(elapsed) {
            var activeId = lock.active, active = lock[activeId];
            if (active) {
                active.timer.c = null;
                active.timer.t = NaN;
                --lock.count;
                delete lock[activeId];
                active.event && active.event.interrupt.call(node, node.__data__, active.index);
            }
            for (var cancelId in lock) {
                if (+cancelId < id) {
                    var cancel = lock[cancelId];
                    cancel.timer.c = null;
                    cancel.timer.t = NaN;
                    --lock.count;
                    delete lock[cancelId];
                }
            }
            timer.c = tick;
            d3_timer(function () {
                if (timer.c && tick(elapsed || 1)) {
                    timer.c = null;
                    timer.t = NaN;
                }
                return 1;
            }, 0, time);
            lock.active = id;
            transition.event && transition.event.start.call(node, node.__data__, i);
            tweens = [];
            transition.tween.forEach(function (key, value) {
                if (value = value.call(node, node.__data__, i)) {
                    tweens.push(value);
                }
            });
            ease = transition.ease;
            duration = transition.duration;
        }
        function tick(elapsed) {
            var t = elapsed / duration, e = ease(t), n = tweens.length;
            while (n > 0) {
                tweens[--n].call(node, e);
            }
            if (t >= 1) {
                transition.event && transition.event.end.call(node, node.__data__, i);
                if (--lock.count)
                    delete lock[id];
                else
                    delete node[ns];
                return 1;
            }
        }
        if (!transition) {
            time = inherit.time;
            timer = d3_timer(schedule, 0, time);
            transition = lock[id] = {
                tween: new d3_Map(),
                time: time,
                timer: timer,
                delay: inherit.delay,
                duration: inherit.duration,
                ease: inherit.ease,
                index: i
            };
            inherit = null;
            ++lock.count;
        }
    }
    d3.svg.axis = function () {
        var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [10], tickValues = null, tickFormat_;
        function axis(g) {
            g.each(function () {
                var g = d3.select(this);
                var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
                var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", epsilon), tickExit = d3.transition(tick.exit()).style("opacity", epsilon).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
                var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([0]), pathUpdate = (path.enter().append("path").attr("class", "domain"),
                    d3.transition(path));
                tickEnter.append("line");
                tickEnter.append("text");
                var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
                if (orient === "bottom" || orient === "top") {
                    tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
                    text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
                    pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
                }
                else {
                    tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
                    text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
                    pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
                }
                lineEnter.attr(y2, sign * innerTickSize);
                textEnter.attr(y1, sign * tickSpacing);
                lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
                textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
                if (scale1.rangeBand) {
                    var x = scale1, dx = x.rangeBand() / 2;
                    scale0 = scale1 = function (d) {
                        return x(d) + dx;
                    };
                }
                else if (scale0.rangeBand) {
                    scale0 = scale1;
                }
                else {
                    tickExit.call(tickTransform, scale1, scale0);
                }
                tickEnter.call(tickTransform, scale0, scale1);
                tickUpdate.call(tickTransform, scale1, scale1);
            });
        }
        axis.scale = function (x) {
            if (!arguments.length)
                return scale;
            scale = x;
            return axis;
        };
        axis.orient = function (x) {
            if (!arguments.length)
                return orient;
            orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
            return axis;
        };
        axis.ticks = function () {
            if (!arguments.length)
                return tickArguments_;
            tickArguments_ = d3_array(arguments);
            return axis;
        };
        axis.tickValues = function (x) {
            if (!arguments.length)
                return tickValues;
            tickValues = x;
            return axis;
        };
        axis.tickFormat = function (x) {
            if (!arguments.length)
                return tickFormat_;
            tickFormat_ = x;
            return axis;
        };
        axis.tickSize = function (x) {
            var n = arguments.length;
            if (!n)
                return innerTickSize;
            innerTickSize = +x;
            outerTickSize = +arguments[n - 1];
            return axis;
        };
        axis.innerTickSize = function (x) {
            if (!arguments.length)
                return innerTickSize;
            innerTickSize = +x;
            return axis;
        };
        axis.outerTickSize = function (x) {
            if (!arguments.length)
                return outerTickSize;
            outerTickSize = +x;
            return axis;
        };
        axis.tickPadding = function (x) {
            if (!arguments.length)
                return tickPadding;
            tickPadding = +x;
            return axis;
        };
        axis.tickSubdivide = function () {
            return arguments.length && axis;
        };
        return axis;
    };
    var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
        top: 1,
        right: 1,
        bottom: 1,
        left: 1
    };
    function d3_svg_axisX(selection, x0, x1) {
        selection.attr("transform", function (d) {
            var v0 = x0(d);
            return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
        });
    }
    function d3_svg_axisY(selection, y0, y1) {
        selection.attr("transform", function (d) {
            var v0 = y0(d);
            return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
        });
    }
    d3.svg.brush = function () {
        var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [0, 0], yExtent = [0, 0], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
        function brush(g) {
            g.each(function () {
                var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
                var background = g.selectAll(".background").data([0]);
                background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
                g.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
                var resize = g.selectAll(".resize").data(resizes, d3_identity);
                resize.exit().remove();
                resize.enter().append("g").attr("class", function (d) {
                    return "resize " + d;
                }).style("cursor", function (d) {
                    return d3_svg_brushCursor[d];
                }).append("rect").attr("x", function (d) {
                    return /[ew]$/.test(d) ? -3 : null;
                }).attr("y", function (d) {
                    return /^[ns]/.test(d) ? -3 : null;
                }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
                resize.style("display", brush.empty() ? "none" : null);
                var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
                if (x) {
                    range = d3_scaleRange(x);
                    backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
                    redrawX(gUpdate);
                }
                if (y) {
                    range = d3_scaleRange(y);
                    backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
                    redrawY(gUpdate);
                }
                redraw(gUpdate);
            });
        }
        brush.event = function (g) {
            g.each(function () {
                var event_ = event.of(this, arguments), extent1 = {
                    x: xExtent,
                    y: yExtent,
                    i: xExtentDomain,
                    j: yExtentDomain
                }, extent0 = this.__chart__ || extent1;
                this.__chart__ = extent1;
                if (d3_transitionInheritId) {
                    d3.select(this).transition().each("start.brush", function () {
                        xExtentDomain = extent0.i;
                        yExtentDomain = extent0.j;
                        xExtent = extent0.x;
                        yExtent = extent0.y;
                        event_({
                            type: "brushstart"
                        });
                    }).tween("brush:brush", function () {
                        var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
                        xExtentDomain = yExtentDomain = null;
                        return function (t) {
                            xExtent = extent1.x = xi(t);
                            yExtent = extent1.y = yi(t);
                            event_({
                                type: "brush",
                                mode: "resize"
                            });
                        };
                    }).each("end.brush", function () {
                        xExtentDomain = extent1.i;
                        yExtentDomain = extent1.j;
                        event_({
                            type: "brush",
                            mode: "resize"
                        });
                        event_({
                            type: "brushend"
                        });
                    });
                }
                else {
                    event_({
                        type: "brushstart"
                    });
                    event_({
                        type: "brush",
                        mode: "resize"
                    });
                    event_({
                        type: "brushend"
                    });
                }
            });
        };
        function redraw(g) {
            g.selectAll(".resize").attr("transform", function (d) {
                return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
            });
        }
        function redrawX(g) {
            g.select(".extent").attr("x", xExtent[0]);
            g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
        }
        function redrawY(g) {
            g.select(".extent").attr("y", yExtent[0]);
            g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
        }
        function brushstart() {
            var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
            var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
            if (d3.event.changedTouches) {
                w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
            }
            else {
                w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
            }
            g.interrupt().selectAll("*").interrupt();
            if (dragging) {
                origin[0] = xExtent[0] - origin[0];
                origin[1] = yExtent[0] - origin[1];
            }
            else if (resizing) {
                var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
                offset = [xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1]];
                origin[0] = xExtent[ex];
                origin[1] = yExtent[ey];
            }
            else if (d3.event.altKey)
                center = origin.slice();
            g.style("pointer-events", "none").selectAll(".resize").style("display", null);
            d3.select("body").style("cursor", eventTarget.style("cursor"));
            event_({
                type: "brushstart"
            });
            brushmove();
            function keydown() {
                if (d3.event.keyCode == 32) {
                    if (!dragging) {
                        center = null;
                        origin[0] -= xExtent[1];
                        origin[1] -= yExtent[1];
                        dragging = 2;
                    }
                    d3_eventPreventDefault();
                }
            }
            function keyup() {
                if (d3.event.keyCode == 32 && dragging == 2) {
                    origin[0] += xExtent[1];
                    origin[1] += yExtent[1];
                    dragging = 0;
                    d3_eventPreventDefault();
                }
            }
            function brushmove() {
                var point = d3.mouse(target), moved = false;
                if (offset) {
                    point[0] += offset[0];
                    point[1] += offset[1];
                }
                if (!dragging) {
                    if (d3.event.altKey) {
                        if (!center)
                            center = [(xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2];
                        origin[0] = xExtent[+(point[0] < center[0])];
                        origin[1] = yExtent[+(point[1] < center[1])];
                    }
                    else
                        center = null;
                }
                if (resizingX && move1(point, x, 0)) {
                    redrawX(g);
                    moved = true;
                }
                if (resizingY && move1(point, y, 1)) {
                    redrawY(g);
                    moved = true;
                }
                if (moved) {
                    redraw(g);
                    event_({
                        type: "brush",
                        mode: dragging ? "move" : "resize"
                    });
                }
            }
            function move1(point, scale, i) {
                var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
                if (dragging) {
                    r0 -= position;
                    r1 -= size + position;
                }
                min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
                if (dragging) {
                    max = (min += position) + size;
                }
                else {
                    if (center)
                        position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
                    if (position < min) {
                        max = min;
                        min = position;
                    }
                    else {
                        max = position;
                    }
                }
                if (extent[0] != min || extent[1] != max) {
                    if (i)
                        yExtentDomain = null;
                    else
                        xExtentDomain = null;
                    extent[0] = min;
                    extent[1] = max;
                    return true;
                }
            }
            function brushend() {
                brushmove();
                g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
                d3.select("body").style("cursor", null);
                w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
                dragRestore();
                event_({
                    type: "brushend"
                });
            }
        }
        brush.x = function (z) {
            if (!arguments.length)
                return x;
            x = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.y = function (z) {
            if (!arguments.length)
                return y;
            y = z;
            resizes = d3_svg_brushResizes[!x << 1 | !y];
            return brush;
        };
        brush.clamp = function (z) {
            if (!arguments.length)
                return x && y ? [xClamp, yClamp] : x ? xClamp : y ? yClamp : null;
            if (x && y)
                xClamp = !!z[0], yClamp = !!z[1];
            else if (x)
                xClamp = !!z;
            else if (y)
                yClamp = !!z;
            return brush;
        };
        brush.extent = function (z) {
            var x0, x1, y0, y1, t;
            if (!arguments.length) {
                if (x) {
                    if (xExtentDomain) {
                        x0 = xExtentDomain[0], x1 = xExtentDomain[1];
                    }
                    else {
                        x0 = xExtent[0], x1 = xExtent[1];
                        if (x.invert)
                            x0 = x.invert(x0), x1 = x.invert(x1);
                        if (x1 < x0)
                            t = x0, x0 = x1, x1 = t;
                    }
                }
                if (y) {
                    if (yExtentDomain) {
                        y0 = yExtentDomain[0], y1 = yExtentDomain[1];
                    }
                    else {
                        y0 = yExtent[0], y1 = yExtent[1];
                        if (y.invert)
                            y0 = y.invert(y0), y1 = y.invert(y1);
                        if (y1 < y0)
                            t = y0, y0 = y1, y1 = t;
                    }
                }
                return x && y ? [[x0, y0], [x1, y1]] : x ? [x0, x1] : y && [y0, y1];
            }
            if (x) {
                x0 = z[0], x1 = z[1];
                if (y)
                    x0 = x0[0], x1 = x1[0];
                xExtentDomain = [x0, x1];
                if (x.invert)
                    x0 = x(x0), x1 = x(x1);
                if (x1 < x0)
                    t = x0, x0 = x1, x1 = t;
                if (x0 != xExtent[0] || x1 != xExtent[1])
                    xExtent = [x0, x1];
            }
            if (y) {
                y0 = z[0], y1 = z[1];
                if (x)
                    y0 = y0[1], y1 = y1[1];
                yExtentDomain = [y0, y1];
                if (y.invert)
                    y0 = y(y0), y1 = y(y1);
                if (y1 < y0)
                    t = y0, y0 = y1, y1 = t;
                if (y0 != yExtent[0] || y1 != yExtent[1])
                    yExtent = [y0, y1];
            }
            return brush;
        };
        brush.clear = function () {
            if (!brush.empty()) {
                xExtent = [0, 0], yExtent = [0, 0];
                xExtentDomain = yExtentDomain = null;
            }
            return brush;
        };
        brush.empty = function () {
            return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
        };
        return d3.rebind(brush, event, "on");
    };
    var d3_svg_brushCursor = {
        n: "ns-resize",
        e: "ew-resize",
        s: "ns-resize",
        w: "ew-resize",
        nw: "nwse-resize",
        ne: "nesw-resize",
        se: "nwse-resize",
        sw: "nesw-resize"
    };
    var d3_svg_brushResizes = [["n", "e", "s", "w", "nw", "ne", "se", "sw"], ["e", "w"], ["n", "s"], []];
    var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
    var d3_time_formatUtc = d3_time_format.utc;
    var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
    d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
    function d3_time_formatIsoNative(date) {
        return date.toISOString();
    }
    d3_time_formatIsoNative.parse = function (string) {
        var date = new Date(string);
        return isNaN(date) ? null : date;
    };
    d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
    d3_time.second = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 1e3) * 1e3);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 1e3);
    }, function (date) {
        return date.getSeconds();
    });
    d3_time.seconds = d3_time.second.range;
    d3_time.seconds.utc = d3_time.second.utc.range;
    d3_time.minute = d3_time_interval(function (date) {
        return new d3_date(Math.floor(date / 6e4) * 6e4);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 6e4);
    }, function (date) {
        return date.getMinutes();
    });
    d3_time.minutes = d3_time.minute.range;
    d3_time.minutes.utc = d3_time.minute.utc.range;
    d3_time.hour = d3_time_interval(function (date) {
        var timezone = date.getTimezoneOffset() / 60;
        return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
    }, function (date, offset) {
        date.setTime(date.getTime() + Math.floor(offset) * 36e5);
    }, function (date) {
        return date.getHours();
    });
    d3_time.hours = d3_time.hour.range;
    d3_time.hours.utc = d3_time.hour.utc.range;
    d3_time.month = d3_time_interval(function (date) {
        date = d3_time.day(date);
        date.setDate(1);
        return date;
    }, function (date, offset) {
        date.setMonth(date.getMonth() + offset);
    }, function (date) {
        return date.getMonth();
    });
    d3_time.months = d3_time.month.range;
    d3_time.months.utc = d3_time.month.utc.range;
    function d3_time_scale(linear, methods, format) {
        function scale(x) {
            return linear(x);
        }
        scale.invert = function (x) {
            return d3_time_scaleDate(linear.invert(x));
        };
        scale.domain = function (x) {
            if (!arguments.length)
                return linear.domain().map(d3_time_scaleDate);
            linear.domain(x);
            return scale;
        };
        function tickMethod(extent, count) {
            var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
            return i == d3_time_scaleSteps.length ? [methods.year, d3_scale_linearTickRange(extent.map(function (d) {
                    return d / 31536e6;
                }), count)[2]] : !i ? [d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2]] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
        }
        scale.nice = function (interval, skip) {
            var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
            if (method)
                interval = method[0], skip = method[1];
            function skipped(date) {
                return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
            }
            return scale.domain(d3_scale_nice(domain, skip > 1 ? {
                floor: function (date) {
                    while (skipped(date = interval.floor(date)))
                        date = d3_time_scaleDate(date - 1);
                    return date;
                },
                ceil: function (date) {
                    while (skipped(date = interval.ceil(date)))
                        date = d3_time_scaleDate(+date + 1);
                    return date;
                }
            } : interval));
        };
        scale.ticks = function (interval, skip) {
            var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [{
                    range: interval
                }, skip];
            if (method)
                interval = method[0], skip = method[1];
            return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
        };
        scale.tickFormat = function () {
            return format;
        };
        scale.copy = function () {
            return d3_time_scale(linear.copy(), methods, format);
        };
        return d3_scale_linearRebind(scale, linear);
    }
    function d3_time_scaleDate(t) {
        return new Date(t);
    }
    var d3_time_scaleSteps = [1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6];
    var d3_time_scaleLocalMethods = [[d3_time.second, 1], [d3_time.second, 5], [d3_time.second, 15], [d3_time.second, 30], [d3_time.minute, 1], [d3_time.minute, 5], [d3_time.minute, 15], [d3_time.minute, 30], [d3_time.hour, 1], [d3_time.hour, 3], [d3_time.hour, 6], [d3_time.hour, 12], [d3_time.day, 1], [d3_time.day, 2], [d3_time.week, 1], [d3_time.month, 1], [d3_time.month, 3], [d3_time.year, 1]];
    var d3_time_scaleLocalFormat = d3_time_format.multi([[".%L", function (d) {
                return d.getMilliseconds();
            }], [":%S", function (d) {
                return d.getSeconds();
            }], ["%I:%M", function (d) {
                return d.getMinutes();
            }], ["%I %p", function (d) {
                return d.getHours();
            }], ["%a %d", function (d) {
                return d.getDay() && d.getDate() != 1;
            }], ["%b %d", function (d) {
                return d.getDate() != 1;
            }], ["%B", function (d) {
                return d.getMonth();
            }], ["%Y", d3_true]]);
    var d3_time_scaleMilliseconds = {
        range: function (start, stop, step) {
            return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
        },
        floor: d3_identity,
        ceil: d3_identity
    };
    d3_time_scaleLocalMethods.year = d3_time.year;
    d3_time.scale = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
    };
    var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function (m) {
        return [m[0].utc, m[1]];
    });
    var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([[".%L", function (d) {
                return d.getUTCMilliseconds();
            }], [":%S", function (d) {
                return d.getUTCSeconds();
            }], ["%I:%M", function (d) {
                return d.getUTCMinutes();
            }], ["%I %p", function (d) {
                return d.getUTCHours();
            }], ["%a %d", function (d) {
                return d.getUTCDay() && d.getUTCDate() != 1;
            }], ["%b %d", function (d) {
                return d.getUTCDate() != 1;
            }], ["%B", function (d) {
                return d.getUTCMonth();
            }], ["%Y", d3_true]]);
    d3_time_scaleUtcMethods.year = d3_time.year.utc;
    d3_time.scale.utc = function () {
        return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
    };
    d3.text = d3_xhrType(function (request) {
        return request.responseText;
    });
    d3.json = function (url, callback) {
        return d3_xhr(url, "application/json", d3_json, callback);
    };
    function d3_json(request) {
        return JSON.parse(request.responseText);
    }
    d3.html = function (url, callback) {
        return d3_xhr(url, "text/html", d3_html, callback);
    };
    function d3_html(request) {
        var range = d3_document.createRange();
        range.selectNode(d3_document.body);
        return range.createContextualFragment(request.responseText);
    }
    d3.xml = d3_xhrType(function (request) {
        return request.responseXML;
    });
    if (typeof define === "function" && define.amd)
        this.d3 = d3, define(d3);
    else if (typeof module === "object" && module.exports)
        module.exports = d3;
    else
        this.d3 = d3;
}();
var netClustering = {
    version: "0.1"
};
(function () {
    function binaryTreeWalk(currentNode, tree, depth, doLeafAction, doDownAction, doUpAction) {
        if (tree[currentNode].leftChild > -1) {
            depth += 1;
            if (doDownAction) {
                doDownAction(currentNode, tree, depth);
            }
            binaryTreeWalk(tree[currentNode].leftChild, tree, depth, doLeafAction, doDownAction, doUpAction);
        }
        if (tree[currentNode].rightChild == -1) {
            if (doLeafAction) {
                doLeafAction(currentNode, tree, depth);
            }
        }
        if (tree[currentNode].rightChild > -1) {
            binaryTreeWalk(tree[currentNode].rightChild, tree, depth, doLeafAction, doDownAction, doUpAction);
            if (doUpAction) {
                doUpAction(currentNode, tree, depth);
            }
            depth -= 1;
        }
    }
    function addClosestPairByCommunity(tree, deltaQ, a) {
        var n = tree.length;
        var H = {};
        for (var hash in deltaQ) {
            var dQ = deltaQ[hash];
            var keys = hash.split("~");
            var i = Number(keys[0]);
            var j = Number(keys[1]);
            if (!H[i]) {
                H[i] = [];
            }
            if (!H[j]) {
                H[j] = [];
            }
            H[i].push({ "dQ": dQ, "i": i, "j": j });
            H[j].push({ "dQ": dQ, "i": i, "j": j });
        }
        var Hmax = { "dQ": -Infinity, "i": -1, "j": -1 };
        for (var i = 0; i < n; i++) {
            if (H[i]) {
                H[i].sort(function (a, b) {
                    return b.dQ - a.dQ;
                });
                if (H[i][0].dQ > Hmax.dQ) {
                    Hmax.dQ = H[i][0].dQ;
                    Hmax.i = H[i][0].i;
                    Hmax.j = H[i][0].j;
                }
            }
        }
        if (Hmax.i == -1) {
            return null;
        }
        var wt = tree[Hmax.i].weight + tree[Hmax.j].weight;
        tree.push({ "parent": -1, "leftChild": Hmax.i, "rightChild": Hmax.j, "weight": wt, "dQ": Hmax.dQ });
        tree[Hmax.i].parent = n;
        tree[Hmax.j].parent = n;
        var hashToZap = [];
        for (var k = 0; k < n; k++) {
            if (k != Hmax.i && k != Hmax.j && H[k]) {
                var hashik = Math.min(Hmax.i, k) + "~" + Math.max(Hmax.i, k);
                var hashjk = Math.min(Hmax.j, k) + "~" + Math.max(Hmax.j, k);
                var hashNew = k + "~" + n;
                var t1 = deltaQ[hashik];
                var t2 = deltaQ[hashjk];
                if (!isNaN(t1)) {
                    hashToZap.push(hashik);
                    if (!isNaN(t2)) {
                        hashToZap.push(hashjk);
                        deltaQ[hashNew] = t1 + t2;
                    }
                    else {
                        deltaQ[hashNew] = t1 - 2.0 * a[Hmax.j] * a[k];
                    }
                }
                else {
                    if (!isNaN(t2)) {
                        hashToZap.push(hashjk);
                        deltaQ[hashNew] = t2 - 2.0 * a[Hmax.i] * a[k];
                    }
                    else {
                        deltaQ[hashNew] = null;
                    }
                }
            }
        }
        a[n] = a[Hmax.i] + a[Hmax.j];
        deltaQ[Hmax.i + "~" + Hmax.j] = null;
        for (var i = 0; i < hashToZap.length; i++) {
            deltaQ[hashToZap[i]] = null;
        }
        var dQcopy = {};
        var ndq = 0;
        for (var hash in deltaQ) {
            if (deltaQ[hash]) {
                dQcopy[hash] = deltaQ[hash];
                ndq++;
            }
        }
        return { "value": Hmax.dQ, "array": dQcopy };
    }
    function buildTreeByCommunities(dataObj, showNotes) {
        var n = dataObj.names.length;
        var k = [];
        for (var i = 0; i < n; i++) {
            k[i] = 0;
        }
        var m = 0;
        var W = 0;
        if (dataObj.useWeights) {
            for (var hash in dataObj.distances) {
                var keys = hash.split("~");
                var i = Number(keys[0]);
                var j = Number(keys[1]);
                var d = dataObj.distances[hash];
                k[i] += d;
                k[j] += d;
                W += d;
                m += 1;
            }
            if (!W) {
                W = 1e-7;
            }
            ;
            var inv2m = 1 / (2 * W);
        }
        else {
            for (var hash in dataObj.distances) {
                var keys = hash.split("~");
                var i = Number(keys[0]);
                var j = Number(keys[1]);
                k[i] += 1;
                k[j] += 1;
                m += 1;
            }
            if (!m) {
                m = 1e-7;
            }
            ;
            var inv2m = 1 / (2 * m);
        }
        var deltaQ = {};
        for (var hash in dataObj.distances) {
            var keys = hash.split("~");
            var i = Number(keys[0]);
            var j = Number(keys[1]);
            if (dataObj.useWeights) {
                deltaQ[hash] = 2.0 * inv2m * dataObj.distances[hash] - 2.0 * inv2m * inv2m * k[i] * k[j];
            }
            else {
                deltaQ[hash] = 2.0 * (inv2m - k[i] * k[j] * inv2m * inv2m);
            }
        }
        var a = [];
        for (var i = 0; i < n; i++) {
            a[i] = inv2m * k[i];
        }
        var tree = [];
        for (var i = 0; i < n; i++) {
            tree.push({ "parent": -1, "leftChild": -1, "rightChild": -1, "weight": 1, "linkage": a[i], "name": dataObj.names[i], "primaryKey": i });
        }
        var Q = 0.0;
        var maxQ = -Infinity;
        var dQobj = { "value": 0, "array": deltaQ };
        var numCommunities = 1;
        while (dQobj && tree.length < (2 * n - 1)) {
            dQobj = addClosestPairByCommunity(tree, dQobj.array, a);
            if (dQobj) {
                Q += dQobj.value;
                if (dQobj.value < 0) {
                    numCommunities += 1;
                }
                ;
                maxQ = Math.max(maxQ, Q);
            }
            else {
                return null;
            }
        }
        var index = 0;
        var root = tree.length - 1;
        binaryTreeWalk(root, tree, 0, function (currentNode, tree, depth) {
            tree[currentNode].index = index;
            index += 1;
        }, null, null);
        if (showNotes) {
            var notes = n + " nodes, " + m + " of " + (n * (n - 1) / 2) + " possible edges (" + Math.round(200 * m / (n * (n - 1))) + "%) ";
            notes += "with data, and " + numCommunities + " primary communities identified.";
            notes += "&nbsp; &nbsp; Q=" + maxQ.toFixed(3);
            document.getElementById("notes").innerHTML = notes;
        }
        return { "tree": tree, "distances": dataObj.distances, "root": root, "names": dataObj.names, "useWeights": dataObj.useWeights };
    }
    function findSplits(treeObj) {
        var breakNext = true;
        var breakNodes = [];
        var g = -1;
        var group = [];
        var members = "";
        var tracker = 0;
        binaryTreeWalk(treeObj.root, treeObj.tree, 0, function (node, tree, depth) {
            if (breakNext) {
                g += 1;
                breakNodes.push(node);
                breakNext = false;
            }
            group[node] = g;
            members += treeObj.tree[node].name + ",";
        }, function (node, tree, depth) {
            var thisNode = tree[node];
            if (thisNode.dQ < 0) {
                breakNext = true;
                tracker = 0;
            }
            tracker += 1;
        }, function (node, tree, depth) {
            var thisNode = tree[node];
            tracker -= 1;
            if (tracker == 1) {
                breakNext = true;
                members += "~";
            }
        });
        var numGroups = g + 1;
        members = members.slice(0, -2);
        members = members.replace(/,~/g, "~");
        return { "numGroups": numGroups, "group": group, "members": members, "breakNodes": breakNodes };
    }
    function findSubCommunities(treeObj, depth, prevGroup) {
        if (!treeObj) {
            return;
        }
        var tree = treeObj.tree;
        var root = treeObj.root;
        var names = treeObj.names;
        var splitInfo = findSplits(treeObj);
        var numGroups = splitInfo.numGroups;
        var group = splitInfo.group;
        var t = splitInfo.members.split("~");
        var groups = [];
        for (var g = 0; g < t.length; g++) {
            groups.push((t[g]).split(","));
        }
        var dataObjList = [];
        for (var g = 0; g < numGroups; g++) {
            dataObjList.push({ "names": [], "distances": [], "useWeights": treeObj.useWeights });
        }
        var nameKeys = [];
        for (var i = 0; i < names.length; i++) {
            var name = names[i];
            dataObjList[group[i]].names.push(name);
            nameKeys[i] = dataObjList[group[i]].names.length - 1;
        }
        for (var hash in treeObj.distances) {
            var keys = hash.split("~");
            var i = Number(keys[0]);
            var j = Number(keys[1]);
            if (group[i] == group[j]) {
                var newHash = nameKeys[i] + "~" + nameKeys[j];
                dataObjList[group[i]].distances[newHash] = treeObj.distances[hash];
            }
        }
        if (numGroups > 1) {
            for (var g = 0; g < numGroups; g++) {
                var innerTreeObj = buildTreeByCommunities(dataObjList[g]);
                if (innerTreeObj && innerTreeObj.tree) {
                    var innerGroups = findSplits(innerTreeObj).numGroups;
                    if (innerGroups > 1) {
                        var subgroups = findSubCommunities(innerTreeObj, depth + 1, g);
                        groups[g] = subgroups;
                    }
                }
            }
        }
        return groups;
    }
    netClustering.buildTreeByCommunities = buildTreeByCommunities;
    netClustering.findSubCommunities = findSubCommunities;
    netClustering.cluster = function (nodes, edges, clusterAttr, edgesCountAttr) {
        var dataObj = {}, treeObj, groups = [], i;
        if (clusterAttr === undefined) {
            clusterAttr = "cluster";
        }
        if (edgesCountAttr === undefined) {
            edgesCountAttr = "value";
        }
        var linksForClustering = [];
        if (edges.length > 0 && typeof (edges[0].source) === "object") {
            linksForClustering = edges.map(function (d) {
                var sourceId = nodes.indexOf(d.source), targetId = nodes.indexOf(d.target);
                if (sourceId === -1 || targetId === -1) {
                    return null;
                }
                else {
                    return {
                        sourceId: sourceId,
                        targetId: targetId,
                        count: d[edgesCountAttr] !== undefined ? d[edgesCountAttr] : 1
                    };
                }
            });
        }
        else {
            edges.forEach(function (d) {
                linksForClustering.push({
                    source: d.source,
                    target: d.target,
                    count: d[edgesCountAttr] !== undefined ? d[edgesCountAttr] : 1
                });
            });
        }
        dataObj.method = "newman";
        dataObj.useWeights = true;
        dataObj.names = nodes.map(function (d, i) { return "" + i; });
        dataObj.distances = {};
        linksForClustering = linksForClustering.filter(function (d) { return d.sourceId !== d.targetId; });
        linksForClustering.forEach(function (d) {
            var hash = Math.min(d.sourceId, d.targetId) + "~" + Math.max(d.sourceId, d.targetId);
            dataObj.distances[hash] = +d.count;
        });
        dataObj = addDummyMetaNode(dataObj);
        treeObj = buildTreeByCommunities(dataObj, false);
        console.log('treeObj', treeObj);
        groups = findSubCommunities(treeObj, 0, 0);
        groups = removeDummyMetaNode(groups);
        i = 0;
        groups.forEach(function (d, i) {
            function assignToCluster(ele, i) {
                if (ele instanceof Array) {
                    ele.forEach(function (e) {
                        assignToCluster(e, i);
                    });
                }
                else {
                    nodes[+ele][clusterAttr] = i.toString();
                }
            }
            assignToCluster(d, i);
        });
        return groups;
    };
    function addDummyMetaNode(dataObj) {
        dataObj.names.push("DUMMY");
        dataObj.names.forEach(function (d, i) {
            if (i === dataObj.names.length - 1) {
                return;
            }
            var hash = i + "~" + (dataObj.names.length - 1);
            dataObj.distances[hash] = 0.1;
        });
        return dataObj;
    }
    function removeDummyMetaNode(groups) {
        var i, ele;
        for (i = 0; i < groups.length; i++) {
            ele = groups[i];
            if (ele instanceof Array) {
                ele = removeDummyMetaNode(ele);
                if (ele.length === 0) {
                    groups.splice(i, 1);
                }
            }
            else {
                if (ele === "DUMMY" || ele === "DUMM") {
                    groups.splice(i, 1);
                    break;
                }
            }
        }
        return groups;
    }
})();
(function () {
    var Color, DEG2RAD, LAB_CONSTANTS, PI, PITHIRD, RAD2DEG, TWOPI, _guess_formats, _guess_formats_sorted, _input, _interpolators, abs, atan2, bezier, blend, blend_f, brewer, burn, chroma, clip_rgb, cmyk2rgb, colors, cos, css2rgb, darken, dodge, each, floor, hex2rgb, hsi2rgb, hsl2css, hsl2rgb, hsv2rgb, interpolate, interpolate_hsx, interpolate_lab, interpolate_num, interpolate_rgb, lab2lch, lab2rgb, lab_xyz, lch2lab, lch2rgb, lighten, limit, log, luminance_x, m, max, multiply, normal, num2rgb, overlay, pow, rgb2cmyk, rgb2css, rgb2hex, rgb2hsi, rgb2hsl, rgb2hsv, rgb2lab, rgb2lch, rgb2luminance, rgb2num, rgb2temperature, rgb2xyz, rgb_xyz, rnd, root, round, screen, sin, sqrt, temperature2rgb, type, unpack, w3cx11, xyz_lab, xyz_rgb, slice = [].slice;
    type = (function () {
        var classToType, len, name, o, ref;
        classToType = {};
        ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
        for (o = 0, len = ref.length; o < len; o++) {
            name = ref[o];
            classToType["[object " + name + "]"] = name.toLowerCase();
        }
        return function (obj) {
            var strType;
            strType = Object.prototype.toString.call(obj);
            return classToType[strType] || "object";
        };
    })();
    limit = function (x, min, max) {
        if (min == null) {
            min = 0;
        }
        if (max == null) {
            max = 1;
        }
        if (x < min) {
            x = min;
        }
        if (x > max) {
            x = max;
        }
        return x;
    };
    unpack = function (args) {
        if (args.length >= 3) {
            return [].slice.call(args);
        }
        else {
            return args[0];
        }
    };
    clip_rgb = function (rgb) {
        var i;
        for (i in rgb) {
            if (i < 3) {
                if (rgb[i] < 0) {
                    rgb[i] = 0;
                }
                if (rgb[i] > 255) {
                    rgb[i] = 255;
                }
            }
            else if (i === 3) {
                if (rgb[i] < 0) {
                    rgb[i] = 0;
                }
                if (rgb[i] > 1) {
                    rgb[i] = 1;
                }
            }
        }
        return rgb;
    };
    PI = Math.PI, round = Math.round, cos = Math.cos, floor = Math.floor, pow = Math.pow, log = Math.log, sin = Math.sin, sqrt = Math.sqrt, atan2 = Math.atan2, max = Math.max, abs = Math.abs;
    TWOPI = PI * 2;
    PITHIRD = PI / 3;
    DEG2RAD = PI / 180;
    RAD2DEG = 180 / PI;
    chroma = function () {
        if (arguments[0] instanceof Color) {
            return arguments[0];
        }
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, arguments, function () { });
    };
    _interpolators = [];
    if ((typeof module !== "undefined" && module !== null) && (module.exports != null)) {
        module.exports = chroma;
    }
    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return chroma;
        });
    }
    else {
        root = typeof exports !== "undefined" && exports !== null ? exports : this;
        root.chroma = chroma;
    }
    chroma.version = '1.1.1';
    _input = {};
    _guess_formats = [];
    _guess_formats_sorted = false;
    Color = (function () {
        function Color() {
            var arg, args, chk, len, len1, me, mode, o, w;
            me = this;
            args = [];
            for (o = 0, len = arguments.length; o < len; o++) {
                arg = arguments[o];
                if (arg != null) {
                    args.push(arg);
                }
            }
            mode = args[args.length - 1];
            if (_input[mode] != null) {
                me._rgb = clip_rgb(_input[mode](unpack(args.slice(0, -1))));
            }
            else {
                if (!_guess_formats_sorted) {
                    _guess_formats = _guess_formats.sort(function (a, b) {
                        return b.p - a.p;
                    });
                    _guess_formats_sorted = true;
                }
                for (w = 0, len1 = _guess_formats.length; w < len1; w++) {
                    chk = _guess_formats[w];
                    mode = chk.test.apply(chk, args);
                    if (mode) {
                        break;
                    }
                }
                if (mode) {
                    me._rgb = clip_rgb(_input[mode].apply(_input, args));
                }
            }
            if (me._rgb == null) {
                console.warn('unknown format: ' + args);
            }
            if (me._rgb == null) {
                me._rgb = [0, 0, 0];
            }
            if (me._rgb.length === 3) {
                me._rgb.push(1);
            }
        }
        Color.prototype.alpha = function (alpha) {
            if (arguments.length) {
                this._rgb[3] = alpha;
                return this;
            }
            return this._rgb[3];
        };
        Color.prototype.toString = function () {
            return this.name();
        };
        return Color;
    })();
    chroma._input = _input;
    chroma.brewer = brewer = {
        OrRd: ['#fff7ec', '#fee8c8', '#fdd49e', '#fdbb84', '#fc8d59', '#ef6548', '#d7301f', '#b30000', '#7f0000'],
        PuBu: ['#fff7fb', '#ece7f2', '#d0d1e6', '#a6bddb', '#74a9cf', '#3690c0', '#0570b0', '#045a8d', '#023858'],
        BuPu: ['#f7fcfd', '#e0ecf4', '#bfd3e6', '#9ebcda', '#8c96c6', '#8c6bb1', '#88419d', '#810f7c', '#4d004b'],
        Oranges: ['#fff5eb', '#fee6ce', '#fdd0a2', '#fdae6b', '#fd8d3c', '#f16913', '#d94801', '#a63603', '#7f2704'],
        BuGn: ['#f7fcfd', '#e5f5f9', '#ccece6', '#99d8c9', '#66c2a4', '#41ae76', '#238b45', '#006d2c', '#00441b'],
        YlOrBr: ['#ffffe5', '#fff7bc', '#fee391', '#fec44f', '#fe9929', '#ec7014', '#cc4c02', '#993404', '#662506'],
        YlGn: ['#ffffe5', '#f7fcb9', '#d9f0a3', '#addd8e', '#78c679', '#41ab5d', '#238443', '#006837', '#004529'],
        Reds: ['#fff5f0', '#fee0d2', '#fcbba1', '#fc9272', '#fb6a4a', '#ef3b2c', '#cb181d', '#a50f15', '#67000d'],
        RdPu: ['#fff7f3', '#fde0dd', '#fcc5c0', '#fa9fb5', '#f768a1', '#dd3497', '#ae017e', '#7a0177', '#49006a'],
        Greens: ['#f7fcf5', '#e5f5e0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#006d2c', '#00441b'],
        YlGnBu: ['#ffffd9', '#edf8b1', '#c7e9b4', '#7fcdbb', '#41b6c4', '#1d91c0', '#225ea8', '#253494', '#081d58'],
        Purples: ['#fcfbfd', '#efedf5', '#dadaeb', '#bcbddc', '#9e9ac8', '#807dba', '#6a51a3', '#54278f', '#3f007d'],
        GnBu: ['#f7fcf0', '#e0f3db', '#ccebc5', '#a8ddb5', '#7bccc4', '#4eb3d3', '#2b8cbe', '#0868ac', '#084081'],
        Greys: ['#ffffff', '#f0f0f0', '#d9d9d9', '#bdbdbd', '#969696', '#737373', '#525252', '#252525', '#000000'],
        YlOrRd: ['#ffffcc', '#ffeda0', '#fed976', '#feb24c', '#fd8d3c', '#fc4e2a', '#e31a1c', '#bd0026', '#800026'],
        PuRd: ['#f7f4f9', '#e7e1ef', '#d4b9da', '#c994c7', '#df65b0', '#e7298a', '#ce1256', '#980043', '#67001f'],
        Blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],
        PuBuGn: ['#fff7fb', '#ece2f0', '#d0d1e6', '#a6bddb', '#67a9cf', '#3690c0', '#02818a', '#016c59', '#014636'],
        Spectral: ['#9e0142', '#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#e6f598', '#abdda4', '#66c2a5', '#3288bd', '#5e4fa2'],
        RdYlGn: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee08b', '#ffffbf', '#d9ef8b', '#a6d96a', '#66bd63', '#1a9850', '#006837'],
        RdBu: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#f7f7f7', '#d1e5f0', '#92c5de', '#4393c3', '#2166ac', '#053061'],
        PiYG: ['#8e0152', '#c51b7d', '#de77ae', '#f1b6da', '#fde0ef', '#f7f7f7', '#e6f5d0', '#b8e186', '#7fbc41', '#4d9221', '#276419'],
        PRGn: ['#40004b', '#762a83', '#9970ab', '#c2a5cf', '#e7d4e8', '#f7f7f7', '#d9f0d3', '#a6dba0', '#5aae61', '#1b7837', '#00441b'],
        RdYlBu: ['#a50026', '#d73027', '#f46d43', '#fdae61', '#fee090', '#ffffbf', '#e0f3f8', '#abd9e9', '#74add1', '#4575b4', '#313695'],
        BrBG: ['#543005', '#8c510a', '#bf812d', '#dfc27d', '#f6e8c3', '#f5f5f5', '#c7eae5', '#80cdc1', '#35978f', '#01665e', '#003c30'],
        RdGy: ['#67001f', '#b2182b', '#d6604d', '#f4a582', '#fddbc7', '#ffffff', '#e0e0e0', '#bababa', '#878787', '#4d4d4d', '#1a1a1a'],
        PuOr: ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],
        Set2: ['#66c2a5', '#fc8d62', '#8da0cb', '#e78ac3', '#a6d854', '#ffd92f', '#e5c494', '#b3b3b3'],
        Accent: ['#7fc97f', '#beaed4', '#fdc086', '#ffff99', '#386cb0', '#f0027f', '#bf5b17', '#666666'],
        Set1: ['#e41a1c', '#377eb8', '#4daf4a', '#984ea3', '#ff7f00', '#ffff33', '#a65628', '#f781bf', '#999999'],
        Set3: ['#8dd3c7', '#ffffb3', '#bebada', '#fb8072', '#80b1d3', '#fdb462', '#b3de69', '#fccde5', '#d9d9d9', '#bc80bd', '#ccebc5', '#ffed6f'],
        Dark2: ['#1b9e77', '#d95f02', '#7570b3', '#e7298a', '#66a61e', '#e6ab02', '#a6761d', '#666666'],
        Paired: ['#a6cee3', '#1f78b4', '#b2df8a', '#33a02c', '#fb9a99', '#e31a1c', '#fdbf6f', '#ff7f00', '#cab2d6', '#6a3d9a', '#ffff99', '#b15928'],
        Pastel2: ['#b3e2cd', '#fdcdac', '#cbd5e8', '#f4cae4', '#e6f5c9', '#fff2ae', '#f1e2cc', '#cccccc'],
        Pastel1: ['#fbb4ae', '#b3cde3', '#ccebc5', '#decbe4', '#fed9a6', '#ffffcc', '#e5d8bd', '#fddaec', '#f2f2f2']
    };
    w3cx11 = {
        indigo: "#4b0082",
        gold: "#ffd700",
        hotpink: "#ff69b4",
        firebrick: "#b22222",
        indianred: "#cd5c5c",
        yellow: "#ffff00",
        mistyrose: "#ffe4e1",
        darkolivegreen: "#556b2f",
        olive: "#808000",
        darkseagreen: "#8fbc8f",
        pink: "#ffc0cb",
        tomato: "#ff6347",
        lightcoral: "#f08080",
        orangered: "#ff4500",
        navajowhite: "#ffdead",
        lime: "#00ff00",
        palegreen: "#98fb98",
        darkslategrey: "#2f4f4f",
        greenyellow: "#adff2f",
        burlywood: "#deb887",
        seashell: "#fff5ee",
        mediumspringgreen: "#00fa9a",
        fuchsia: "#ff00ff",
        papayawhip: "#ffefd5",
        blanchedalmond: "#ffebcd",
        chartreuse: "#7fff00",
        dimgray: "#696969",
        black: "#000000",
        peachpuff: "#ffdab9",
        springgreen: "#00ff7f",
        aquamarine: "#7fffd4",
        white: "#ffffff",
        orange: "#ffa500",
        lightsalmon: "#ffa07a",
        darkslategray: "#2f4f4f",
        brown: "#a52a2a",
        ivory: "#fffff0",
        dodgerblue: "#1e90ff",
        peru: "#cd853f",
        lawngreen: "#7cfc00",
        chocolate: "#d2691e",
        crimson: "#dc143c",
        forestgreen: "#228b22",
        darkgrey: "#a9a9a9",
        lightseagreen: "#20b2aa",
        cyan: "#00ffff",
        mintcream: "#f5fffa",
        silver: "#c0c0c0",
        antiquewhite: "#faebd7",
        mediumorchid: "#ba55d3",
        skyblue: "#87ceeb",
        gray: "#808080",
        darkturquoise: "#00ced1",
        goldenrod: "#daa520",
        darkgreen: "#006400",
        floralwhite: "#fffaf0",
        darkviolet: "#9400d3",
        darkgray: "#a9a9a9",
        moccasin: "#ffe4b5",
        saddlebrown: "#8b4513",
        grey: "#808080",
        darkslateblue: "#483d8b",
        lightskyblue: "#87cefa",
        lightpink: "#ffb6c1",
        mediumvioletred: "#c71585",
        slategrey: "#708090",
        red: "#ff0000",
        deeppink: "#ff1493",
        limegreen: "#32cd32",
        darkmagenta: "#8b008b",
        palegoldenrod: "#eee8aa",
        plum: "#dda0dd",
        turquoise: "#40e0d0",
        lightgrey: "#d3d3d3",
        lightgoldenrodyellow: "#fafad2",
        darkgoldenrod: "#b8860b",
        lavender: "#e6e6fa",
        maroon: "#800000",
        yellowgreen: "#9acd32",
        sandybrown: "#f4a460",
        thistle: "#d8bfd8",
        violet: "#ee82ee",
        navy: "#000080",
        magenta: "#ff00ff",
        dimgrey: "#696969",
        tan: "#d2b48c",
        rosybrown: "#bc8f8f",
        olivedrab: "#6b8e23",
        blue: "#0000ff",
        lightblue: "#add8e6",
        ghostwhite: "#f8f8ff",
        honeydew: "#f0fff0",
        cornflowerblue: "#6495ed",
        slateblue: "#6a5acd",
        linen: "#faf0e6",
        darkblue: "#00008b",
        powderblue: "#b0e0e6",
        seagreen: "#2e8b57",
        darkkhaki: "#bdb76b",
        snow: "#fffafa",
        sienna: "#a0522d",
        mediumblue: "#0000cd",
        royalblue: "#4169e1",
        lightcyan: "#e0ffff",
        green: "#008000",
        mediumpurple: "#9370db",
        midnightblue: "#191970",
        cornsilk: "#fff8dc",
        paleturquoise: "#afeeee",
        bisque: "#ffe4c4",
        slategray: "#708090",
        darkcyan: "#008b8b",
        khaki: "#f0e68c",
        wheat: "#f5deb3",
        teal: "#008080",
        darkorchid: "#9932cc",
        deepskyblue: "#00bfff",
        salmon: "#fa8072",
        darkred: "#8b0000",
        steelblue: "#4682b4",
        palevioletred: "#db7093",
        lightslategray: "#778899",
        aliceblue: "#f0f8ff",
        lightslategrey: "#778899",
        lightgreen: "#90ee90",
        orchid: "#da70d6",
        gainsboro: "#dcdcdc",
        mediumseagreen: "#3cb371",
        lightgray: "#d3d3d3",
        mediumturquoise: "#48d1cc",
        lemonchiffon: "#fffacd",
        cadetblue: "#5f9ea0",
        lightyellow: "#ffffe0",
        lavenderblush: "#fff0f5",
        coral: "#ff7f50",
        purple: "#800080",
        aqua: "#00ffff",
        whitesmoke: "#f5f5f5",
        mediumslateblue: "#7b68ee",
        darkorange: "#ff8c00",
        mediumaquamarine: "#66cdaa",
        darksalmon: "#e9967a",
        beige: "#f5f5dc",
        blueviolet: "#8a2be2",
        azure: "#f0ffff",
        lightsteelblue: "#b0c4de",
        oldlace: "#fdf5e6",
        rebeccapurple: "#663399"
    };
    chroma.colors = colors = w3cx11;
    lab2rgb = function () {
        var a, args, b, g, l, r, x, y, z;
        args = unpack(arguments);
        l = args[0], a = args[1], b = args[2];
        y = (l + 16) / 116;
        x = isNaN(a) ? y : y + a / 500;
        z = isNaN(b) ? y : y - b / 200;
        y = LAB_CONSTANTS.Yn * lab_xyz(y);
        x = LAB_CONSTANTS.Xn * lab_xyz(x);
        z = LAB_CONSTANTS.Zn * lab_xyz(z);
        r = xyz_rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z);
        g = xyz_rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z);
        b = xyz_rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z);
        r = limit(r, 0, 255);
        g = limit(g, 0, 255);
        b = limit(b, 0, 255);
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };
    xyz_rgb = function (r) {
        return round(255 * (r <= 0.00304 ? 12.92 * r : 1.055 * pow(r, 1 / 2.4) - 0.055));
    };
    lab_xyz = function (t) {
        if (t > LAB_CONSTANTS.t1) {
            return t * t * t;
        }
        else {
            return LAB_CONSTANTS.t2 * (t - LAB_CONSTANTS.t0);
        }
    };
    LAB_CONSTANTS = {
        Kn: 18,
        Xn: 0.950470,
        Yn: 1,
        Zn: 1.088830,
        t0: 0.137931034,
        t1: 0.206896552,
        t2: 0.12841855,
        t3: 0.008856452
    };
    rgb2lab = function () {
        var b, g, r, ref, ref1, x, y, z;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        ref1 = rgb2xyz(r, g, b), x = ref1[0], y = ref1[1], z = ref1[2];
        return [116 * y - 16, 500 * (x - y), 200 * (y - z)];
    };
    rgb_xyz = function (r) {
        if ((r /= 255) <= 0.04045) {
            return r / 12.92;
        }
        else {
            return pow((r + 0.055) / 1.055, 2.4);
        }
    };
    xyz_lab = function (t) {
        if (t > LAB_CONSTANTS.t3) {
            return pow(t, 1 / 3);
        }
        else {
            return t / LAB_CONSTANTS.t2 + LAB_CONSTANTS.t0;
        }
    };
    rgb2xyz = function () {
        var b, g, r, ref, x, y, z;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        r = rgb_xyz(r);
        g = rgb_xyz(g);
        b = rgb_xyz(b);
        x = xyz_lab((0.4124564 * r + 0.3575761 * g + 0.1804375 * b) / LAB_CONSTANTS.Xn);
        y = xyz_lab((0.2126729 * r + 0.7151522 * g + 0.0721750 * b) / LAB_CONSTANTS.Yn);
        z = xyz_lab((0.0193339 * r + 0.1191920 * g + 0.9503041 * b) / LAB_CONSTANTS.Zn);
        return [x, y, z];
    };
    chroma.lab = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['lab']), function () { });
    };
    _input.lab = lab2rgb;
    Color.prototype.lab = function () {
        return rgb2lab(this._rgb);
    };
    bezier = function (colors) {
        var I, I0, I1, c, lab0, lab1, lab2, lab3, ref, ref1, ref2;
        colors = (function () {
            var len, o, results;
            results = [];
            for (o = 0, len = colors.length; o < len; o++) {
                c = colors[o];
                results.push(chroma(c));
            }
            return results;
        })();
        if (colors.length === 2) {
            ref = (function () {
                var len, o, results;
                results = [];
                for (o = 0, len = colors.length; o < len; o++) {
                    c = colors[o];
                    results.push(c.lab());
                }
                return results;
            })(), lab0 = ref[0], lab1 = ref[1];
            I = function (t) {
                var i, lab;
                lab = (function () {
                    var o, results;
                    results = [];
                    for (i = o = 0; o <= 2; i = ++o) {
                        results.push(lab0[i] + t * (lab1[i] - lab0[i]));
                    }
                    return results;
                })();
                return chroma.lab.apply(chroma, lab);
            };
        }
        else if (colors.length === 3) {
            ref1 = (function () {
                var len, o, results;
                results = [];
                for (o = 0, len = colors.length; o < len; o++) {
                    c = colors[o];
                    results.push(c.lab());
                }
                return results;
            })(), lab0 = ref1[0], lab1 = ref1[1], lab2 = ref1[2];
            I = function (t) {
                var i, lab;
                lab = (function () {
                    var o, results;
                    results = [];
                    for (i = o = 0; o <= 2; i = ++o) {
                        results.push((1 - t) * (1 - t) * lab0[i] + 2 * (1 - t) * t * lab1[i] + t * t * lab2[i]);
                    }
                    return results;
                })();
                return chroma.lab.apply(chroma, lab);
            };
        }
        else if (colors.length === 4) {
            ref2 = (function () {
                var len, o, results;
                results = [];
                for (o = 0, len = colors.length; o < len; o++) {
                    c = colors[o];
                    results.push(c.lab());
                }
                return results;
            })(), lab0 = ref2[0], lab1 = ref2[1], lab2 = ref2[2], lab3 = ref2[3];
            I = function (t) {
                var i, lab;
                lab = (function () {
                    var o, results;
                    results = [];
                    for (i = o = 0; o <= 2; i = ++o) {
                        results.push((1 - t) * (1 - t) * (1 - t) * lab0[i] + 3 * (1 - t) * (1 - t) * t * lab1[i] + 3 * (1 - t) * t * t * lab2[i] + t * t * t * lab3[i]);
                    }
                    return results;
                })();
                return chroma.lab.apply(chroma, lab);
            };
        }
        else if (colors.length === 5) {
            I0 = bezier(colors.slice(0, 3));
            I1 = bezier(colors.slice(2, 5));
            I = function (t) {
                if (t < 0.5) {
                    return I0(t * 2);
                }
                else {
                    return I1((t - 0.5) * 2);
                }
            };
        }
        return I;
    };
    chroma.bezier = function (colors) {
        var f;
        f = bezier(colors);
        f.scale = function () {
            return chroma.scale(f);
        };
        return f;
    };
    chroma.cubehelix = function (start, rotations, hue, gamma, lightness) {
        var dh, dl, f;
        if (start == null) {
            start = 300;
        }
        if (rotations == null) {
            rotations = -1.5;
        }
        if (hue == null) {
            hue = 1;
        }
        if (gamma == null) {
            gamma = 1;
        }
        if (lightness == null) {
            lightness = [0, 1];
        }
        dl = lightness[1] - lightness[0];
        dh = 0;
        f = function (fract) {
            var a, amp, b, cos_a, g, h, l, r, sin_a;
            a = TWOPI * ((start + 120) / 360 + rotations * fract);
            l = pow(lightness[0] + dl * fract, gamma);
            h = dh !== 0 ? hue[0] + fract * dh : hue;
            amp = h * l * (1 - l) / 2;
            cos_a = cos(a);
            sin_a = sin(a);
            r = l + amp * (-0.14861 * cos_a + 1.78277 * sin_a);
            g = l + amp * (-0.29227 * cos_a - 0.90649 * sin_a);
            b = l + amp * (+1.97294 * cos_a);
            return chroma(clip_rgb([r * 255, g * 255, b * 255]));
        };
        f.start = function (s) {
            if (s == null) {
                return start;
            }
            start = s;
            return f;
        };
        f.rotations = function (r) {
            if (r == null) {
                return rotations;
            }
            rotations = r;
            return f;
        };
        f.gamma = function (g) {
            if (g == null) {
                return gamma;
            }
            gamma = g;
            return f;
        };
        f.hue = function (h) {
            if (h == null) {
                return hue;
            }
            hue = h;
            if (type(hue) === 'array') {
                dh = hue[1] - hue[0];
                if (dh === 0) {
                    hue = hue[1];
                }
            }
            else {
                dh = 0;
            }
            return f;
        };
        f.lightness = function (h) {
            if (h == null) {
                return lightness;
            }
            lightness = h;
            if (type(lightness) === 'array') {
                dl = lightness[1] - lightness[0];
                if (dl === 0) {
                    lightness = lightness[1];
                }
            }
            else {
                dl = 0;
            }
            return f;
        };
        f.scale = function () {
            return chroma.scale(f);
        };
        f.hue(hue);
        return f;
    };
    chroma.random = function () {
        var code, digits, i, o;
        digits = '0123456789abcdef';
        code = '#';
        for (i = o = 0; o < 6; i = ++o) {
            code += digits.charAt(floor(Math.random() * 16));
        }
        return new Color(code);
    };
    _input.rgb = function () {
        var k, ref, results, v;
        ref = unpack(arguments);
        results = [];
        for (k in ref) {
            v = ref[k];
            results.push(v);
        }
        return results;
    };
    chroma.rgb = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['rgb']), function () { });
    };
    Color.prototype.rgb = function () {
        return this._rgb.slice(0, 3);
    };
    Color.prototype.rgba = function () {
        return this._rgb;
    };
    _guess_formats.push({
        p: 15,
        test: function (n) {
            var a;
            a = unpack(arguments);
            if (type(a) === 'array' && a.length === 3) {
                return 'rgb';
            }
            if (a.length === 4 && type(a[3]) === "number" && a[3] >= 0 && a[3] <= 1) {
                return 'rgb';
            }
        }
    });
    hex2rgb = function (hex) {
        var a, b, g, r, rgb, u;
        if (hex.match(/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/)) {
            if (hex.length === 4 || hex.length === 7) {
                hex = hex.substr(1);
            }
            if (hex.length === 3) {
                hex = hex.split("");
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            u = parseInt(hex, 16);
            r = u >> 16;
            g = u >> 8 & 0xFF;
            b = u & 0xFF;
            return [r, g, b, 1];
        }
        if (hex.match(/^#?([A-Fa-f0-9]{8})$/)) {
            if (hex.length === 9) {
                hex = hex.substr(1);
            }
            u = parseInt(hex, 16);
            r = u >> 24 & 0xFF;
            g = u >> 16 & 0xFF;
            b = u >> 8 & 0xFF;
            a = round((u & 0xFF) / 0xFF * 100) / 100;
            return [r, g, b, a];
        }
        if ((_input.css != null) && (rgb = _input.css(hex))) {
            return rgb;
        }
        throw "unknown color: " + hex;
    };
    rgb2hex = function (channels, mode) {
        var a, b, g, hxa, r, str, u;
        if (mode == null) {
            mode = 'rgb';
        }
        r = channels[0], g = channels[1], b = channels[2], a = channels[3];
        u = r << 16 | g << 8 | b;
        str = "000000" + u.toString(16);
        str = str.substr(str.length - 6);
        hxa = '0' + round(a * 255).toString(16);
        hxa = hxa.substr(hxa.length - 2);
        return "#" + (function () {
            switch (mode.toLowerCase()) {
                case 'rgba':
                    return str + hxa;
                case 'argb':
                    return hxa + str;
                default:
                    return str;
            }
        })();
    };
    _input.hex = function (h) {
        return hex2rgb(h);
    };
    chroma.hex = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['hex']), function () { });
    };
    Color.prototype.hex = function (mode) {
        if (mode == null) {
            mode = 'rgb';
        }
        return rgb2hex(this._rgb, mode);
    };
    _guess_formats.push({
        p: 10,
        test: function (n) {
            if (arguments.length === 1 && type(n) === "string") {
                return 'hex';
            }
        }
    });
    hsl2rgb = function () {
        var args, b, c, g, h, i, l, o, r, ref, s, t1, t2, t3;
        args = unpack(arguments);
        h = args[0], s = args[1], l = args[2];
        if (s === 0) {
            r = g = b = l * 255;
        }
        else {
            t3 = [0, 0, 0];
            c = [0, 0, 0];
            t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
            t1 = 2 * l - t2;
            h /= 360;
            t3[0] = h + 1 / 3;
            t3[1] = h;
            t3[2] = h - 1 / 3;
            for (i = o = 0; o <= 2; i = ++o) {
                if (t3[i] < 0) {
                    t3[i] += 1;
                }
                if (t3[i] > 1) {
                    t3[i] -= 1;
                }
                if (6 * t3[i] < 1) {
                    c[i] = t1 + (t2 - t1) * 6 * t3[i];
                }
                else if (2 * t3[i] < 1) {
                    c[i] = t2;
                }
                else if (3 * t3[i] < 2) {
                    c[i] = t1 + (t2 - t1) * ((2 / 3) - t3[i]) * 6;
                }
                else {
                    c[i] = t1;
                }
            }
            ref = [round(c[0] * 255), round(c[1] * 255), round(c[2] * 255)], r = ref[0], g = ref[1], b = ref[2];
        }
        if (args.length > 3) {
            return [r, g, b, args[3]];
        }
        else {
            return [r, g, b];
        }
    };
    rgb2hsl = function (r, g, b) {
        var h, l, min, ref, s;
        if (r !== void 0 && r.length >= 3) {
            ref = r, r = ref[0], g = ref[1], b = ref[2];
        }
        r /= 255;
        g /= 255;
        b /= 255;
        min = Math.min(r, g, b);
        max = Math.max(r, g, b);
        l = (max + min) / 2;
        if (max === min) {
            s = 0;
            h = Number.NaN;
        }
        else {
            s = l < 0.5 ? (max - min) / (max + min) : (max - min) / (2 - max - min);
        }
        if (r === max) {
            h = (g - b) / (max - min);
        }
        else if (g === max) {
            h = 2 + (b - r) / (max - min);
        }
        else if (b === max) {
            h = 4 + (r - g) / (max - min);
        }
        h *= 60;
        if (h < 0) {
            h += 360;
        }
        return [h, s, l];
    };
    chroma.hsl = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['hsl']), function () { });
    };
    _input.hsl = hsl2rgb;
    Color.prototype.hsl = function () {
        return rgb2hsl(this._rgb);
    };
    hsv2rgb = function () {
        var args, b, f, g, h, i, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, s, t, v;
        args = unpack(arguments);
        h = args[0], s = args[1], v = args[2];
        v *= 255;
        if (s === 0) {
            r = g = b = v;
        }
        else {
            if (h === 360) {
                h = 0;
            }
            if (h > 360) {
                h -= 360;
            }
            if (h < 0) {
                h += 360;
            }
            h /= 60;
            i = floor(h);
            f = h - i;
            p = v * (1 - s);
            q = v * (1 - s * f);
            t = v * (1 - s * (1 - f));
            switch (i) {
                case 0:
                    ref = [v, t, p], r = ref[0], g = ref[1], b = ref[2];
                    break;
                case 1:
                    ref1 = [q, v, p], r = ref1[0], g = ref1[1], b = ref1[2];
                    break;
                case 2:
                    ref2 = [p, v, t], r = ref2[0], g = ref2[1], b = ref2[2];
                    break;
                case 3:
                    ref3 = [p, q, v], r = ref3[0], g = ref3[1], b = ref3[2];
                    break;
                case 4:
                    ref4 = [t, p, v], r = ref4[0], g = ref4[1], b = ref4[2];
                    break;
                case 5:
                    ref5 = [v, p, q], r = ref5[0], g = ref5[1], b = ref5[2];
            }
        }
        r = round(r);
        g = round(g);
        b = round(b);
        return [r, g, b, args.length > 3 ? args[3] : 1];
    };
    rgb2hsv = function () {
        var b, delta, g, h, min, r, ref, s, v;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        min = Math.min(r, g, b);
        max = Math.max(r, g, b);
        delta = max - min;
        v = max / 255.0;
        if (max === 0) {
            h = Number.NaN;
            s = 0;
        }
        else {
            s = delta / max;
            if (r === max) {
                h = (g - b) / delta;
            }
            if (g === max) {
                h = 2 + (b - r) / delta;
            }
            if (b === max) {
                h = 4 + (r - g) / delta;
            }
            h *= 60;
            if (h < 0) {
                h += 360;
            }
        }
        return [h, s, v];
    };
    chroma.hsv = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['hsv']), function () { });
    };
    _input.hsv = hsv2rgb;
    Color.prototype.hsv = function () {
        return rgb2hsv(this._rgb);
    };
    num2rgb = function (num) {
        var b, g, r;
        if (type(num) === "number" && num >= 0 && num <= 0xFFFFFF) {
            r = num >> 16;
            g = (num >> 8) & 0xFF;
            b = num & 0xFF;
            return [r, g, b, 1];
        }
        console.warn("unknown num color: " + num);
        return [0, 0, 0, 1];
    };
    rgb2num = function () {
        var b, g, r, ref;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        return (r << 16) + (g << 8) + b;
    };
    chroma.num = function (num) {
        return new Color(num, 'num');
    };
    Color.prototype.num = function (mode) {
        if (mode == null) {
            mode = 'rgb';
        }
        return rgb2num(this._rgb, mode);
    };
    _input.num = num2rgb;
    _guess_formats.push({
        p: 10,
        test: function (n) {
            if (arguments.length === 1 && type(n) === "number" && n >= 0 && n <= 0xFFFFFF) {
                return 'num';
            }
        }
    });
    css2rgb = function (css) {
        var aa, ab, hsl, i, m, o, rgb, w;
        css = css.toLowerCase();
        if ((chroma.colors != null) && chroma.colors[css]) {
            return hex2rgb(chroma.colors[css]);
        }
        if (m = css.match(/rgb\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*\)/)) {
            rgb = m.slice(1, 4);
            for (i = o = 0; o <= 2; i = ++o) {
                rgb[i] = +rgb[i];
            }
            rgb[3] = 1;
        }
        else if (m = css.match(/rgba\(\s*(\-?\d+),\s*(\-?\d+)\s*,\s*(\-?\d+)\s*,\s*([01]|[01]?\.\d+)\)/)) {
            rgb = m.slice(1, 5);
            for (i = w = 0; w <= 3; i = ++w) {
                rgb[i] = +rgb[i];
            }
        }
        else if (m = css.match(/rgb\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
            rgb = m.slice(1, 4);
            for (i = aa = 0; aa <= 2; i = ++aa) {
                rgb[i] = round(rgb[i] * 2.55);
            }
            rgb[3] = 1;
        }
        else if (m = css.match(/rgba\(\s*(\-?\d+(?:\.\d+)?)%,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
            rgb = m.slice(1, 5);
            for (i = ab = 0; ab <= 2; i = ++ab) {
                rgb[i] = round(rgb[i] * 2.55);
            }
            rgb[3] = +rgb[3];
        }
        else if (m = css.match(/hsl\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*\)/)) {
            hsl = m.slice(1, 4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            rgb = hsl2rgb(hsl);
            rgb[3] = 1;
        }
        else if (m = css.match(/hsla\(\s*(\-?\d+(?:\.\d+)?),\s*(\-?\d+(?:\.\d+)?)%\s*,\s*(\-?\d+(?:\.\d+)?)%\s*,\s*([01]|[01]?\.\d+)\)/)) {
            hsl = m.slice(1, 4);
            hsl[1] *= 0.01;
            hsl[2] *= 0.01;
            rgb = hsl2rgb(hsl);
            rgb[3] = +m[4];
        }
        return rgb;
    };
    rgb2css = function (rgba) {
        var mode;
        mode = rgba[3] < 1 ? 'rgba' : 'rgb';
        if (mode === 'rgb') {
            return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ')';
        }
        else if (mode === 'rgba') {
            return mode + '(' + rgba.slice(0, 3).map(round).join(',') + ',' + rgba[3] + ')';
        }
        else {
        }
    };
    rnd = function (a) {
        return round(a * 100) / 100;
    };
    hsl2css = function (hsl, alpha) {
        var mode;
        mode = alpha < 1 ? 'hsla' : 'hsl';
        hsl[0] = rnd(hsl[0] || 0);
        hsl[1] = rnd(hsl[1] * 100) + '%';
        hsl[2] = rnd(hsl[2] * 100) + '%';
        if (mode === 'hsla') {
            hsl[3] = alpha;
        }
        return mode + '(' + hsl.join(',') + ')';
    };
    _input.css = function (h) {
        return css2rgb(h);
    };
    chroma.css = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['css']), function () { });
    };
    Color.prototype.css = function (mode) {
        if (mode == null) {
            mode = 'rgb';
        }
        if (mode.slice(0, 3) === 'rgb') {
            return rgb2css(this._rgb);
        }
        else if (mode.slice(0, 3) === 'hsl') {
            return hsl2css(this.hsl(), this.alpha());
        }
    };
    _input.named = function (name) {
        return hex2rgb(w3cx11[name]);
    };
    _guess_formats.push({
        p: 20,
        test: function (n) {
            if (arguments.length === 1 && (w3cx11[n] != null)) {
                return 'named';
            }
        }
    });
    Color.prototype.name = function (n) {
        var h, k;
        if (arguments.length) {
            if (w3cx11[n]) {
                this._rgb = hex2rgb(w3cx11[n]);
            }
            this._rgb[3] = 1;
            this;
        }
        h = this.hex();
        for (k in w3cx11) {
            if (h === w3cx11[k]) {
                return k;
            }
        }
        return h;
    };
    lch2lab = function () {
        var c, h, l, ref;
        ref = unpack(arguments), l = ref[0], c = ref[1], h = ref[2];
        h = h * DEG2RAD;
        return [l, cos(h) * c, sin(h) * c];
    };
    lch2rgb = function () {
        var L, a, args, b, c, g, h, l, r, ref, ref1;
        args = unpack(arguments);
        l = args[0], c = args[1], h = args[2];
        ref = lch2lab(l, c, h), L = ref[0], a = ref[1], b = ref[2];
        ref1 = lab2rgb(L, a, b), r = ref1[0], g = ref1[1], b = ref1[2];
        return [limit(r, 0, 255), limit(g, 0, 255), limit(b, 0, 255), args.length > 3 ? args[3] : 1];
    };
    lab2lch = function () {
        var a, b, c, h, l, ref;
        ref = unpack(arguments), l = ref[0], a = ref[1], b = ref[2];
        c = sqrt(a * a + b * b);
        h = (atan2(b, a) * RAD2DEG + 360) % 360;
        if (round(c * 10000) === 0) {
            h = Number.NaN;
        }
        return [l, c, h];
    };
    rgb2lch = function () {
        var a, b, g, l, r, ref, ref1;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        ref1 = rgb2lab(r, g, b), l = ref1[0], a = ref1[1], b = ref1[2];
        return lab2lch(l, a, b);
    };
    chroma.lch = function () {
        var args;
        args = unpack(arguments);
        return new Color(args, 'lch');
    };
    chroma.hcl = function () {
        var args;
        args = unpack(arguments);
        return new Color(args, 'hcl');
    };
    _input.lch = lch2rgb;
    _input.hcl = function () {
        var c, h, l, ref;
        ref = unpack(arguments), h = ref[0], c = ref[1], l = ref[2];
        return lch2rgb([l, c, h]);
    };
    Color.prototype.lch = function () {
        return rgb2lch(this._rgb);
    };
    Color.prototype.hcl = function () {
        return rgb2lch(this._rgb).reverse();
    };
    rgb2cmyk = function (mode) {
        var b, c, f, g, k, m, r, ref, y;
        if (mode == null) {
            mode = 'rgb';
        }
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        r = r / 255;
        g = g / 255;
        b = b / 255;
        k = 1 - Math.max(r, Math.max(g, b));
        f = k < 1 ? 1 / (1 - k) : 0;
        c = (1 - r - k) * f;
        m = (1 - g - k) * f;
        y = (1 - b - k) * f;
        return [c, m, y, k];
    };
    cmyk2rgb = function () {
        var alpha, args, b, c, g, k, m, r, y;
        args = unpack(arguments);
        c = args[0], m = args[1], y = args[2], k = args[3];
        alpha = args.length > 4 ? args[4] : 1;
        if (k === 1) {
            return [0, 0, 0, alpha];
        }
        r = c >= 1 ? 0 : round(255 * (1 - c) * (1 - k));
        g = m >= 1 ? 0 : round(255 * (1 - m) * (1 - k));
        b = y >= 1 ? 0 : round(255 * (1 - y) * (1 - k));
        return [r, g, b, alpha];
    };
    _input.cmyk = function () {
        return cmyk2rgb(unpack(arguments));
    };
    chroma.cmyk = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['cmyk']), function () { });
    };
    Color.prototype.cmyk = function () {
        return rgb2cmyk(this._rgb);
    };
    _input.gl = function () {
        var i, k, o, rgb, v;
        rgb = (function () {
            var ref, results;
            ref = unpack(arguments);
            results = [];
            for (k in ref) {
                v = ref[k];
                results.push(v);
            }
            return results;
        }).apply(this, arguments);
        for (i = o = 0; o <= 2; i = ++o) {
            rgb[i] *= 255;
        }
        return rgb;
    };
    chroma.gl = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['gl']), function () { });
    };
    Color.prototype.gl = function () {
        var rgb;
        rgb = this._rgb;
        return [rgb[0] / 255, rgb[1] / 255, rgb[2] / 255, rgb[3]];
    };
    rgb2luminance = function (r, g, b) {
        var ref;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        r = luminance_x(r);
        g = luminance_x(g);
        b = luminance_x(b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    };
    luminance_x = function (x) {
        x /= 255;
        if (x <= 0.03928) {
            return x / 12.92;
        }
        else {
            return pow((x + 0.055) / 1.055, 2.4);
        }
    };
    _interpolators = [];
    interpolate = function (col1, col2, f, m) {
        var interpol, len, o, res;
        if (f == null) {
            f = 0.5;
        }
        if (m == null) {
            m = 'rgb';
        }
        if (type(col1) !== 'object') {
            col1 = chroma(col1);
        }
        if (type(col2) !== 'object') {
            col2 = chroma(col2);
        }
        for (o = 0, len = _interpolators.length; o < len; o++) {
            interpol = _interpolators[o];
            if (m === interpol[0]) {
                res = interpol[1](col1, col2, f, m);
                break;
            }
        }
        if (res == null) {
            throw "color mode " + m + " is not supported";
        }
        res.alpha(col1.alpha() + f * (col2.alpha() - col1.alpha()));
        return res;
    };
    chroma.interpolate = interpolate;
    Color.prototype.interpolate = function (col2, f, m) {
        return interpolate(this, col2, f, m);
    };
    chroma.mix = interpolate;
    Color.prototype.mix = Color.prototype.interpolate;
    interpolate_rgb = function (col1, col2, f, m) {
        var xyz0, xyz1;
        xyz0 = col1._rgb;
        xyz1 = col2._rgb;
        return new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
    };
    _interpolators.push(['rgb', interpolate_rgb]);
    Color.prototype.luminance = function (lum, mode) {
        var cur_lum, eps, max_iter, test;
        if (mode == null) {
            mode = 'rgb';
        }
        if (!arguments.length) {
            return rgb2luminance(this._rgb);
        }
        if (lum === 0) {
            this._rgb = [0, 0, 0, this._rgb[3]];
        }
        else if (lum === 1) {
            this._rgb = [255, 255, 255, this._rgb[3]];
        }
        else {
            eps = 1e-7;
            max_iter = 20;
            test = function (l, h) {
                var lm, m;
                m = l.interpolate(h, 0.5, mode);
                lm = m.luminance();
                if (Math.abs(lum - lm) < eps || !max_iter--) {
                    return m;
                }
                if (lm > lum) {
                    return test(l, m);
                }
                return test(m, h);
            };
            cur_lum = rgb2luminance(this._rgb);
            this._rgb = (cur_lum > lum ? test(chroma('black'), this) : test(this, chroma('white'))).rgba();
        }
        return this;
    };
    temperature2rgb = function (kelvin) {
        var b, g, r, temp;
        temp = kelvin / 100;
        if (temp < 66) {
            r = 255;
            g = -155.25485562709179 - 0.44596950469579133 * (g = temp - 2) + 104.49216199393888 * log(g);
            b = temp < 20 ? 0 : -254.76935184120902 + 0.8274096064007395 * (b = temp - 10) + 115.67994401066147 * log(b);
        }
        else {
            r = 351.97690566805693 + 0.114206453784165 * (r = temp - 55) - 40.25366309332127 * log(r);
            g = 325.4494125711974 + 0.07943456536662342 * (g = temp - 50) - 28.0852963507957 * log(g);
            b = 255;
        }
        return clip_rgb([r, g, b]);
    };
    rgb2temperature = function () {
        var b, eps, g, maxTemp, minTemp, r, ref, rgb, temp;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        minTemp = 1000;
        maxTemp = 40000;
        eps = 0.4;
        while (maxTemp - minTemp > eps) {
            temp = (maxTemp + minTemp) * 0.5;
            rgb = temperature2rgb(temp);
            if ((rgb[2] / rgb[0]) >= (b / r)) {
                maxTemp = temp;
            }
            else {
                minTemp = temp;
            }
        }
        return round(temp);
    };
    chroma.temperature = chroma.kelvin = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['temperature']), function () { });
    };
    _input.temperature = _input.kelvin = _input.K = temperature2rgb;
    Color.prototype.temperature = function () {
        return rgb2temperature(this._rgb);
    };
    Color.prototype.kelvin = Color.prototype.temperature;
    chroma.contrast = function (a, b) {
        var l1, l2, ref, ref1;
        if ((ref = type(a)) === 'string' || ref === 'number') {
            a = new Color(a);
        }
        if ((ref1 = type(b)) === 'string' || ref1 === 'number') {
            b = new Color(b);
        }
        l1 = a.luminance();
        l2 = b.luminance();
        if (l1 > l2) {
            return (l1 + 0.05) / (l2 + 0.05);
        }
        else {
            return (l2 + 0.05) / (l1 + 0.05);
        }
    };
    Color.prototype.get = function (modechan) {
        var channel, i, me, mode, ref, src;
        me = this;
        ref = modechan.split('.'), mode = ref[0], channel = ref[1];
        src = me[mode]();
        if (channel) {
            i = mode.indexOf(channel);
            if (i > -1) {
                return src[i];
            }
            else {
                return console.warn('unknown channel ' + channel + ' in mode ' + mode);
            }
        }
        else {
            return src;
        }
    };
    Color.prototype.set = function (modechan, value) {
        var channel, i, me, mode, ref, src;
        me = this;
        ref = modechan.split('.'), mode = ref[0], channel = ref[1];
        if (channel) {
            src = me[mode]();
            i = mode.indexOf(channel);
            if (i > -1) {
                if (type(value) === 'string') {
                    switch (value.charAt(0)) {
                        case '+':
                            src[i] += +value;
                            break;
                        case '-':
                            src[i] += +value;
                            break;
                        case '*':
                            src[i] *= +(value.substr(1));
                            break;
                        case '/':
                            src[i] /= +(value.substr(1));
                            break;
                        default:
                            src[i] = +value;
                    }
                }
                else {
                    src[i] = value;
                }
            }
            else {
                console.warn('unknown channel ' + channel + ' in mode ' + mode);
            }
        }
        else {
            src = value;
        }
        me._rgb = chroma(src, mode).alpha(me.alpha())._rgb;
        return me;
    };
    Color.prototype.darken = function (amount) {
        var lab, me;
        if (amount == null) {
            amount = 1;
        }
        me = this;
        lab = me.lab();
        lab[0] -= LAB_CONSTANTS.Kn * amount;
        return chroma.lab(lab).alpha(me.alpha());
    };
    Color.prototype.brighten = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return this.darken(-amount);
    };
    Color.prototype.darker = Color.prototype.darken;
    Color.prototype.brighter = Color.prototype.brighten;
    Color.prototype.saturate = function (amount) {
        var lch, me;
        if (amount == null) {
            amount = 1;
        }
        me = this;
        lch = me.lch();
        lch[1] += amount * LAB_CONSTANTS.Kn;
        if (lch[1] < 0) {
            lch[1] = 0;
        }
        return chroma.lch(lch).alpha(me.alpha());
    };
    Color.prototype.desaturate = function (amount) {
        if (amount == null) {
            amount = 1;
        }
        return this.saturate(-amount);
    };
    Color.prototype.premultiply = function () {
        var a, rgb;
        rgb = this.rgb();
        a = this.alpha();
        return chroma(rgb[0] * a, rgb[1] * a, rgb[2] * a, a);
    };
    blend = function (bottom, top, mode) {
        if (!blend[mode]) {
            throw 'unknown blend mode ' + mode;
        }
        return blend[mode](bottom, top);
    };
    blend_f = function (f) {
        return function (bottom, top) {
            var c0, c1;
            c0 = chroma(top).rgb();
            c1 = chroma(bottom).rgb();
            return chroma(f(c0, c1), 'rgb');
        };
    };
    each = function (f) {
        return function (c0, c1) {
            var i, o, out;
            out = [];
            for (i = o = 0; o <= 3; i = ++o) {
                out[i] = f(c0[i], c1[i]);
            }
            return out;
        };
    };
    normal = function (a, b) {
        return a;
    };
    multiply = function (a, b) {
        return a * b / 255;
    };
    darken = function (a, b) {
        if (a > b) {
            return b;
        }
        else {
            return a;
        }
    };
    lighten = function (a, b) {
        if (a > b) {
            return a;
        }
        else {
            return b;
        }
    };
    screen = function (a, b) {
        return 255 * (1 - (1 - a / 255) * (1 - b / 255));
    };
    overlay = function (a, b) {
        if (b < 128) {
            return 2 * a * b / 255;
        }
        else {
            return 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
        }
    };
    burn = function (a, b) {
        return 255 * (1 - (1 - b / 255) / (a / 255));
    };
    dodge = function (a, b) {
        if (a === 255) {
            return 255;
        }
        a = 255 * (b / 255) / (1 - a / 255);
        if (a > 255) {
            return 255;
        }
        else {
            return a;
        }
    };
    blend.normal = blend_f(each(normal));
    blend.multiply = blend_f(each(multiply));
    blend.screen = blend_f(each(screen));
    blend.overlay = blend_f(each(overlay));
    blend.darken = blend_f(each(darken));
    blend.lighten = blend_f(each(lighten));
    blend.dodge = blend_f(each(dodge));
    blend.burn = blend_f(each(burn));
    chroma.blend = blend;
    chroma.analyze = function (data) {
        var len, o, r, val;
        r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE * -1,
            sum: 0,
            values: [],
            count: 0
        };
        for (o = 0, len = data.length; o < len; o++) {
            val = data[o];
            if ((val != null) && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) {
                    r.min = val;
                }
                if (val > r.max) {
                    r.max = val;
                }
                r.count += 1;
            }
        }
        r.domain = [r.min, r.max];
        r.limits = function (mode, num) {
            return chroma.limits(r, mode, num);
        };
        return r;
    };
    chroma.scale = function (colors, positions) {
        var _classes, _colorCache, _colors, _correctLightness, _domain, _fixed, _max, _min, _mode, _nacol, _out, _padding, _pos, _spread, classifyValue, f, getClass, getColor, resetCache, setColors, tmap;
        _mode = 'rgb';
        _nacol = chroma('#ccc');
        _spread = 0;
        _fixed = false;
        _domain = [0, 1];
        _pos = [];
        _padding = [0, 0];
        _classes = false;
        _colors = [];
        _out = false;
        _min = 0;
        _max = 1;
        _correctLightness = false;
        _colorCache = {};
        setColors = function (colors) {
            var c, col, o, ref, ref1, ref2, w;
            if (colors == null) {
                colors = ['#fff', '#000'];
            }
            if ((colors != null) && type(colors) === 'string' && (((ref = chroma.brewer) != null ? ref[colors] : void 0) != null)) {
                colors = chroma.brewer[colors];
            }
            if (type(colors) === 'array') {
                colors = colors.slice(0);
                for (c = o = 0, ref1 = colors.length - 1; 0 <= ref1 ? o <= ref1 : o >= ref1; c = 0 <= ref1 ? ++o : --o) {
                    col = colors[c];
                    if (type(col) === "string") {
                        colors[c] = chroma(col);
                    }
                }
                _pos.length = 0;
                for (c = w = 0, ref2 = colors.length - 1; 0 <= ref2 ? w <= ref2 : w >= ref2; c = 0 <= ref2 ? ++w : --w) {
                    _pos.push(c / (colors.length - 1));
                }
            }
            resetCache();
            return _colors = colors;
        };
        getClass = function (value) {
            var i, n;
            if (_classes != null) {
                n = _classes.length - 1;
                i = 0;
                while (i < n && value >= _classes[i]) {
                    i++;
                }
                return i - 1;
            }
            return 0;
        };
        tmap = function (t) {
            return t;
        };
        classifyValue = function (value) {
            var i, maxc, minc, n, val;
            val = value;
            if (_classes.length > 2) {
                n = _classes.length - 1;
                i = getClass(value);
                minc = _classes[0] + (_classes[1] - _classes[0]) * (0 + _spread * 0.5);
                maxc = _classes[n - 1] + (_classes[n] - _classes[n - 1]) * (1 - _spread * 0.5);
                val = _min + ((_classes[i] + (_classes[i + 1] - _classes[i]) * 0.5 - minc) / (maxc - minc)) * (_max - _min);
            }
            return val;
        };
        getColor = function (val, bypassMap) {
            var c, col, i, k, o, p, ref, t;
            if (bypassMap == null) {
                bypassMap = false;
            }
            if (isNaN(val)) {
                return _nacol;
            }
            if (!bypassMap) {
                if (_classes && _classes.length > 2) {
                    c = getClass(val);
                    t = c / (_classes.length - 2);
                    t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));
                }
                else if (_max !== _min) {
                    t = (val - _min) / (_max - _min);
                    t = _padding[0] + (t * (1 - _padding[0] - _padding[1]));
                    t = Math.min(1, Math.max(0, t));
                }
                else {
                    t = 1;
                }
            }
            else {
                t = val;
            }
            if (!bypassMap) {
                t = tmap(t);
            }
            k = Math.floor(t * 10000);
            if (_colorCache[k]) {
                col = _colorCache[k];
            }
            else {
                if (type(_colors) === 'array') {
                    for (i = o = 0, ref = _pos.length - 1; 0 <= ref ? o <= ref : o >= ref; i = 0 <= ref ? ++o : --o) {
                        p = _pos[i];
                        if (t <= p) {
                            col = _colors[i];
                            break;
                        }
                        if (t >= p && i === _pos.length - 1) {
                            col = _colors[i];
                            break;
                        }
                        if (t > p && t < _pos[i + 1]) {
                            t = (t - p) / (_pos[i + 1] - p);
                            col = chroma.interpolate(_colors[i], _colors[i + 1], t, _mode);
                            break;
                        }
                    }
                }
                else if (type(_colors) === 'function') {
                    col = _colors(t);
                }
                _colorCache[k] = col;
            }
            return col;
        };
        resetCache = function () {
            return _colorCache = {};
        };
        setColors(colors);
        f = function (v) {
            var c;
            c = chroma(getColor(v));
            if (_out && c[_out]) {
                return c[_out]();
            }
            else {
                return c;
            }
        };
        f.classes = function (classes) {
            var d;
            if (classes != null) {
                if (type(classes) === 'array') {
                    _classes = classes;
                    _domain = [classes[0], classes[classes.length - 1]];
                }
                else {
                    d = chroma.analyze(_domain);
                    if (classes === 0) {
                        _classes = [d.min, d.max];
                    }
                    else {
                        _classes = chroma.limits(d, 'e', classes);
                    }
                }
                return f;
            }
            return _classes;
        };
        f.domain = function (domain) {
            var c, d, k, len, o, ref, w;
            if (!arguments.length) {
                return _domain;
            }
            _min = domain[0];
            _max = domain[domain.length - 1];
            _pos = [];
            k = _colors.length;
            if (domain.length === k && _min !== _max) {
                for (o = 0, len = domain.length; o < len; o++) {
                    d = domain[o];
                    _pos.push((d - _min) / (_max - _min));
                }
            }
            else {
                for (c = w = 0, ref = k - 1; 0 <= ref ? w <= ref : w >= ref; c = 0 <= ref ? ++w : --w) {
                    _pos.push(c / (k - 1));
                }
            }
            _domain = [_min, _max];
            return f;
        };
        f.mode = function (_m) {
            if (!arguments.length) {
                return _mode;
            }
            _mode = _m;
            resetCache();
            return f;
        };
        f.range = function (colors, _pos) {
            setColors(colors, _pos);
            return f;
        };
        f.out = function (_o) {
            _out = _o;
            return f;
        };
        f.spread = function (val) {
            if (!arguments.length) {
                return _spread;
            }
            _spread = val;
            return f;
        };
        f.correctLightness = function (v) {
            if (v == null) {
                v = true;
            }
            _correctLightness = v;
            resetCache();
            if (_correctLightness) {
                tmap = function (t) {
                    var L0, L1, L_actual, L_diff, L_ideal, max_iter, pol, t0, t1;
                    L0 = getColor(0, true).lab()[0];
                    L1 = getColor(1, true).lab()[0];
                    pol = L0 > L1;
                    L_actual = getColor(t, true).lab()[0];
                    L_ideal = L0 + (L1 - L0) * t;
                    L_diff = L_actual - L_ideal;
                    t0 = 0;
                    t1 = 1;
                    max_iter = 20;
                    while (Math.abs(L_diff) > 1e-2 && max_iter-- > 0) {
                        (function () {
                            if (pol) {
                                L_diff *= -1;
                            }
                            if (L_diff < 0) {
                                t0 = t;
                                t += (t1 - t) * 0.5;
                            }
                            else {
                                t1 = t;
                                t += (t0 - t) * 0.5;
                            }
                            L_actual = getColor(t, true).lab()[0];
                            return L_diff = L_actual - L_ideal;
                        })();
                    }
                    return t;
                };
            }
            else {
                tmap = function (t) {
                    return t;
                };
            }
            return f;
        };
        f.padding = function (p) {
            if (p != null) {
                if (type(p) === 'number') {
                    p = [p, p];
                }
                _padding = p;
                return f;
            }
            else {
                return _padding;
            }
        };
        f.colors = function () {
            var dd, dm, i, numColors, o, out, ref, results, samples, w;
            numColors = 0;
            out = 'hex';
            if (arguments.length === 1) {
                if (type(arguments[0]) === 'string') {
                    out = arguments[0];
                }
                else {
                    numColors = arguments[0];
                }
            }
            if (arguments.length === 2) {
                numColors = arguments[0], out = arguments[1];
            }
            if (numColors) {
                dm = _domain[0];
                dd = _domain[1] - dm;
                return (function () {
                    results = [];
                    for (var o = 0; 0 <= numColors ? o < numColors : o > numColors; 0 <= numColors ? o++ : o--) {
                        results.push(o);
                    }
                    return results;
                }).apply(this).map(function (i) {
                    return f(dm + i / (numColors - 1) * dd)[out]();
                });
            }
            colors = [];
            samples = [];
            if (_classes && _classes.length > 2) {
                for (i = w = 1, ref = _classes.length; 1 <= ref ? w < ref : w > ref; i = 1 <= ref ? ++w : --w) {
                    samples.push((_classes[i - 1] + _classes[i]) * 0.5);
                }
            }
            else {
                samples = _domain;
            }
            return samples.map(function (v) {
                return f(v)[out]();
            });
        };
        return f;
    };
    if (chroma.scales == null) {
        chroma.scales = {};
    }
    chroma.scales.cool = function () {
        return chroma.scale([chroma.hsl(180, 1, .9), chroma.hsl(250, .7, .4)]);
    };
    chroma.scales.hot = function () {
        return chroma.scale(['#000', '#f00', '#ff0', '#fff'], [0, .25, .75, 1]).mode('rgb');
    };
    chroma.analyze = function (data, key, filter) {
        var add, k, len, o, r, val, visit;
        r = {
            min: Number.MAX_VALUE,
            max: Number.MAX_VALUE * -1,
            sum: 0,
            values: [],
            count: 0
        };
        if (filter == null) {
            filter = function () {
                return true;
            };
        }
        add = function (val) {
            if ((val != null) && !isNaN(val)) {
                r.values.push(val);
                r.sum += val;
                if (val < r.min) {
                    r.min = val;
                }
                if (val > r.max) {
                    r.max = val;
                }
                r.count += 1;
            }
        };
        visit = function (val, k) {
            if (filter(val, k)) {
                if ((key != null) && type(key) === 'function') {
                    return add(key(val));
                }
                else if ((key != null) && type(key) === 'string' || type(key) === 'number') {
                    return add(val[key]);
                }
                else {
                    return add(val);
                }
            }
        };
        if (type(data) === 'array') {
            for (o = 0, len = data.length; o < len; o++) {
                val = data[o];
                visit(val);
            }
        }
        else {
            for (k in data) {
                val = data[k];
                visit(val, k);
            }
        }
        r.domain = [r.min, r.max];
        r.limits = function (mode, num) {
            return chroma.limits(r, mode, num);
        };
        return r;
    };
    chroma.limits = function (data, mode, num) {
        var aa, ab, ac, ad, ae, af, ag, ah, ai, aj, ak, al, am, assignments, best, centroids, cluster, clusterSizes, dist, i, j, kClusters, limits, max_log, min, min_log, mindist, n, nb_iters, newCentroids, o, p, pb, pr, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, repeat, sum, tmpKMeansBreaks, value, values, w;
        if (mode == null) {
            mode = 'equal';
        }
        if (num == null) {
            num = 7;
        }
        if (type(data) === 'array') {
            data = chroma.analyze(data);
        }
        min = data.min;
        max = data.max;
        sum = data.sum;
        values = data.values.sort(function (a, b) {
            return a - b;
        });
        limits = [];
        if (mode.substr(0, 1) === 'c') {
            limits.push(min);
            limits.push(max);
        }
        if (mode.substr(0, 1) === 'e') {
            limits.push(min);
            for (i = o = 1, ref = num - 1; 1 <= ref ? o <= ref : o >= ref; i = 1 <= ref ? ++o : --o) {
                limits.push(min + (i / num) * (max - min));
            }
            limits.push(max);
        }
        else if (mode.substr(0, 1) === 'l') {
            if (min <= 0) {
                throw 'Logarithmic scales are only possible for values > 0';
            }
            min_log = Math.LOG10E * log(min);
            max_log = Math.LOG10E * log(max);
            limits.push(min);
            for (i = w = 1, ref1 = num - 1; 1 <= ref1 ? w <= ref1 : w >= ref1; i = 1 <= ref1 ? ++w : --w) {
                limits.push(pow(10, min_log + (i / num) * (max_log - min_log)));
            }
            limits.push(max);
        }
        else if (mode.substr(0, 1) === 'q') {
            limits.push(min);
            for (i = aa = 1, ref2 = num - 1; 1 <= ref2 ? aa <= ref2 : aa >= ref2; i = 1 <= ref2 ? ++aa : --aa) {
                p = values.length * i / num;
                pb = floor(p);
                if (pb === p) {
                    limits.push(values[pb]);
                }
                else {
                    pr = p - pb;
                    limits.push(values[pb] * pr + values[pb + 1] * (1 - pr));
                }
            }
            limits.push(max);
        }
        else if (mode.substr(0, 1) === 'k') {
            n = values.length;
            assignments = new Array(n);
            clusterSizes = new Array(num);
            repeat = true;
            nb_iters = 0;
            centroids = null;
            centroids = [];
            centroids.push(min);
            for (i = ab = 1, ref3 = num - 1; 1 <= ref3 ? ab <= ref3 : ab >= ref3; i = 1 <= ref3 ? ++ab : --ab) {
                centroids.push(min + (i / num) * (max - min));
            }
            centroids.push(max);
            while (repeat) {
                for (j = ac = 0, ref4 = num - 1; 0 <= ref4 ? ac <= ref4 : ac >= ref4; j = 0 <= ref4 ? ++ac : --ac) {
                    clusterSizes[j] = 0;
                }
                for (i = ad = 0, ref5 = n - 1; 0 <= ref5 ? ad <= ref5 : ad >= ref5; i = 0 <= ref5 ? ++ad : --ad) {
                    value = values[i];
                    mindist = Number.MAX_VALUE;
                    for (j = ae = 0, ref6 = num - 1; 0 <= ref6 ? ae <= ref6 : ae >= ref6; j = 0 <= ref6 ? ++ae : --ae) {
                        dist = abs(centroids[j] - value);
                        if (dist < mindist) {
                            mindist = dist;
                            best = j;
                        }
                    }
                    clusterSizes[best]++;
                    assignments[i] = best;
                }
                newCentroids = new Array(num);
                for (j = af = 0, ref7 = num - 1; 0 <= ref7 ? af <= ref7 : af >= ref7; j = 0 <= ref7 ? ++af : --af) {
                    newCentroids[j] = null;
                }
                for (i = ag = 0, ref8 = n - 1; 0 <= ref8 ? ag <= ref8 : ag >= ref8; i = 0 <= ref8 ? ++ag : --ag) {
                    cluster = assignments[i];
                    if (newCentroids[cluster] === null) {
                        newCentroids[cluster] = values[i];
                    }
                    else {
                        newCentroids[cluster] += values[i];
                    }
                }
                for (j = ah = 0, ref9 = num - 1; 0 <= ref9 ? ah <= ref9 : ah >= ref9; j = 0 <= ref9 ? ++ah : --ah) {
                    newCentroids[j] *= 1 / clusterSizes[j];
                }
                repeat = false;
                for (j = ai = 0, ref10 = num - 1; 0 <= ref10 ? ai <= ref10 : ai >= ref10; j = 0 <= ref10 ? ++ai : --ai) {
                    if (newCentroids[j] !== centroids[i]) {
                        repeat = true;
                        break;
                    }
                }
                centroids = newCentroids;
                nb_iters++;
                if (nb_iters > 200) {
                    repeat = false;
                }
            }
            kClusters = {};
            for (j = aj = 0, ref11 = num - 1; 0 <= ref11 ? aj <= ref11 : aj >= ref11; j = 0 <= ref11 ? ++aj : --aj) {
                kClusters[j] = [];
            }
            for (i = ak = 0, ref12 = n - 1; 0 <= ref12 ? ak <= ref12 : ak >= ref12; i = 0 <= ref12 ? ++ak : --ak) {
                cluster = assignments[i];
                kClusters[cluster].push(values[i]);
            }
            tmpKMeansBreaks = [];
            for (j = al = 0, ref13 = num - 1; 0 <= ref13 ? al <= ref13 : al >= ref13; j = 0 <= ref13 ? ++al : --al) {
                tmpKMeansBreaks.push(kClusters[j][0]);
                tmpKMeansBreaks.push(kClusters[j][kClusters[j].length - 1]);
            }
            tmpKMeansBreaks = tmpKMeansBreaks.sort(function (a, b) {
                return a - b;
            });
            limits.push(tmpKMeansBreaks[0]);
            for (i = am = 1, ref14 = tmpKMeansBreaks.length - 1; am <= ref14; i = am += 2) {
                if (!isNaN(tmpKMeansBreaks[i])) {
                    limits.push(tmpKMeansBreaks[i]);
                }
            }
        }
        return limits;
    };
    hsi2rgb = function (h, s, i) {
        var args, b, g, r;
        args = unpack(arguments);
        h = args[0], s = args[1], i = args[2];
        h /= 360;
        if (h < 1 / 3) {
            b = (1 - s) / 3;
            r = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
            g = 1 - (b + r);
        }
        else if (h < 2 / 3) {
            h -= 1 / 3;
            r = (1 - s) / 3;
            g = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
            b = 1 - (r + g);
        }
        else {
            h -= 2 / 3;
            g = (1 - s) / 3;
            b = (1 + s * cos(TWOPI * h) / cos(PITHIRD - TWOPI * h)) / 3;
            r = 1 - (g + b);
        }
        r = limit(i * r * 3);
        g = limit(i * g * 3);
        b = limit(i * b * 3);
        return [r * 255, g * 255, b * 255, args.length > 3 ? args[3] : 1];
    };
    rgb2hsi = function () {
        var b, g, h, i, min, r, ref, s;
        ref = unpack(arguments), r = ref[0], g = ref[1], b = ref[2];
        TWOPI = Math.PI * 2;
        r /= 255;
        g /= 255;
        b /= 255;
        min = Math.min(r, g, b);
        i = (r + g + b) / 3;
        s = 1 - min / i;
        if (s === 0) {
            h = 0;
        }
        else {
            h = ((r - g) + (r - b)) / 2;
            h /= Math.sqrt((r - g) * (r - g) + (r - b) * (g - b));
            h = Math.acos(h);
            if (b > g) {
                h = TWOPI - h;
            }
            h /= TWOPI;
        }
        return [h * 360, s, i];
    };
    chroma.hsi = function () {
        return (function (func, args, ctor) {
            ctor.prototype = func.prototype;
            var child = new ctor, result = func.apply(child, args);
            return Object(result) === result ? result : child;
        })(Color, slice.call(arguments).concat(['hsi']), function () { });
    };
    _input.hsi = hsi2rgb;
    Color.prototype.hsi = function () {
        return rgb2hsi(this._rgb);
    };
    interpolate_hsx = function (col1, col2, f, m) {
        var dh, hue, hue0, hue1, lbv, lbv0, lbv1, res, sat, sat0, sat1, xyz0, xyz1;
        if (m === 'hsl') {
            xyz0 = col1.hsl();
            xyz1 = col2.hsl();
        }
        else if (m === 'hsv') {
            xyz0 = col1.hsv();
            xyz1 = col2.hsv();
        }
        else if (m === 'hsi') {
            xyz0 = col1.hsi();
            xyz1 = col2.hsi();
        }
        else if (m === 'lch' || m === 'hcl') {
            m = 'hcl';
            xyz0 = col1.hcl();
            xyz1 = col2.hcl();
        }
        if (m.substr(0, 1) === 'h') {
            hue0 = xyz0[0], sat0 = xyz0[1], lbv0 = xyz0[2];
            hue1 = xyz1[0], sat1 = xyz1[1], lbv1 = xyz1[2];
        }
        if (!isNaN(hue0) && !isNaN(hue1)) {
            if (hue1 > hue0 && hue1 - hue0 > 180) {
                dh = hue1 - (hue0 + 360);
            }
            else if (hue1 < hue0 && hue0 - hue1 > 180) {
                dh = hue1 + 360 - hue0;
            }
            else {
                dh = hue1 - hue0;
            }
            hue = hue0 + f * dh;
        }
        else if (!isNaN(hue0)) {
            hue = hue0;
            if ((lbv1 === 1 || lbv1 === 0) && m !== 'hsv') {
                sat = sat0;
            }
        }
        else if (!isNaN(hue1)) {
            hue = hue1;
            if ((lbv0 === 1 || lbv0 === 0) && m !== 'hsv') {
                sat = sat1;
            }
        }
        else {
            hue = Number.NaN;
        }
        if (sat == null) {
            sat = sat0 + f * (sat1 - sat0);
        }
        lbv = lbv0 + f * (lbv1 - lbv0);
        return res = chroma[m](hue, sat, lbv);
    };
    _interpolators = _interpolators.concat((function () {
        var len, o, ref, results;
        ref = ['hsv', 'hsl', 'hsi', 'hcl', 'lch'];
        results = [];
        for (o = 0, len = ref.length; o < len; o++) {
            m = ref[o];
            results.push([m, interpolate_hsx]);
        }
        return results;
    })());
    interpolate_num = function (col1, col2, f, m) {
        var n1, n2;
        n1 = col1.num();
        n2 = col2.num();
        return chroma.num(n1 + (n2 - n1) * f, 'num');
    };
    _interpolators.push(['num', interpolate_num]);
    interpolate_lab = function (col1, col2, f, m) {
        var res, xyz0, xyz1;
        xyz0 = col1.lab();
        xyz1 = col2.lab();
        return res = new Color(xyz0[0] + f * (xyz1[0] - xyz0[0]), xyz0[1] + f * (xyz1[1] - xyz0[1]), xyz0[2] + f * (xyz1[2] - xyz0[2]), m);
    };
    _interpolators.push(['lab', interpolate_lab]);
}).call(this);
var LZString = function () { function o(o, r) { if (!t[o]) {
    t[o] = {};
    for (var n = 0; n < o.length; n++)
        t[o][o.charAt(n)] = n;
} return t[o][r]; } var r = String.fromCharCode, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", t = {}, i = { compressToBase64: function (o) { if (null == o)
        return ""; var r = i._compress(o, 6, function (o) { return n.charAt(o); }); switch (r.length % 4) {
        default:
        case 0: return r;
        case 1: return r + "===";
        case 2: return r + "==";
        case 3: return r + "=";
    } }, decompressFromBase64: function (r) { return null == r ? "" : "" == r ? null : i._decompress(r.length, 32, function (e) { return o(n, r.charAt(e)); }); }, compressToUTF16: function (o) { return null == o ? "" : i._compress(o, 15, function (o) { return r(o + 32); }) + " "; }, decompressFromUTF16: function (o) { return null == o ? "" : "" == o ? null : i._decompress(o.length, 16384, function (r) { return o.charCodeAt(r) - 32; }); }, compressToUint8Array: function (o) { for (var r = i.compress(o), n = new Uint8Array(2 * r.length), e = 0, t = r.length; t > e; e++) {
        var s = r.charCodeAt(e);
        n[2 * e] = s >>> 8, n[2 * e + 1] = s % 256;
    } return n; }, decompressFromUint8Array: function (o) { if (null === o || void 0 === o)
        return i.decompress(o); for (var n = new Array(o.length / 2), e = 0, t = n.length; t > e; e++)
        n[e] = 256 * o[2 * e] + o[2 * e + 1]; var s = []; return n.forEach(function (o) { s.push(r(o)); }), i.decompress(s.join("")); }, compressToEncodedURIComponent: function (o) { return null == o ? "" : i._compress(o, 6, function (o) { return e.charAt(o); }); }, decompressFromEncodedURIComponent: function (r) { return null == r ? "" : "" == r ? null : (r = r.replace(/ /g, "+"), i._decompress(r.length, 32, function (n) { return o(e, r.charAt(n)); })); }, compress: function (o) { return i._compress(o, 16, function (o) { return r(o); }); }, _compress: function (o, r, n) { if (null == o)
        return ""; var e, t, i, s = {}, p = {}, u = "", c = "", a = "", l = 2, f = 3, h = 2, d = [], m = 0, v = 0; for (i = 0; i < o.length; i += 1)
        if (u = o.charAt(i), Object.prototype.hasOwnProperty.call(s, u) || (s[u] = f++, p[u] = !0), c = a + u, Object.prototype.hasOwnProperty.call(s, c))
            a = c;
        else {
            if (Object.prototype.hasOwnProperty.call(p, a)) {
                if (a.charCodeAt(0) < 256) {
                    for (e = 0; h > e; e++)
                        m <<= 1, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++;
                    for (t = a.charCodeAt(0), e = 0; 8 > e; e++)
                        m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
                }
                else {
                    for (t = 1, e = 0; h > e; e++)
                        m = m << 1 | t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t = 0;
                    for (t = a.charCodeAt(0), e = 0; 16 > e; e++)
                        m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
                }
                l--, 0 == l && (l = Math.pow(2, h), h++), delete p[a];
            }
            else
                for (t = s[a], e = 0; h > e; e++)
                    m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
            l--, 0 == l && (l = Math.pow(2, h), h++), s[c] = f++, a = String(u);
        } if ("" !== a) {
        if (Object.prototype.hasOwnProperty.call(p, a)) {
            if (a.charCodeAt(0) < 256) {
                for (e = 0; h > e; e++)
                    m <<= 1, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++;
                for (t = a.charCodeAt(0), e = 0; 8 > e; e++)
                    m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
            }
            else {
                for (t = 1, e = 0; h > e; e++)
                    m = m << 1 | t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t = 0;
                for (t = a.charCodeAt(0), e = 0; 16 > e; e++)
                    m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
            }
            l--, 0 == l && (l = Math.pow(2, h), h++), delete p[a];
        }
        else
            for (t = s[a], e = 0; h > e; e++)
                m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1;
        l--, 0 == l && (l = Math.pow(2, h), h++);
    } for (t = 2, e = 0; h > e; e++)
        m = m << 1 | 1 & t, v == r - 1 ? (v = 0, d.push(n(m)), m = 0) : v++, t >>= 1; for (;;) {
        if (m <<= 1, v == r - 1) {
            d.push(n(m));
            break;
        }
        v++;
    } return d.join(""); }, decompress: function (o) { return null == o ? "" : "" == o ? null : i._decompress(o.length, 32768, function (r) { return o.charCodeAt(r); }); }, _decompress: function (o, n, e) { var t, i, s, p, u, c, a, l, f = [], h = 4, d = 4, m = 3, v = "", w = [], A = { val: e(0), position: n, index: 1 }; for (i = 0; 3 > i; i += 1)
        f[i] = i; for (p = 0, c = Math.pow(2, 2), a = 1; a != c;)
        u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1; switch (t = p) {
        case 0:
            for (p = 0, c = Math.pow(2, 8), a = 1; a != c;)
                u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;
            l = r(p);
            break;
        case 1:
            for (p = 0, c = Math.pow(2, 16), a = 1; a != c;)
                u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;
            l = r(p);
            break;
        case 2: return "";
    } for (f[3] = l, s = l, w.push(l);;) {
        if (A.index > o)
            return "";
        for (p = 0, c = Math.pow(2, m), a = 1; a != c;)
            u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;
        switch (l = p) {
            case 0:
                for (p = 0, c = Math.pow(2, 8), a = 1; a != c;)
                    u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;
                f[d++] = r(p), l = d - 1, h--;
                break;
            case 1:
                for (p = 0, c = Math.pow(2, 16), a = 1; a != c;)
                    u = A.val & A.position, A.position >>= 1, 0 == A.position && (A.position = n, A.val = e(A.index++)), p |= (u > 0 ? 1 : 0) * a, a <<= 1;
                f[d++] = r(p), l = d - 1, h--;
                break;
            case 2: return w.join("");
        }
        if (0 == h && (h = Math.pow(2, m), m++), f[l])
            v = f[l];
        else {
            if (l !== d)
                return null;
            v = s + s.charAt(0);
        }
        w.push(v), f[d++] = s + v.charAt(0), h--, s = v, 0 == h && (h = Math.pow(2, m), m++);
    } } }; return i; }();
"function" == typeof define && define.amd ? define(function () { return LZString; }) : "undefined" != typeof module && null != module && (module.exports = LZString);
!function (a, b) { "object" == typeof exports && "undefined" != typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define(b) : a.moment = b(); }(this, function () {
    "use strict";
    function a() { return Dc.apply(null, arguments); }
    function b(a) { Dc = a; }
    function c(a) { return "[object Array]" === Object.prototype.toString.call(a); }
    function d(a) { return a instanceof Date || "[object Date]" === Object.prototype.toString.call(a); }
    function e(a, b) { var c, d = []; for (c = 0; c < a.length; ++c)
        d.push(b(a[c], c)); return d; }
    function f(a, b) { return Object.prototype.hasOwnProperty.call(a, b); }
    function g(a, b) { for (var c in b)
        f(b, c) && (a[c] = b[c]); return f(b, "toString") && (a.toString = b.toString), f(b, "valueOf") && (a.valueOf = b.valueOf), a; }
    function h(a, b, c, d) { return za(a, b, c, d, !0).utc(); }
    function i() { return { empty: !1, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: !1, invalidMonth: null, invalidFormat: !1, userInvalidated: !1, iso: !1 }; }
    function j(a) { return null == a._pf && (a._pf = i()), a._pf; }
    function k(a) { if (null == a._isValid) {
        var b = j(a);
        a._isValid = !isNaN(a._d.getTime()) && b.overflow < 0 && !b.empty && !b.invalidMonth && !b.nullInput && !b.invalidFormat && !b.userInvalidated, a._strict && (a._isValid = a._isValid && 0 === b.charsLeftOver && 0 === b.unusedTokens.length && void 0 === b.bigHour);
    } return a._isValid; }
    function l(a) { var b = h(0 / 0); return null != a ? g(j(b), a) : j(b).userInvalidated = !0, b; }
    function m(a, b) { var c, d, e; if ("undefined" != typeof b._isAMomentObject && (a._isAMomentObject = b._isAMomentObject), "undefined" != typeof b._i && (a._i = b._i), "undefined" != typeof b._f && (a._f = b._f), "undefined" != typeof b._l && (a._l = b._l), "undefined" != typeof b._strict && (a._strict = b._strict), "undefined" != typeof b._tzm && (a._tzm = b._tzm), "undefined" != typeof b._isUTC && (a._isUTC = b._isUTC), "undefined" != typeof b._offset && (a._offset = b._offset), "undefined" != typeof b._pf && (a._pf = j(b)), "undefined" != typeof b._locale && (a._locale = b._locale), Fc.length > 0)
        for (c in Fc)
            d = Fc[c], e = b[d], "undefined" != typeof e && (a[d] = e); return a; }
    function n(b) { m(this, b), this._d = new Date(+b._d), Gc === !1 && (Gc = !0, a.updateOffset(this), Gc = !1); }
    function o(a) { return a instanceof n || null != a && null != a._isAMomentObject; }
    function p(a) { var b = +a, c = 0; return 0 !== b && isFinite(b) && (c = b >= 0 ? Math.floor(b) : Math.ceil(b)), c; }
    function q(a, b, c) { var d, e = Math.min(a.length, b.length), f = Math.abs(a.length - b.length), g = 0; for (d = 0; e > d; d++)
        (c && a[d] !== b[d] || !c && p(a[d]) !== p(b[d])) && g++; return g + f; }
    function r() { }
    function s(a) { return a ? a.toLowerCase().replace("_", "-") : a; }
    function t(a) { for (var b, c, d, e, f = 0; f < a.length;) {
        for (e = s(a[f]).split("-"), b = e.length, c = s(a[f + 1]), c = c ? c.split("-") : null; b > 0;) {
            if (d = u(e.slice(0, b).join("-")))
                return d;
            if (c && c.length >= b && q(e, c, !0) >= b - 1)
                break;
            b--;
        }
        f++;
    } return null; }
    function u(a) { var b = null; if (!Hc[a] && "undefined" != typeof module && module && module.exports)
        try {
            b = Ec._abbr, require("./locale/" + a), v(b);
        }
        catch (c) { } return Hc[a]; }
    function v(a, b) { var c; return a && (c = "undefined" == typeof b ? x(a) : w(a, b), c && (Ec = c)), Ec._abbr; }
    function w(a, b) { return null !== b ? (b.abbr = a, Hc[a] || (Hc[a] = new r), Hc[a].set(b), v(a), Hc[a]) : (delete Hc[a], null); }
    function x(a) { var b; if (a && a._locale && a._locale._abbr && (a = a._locale._abbr), !a)
        return Ec; if (!c(a)) {
        if (b = u(a))
            return b;
        a = [a];
    } return t(a); }
    function y(a, b) { var c = a.toLowerCase(); Ic[c] = Ic[c + "s"] = Ic[b] = a; }
    function z(a) { return "string" == typeof a ? Ic[a] || Ic[a.toLowerCase()] : void 0; }
    function A(a) { var b, c, d = {}; for (c in a)
        f(a, c) && (b = z(c), b && (d[b] = a[c])); return d; }
    function B(b, c) { return function (d) { return null != d ? (D(this, b, d), a.updateOffset(this, c), this) : C(this, b); }; }
    function C(a, b) { return a._d["get" + (a._isUTC ? "UTC" : "") + b](); }
    function D(a, b, c) { return a._d["set" + (a._isUTC ? "UTC" : "") + b](c); }
    function E(a, b) { var c; if ("object" == typeof a)
        for (c in a)
            this.set(c, a[c]);
    else if (a = z(a), "function" == typeof this[a])
        return this[a](b); return this; }
    function F(a, b, c) { for (var d = "" + Math.abs(a), e = a >= 0; d.length < b;)
        d = "0" + d; return (e ? c ? "+" : "" : "-") + d; }
    function G(a, b, c, d) { var e = d; "string" == typeof d && (e = function () { return this[d](); }), a && (Mc[a] = e), b && (Mc[b[0]] = function () { return F(e.apply(this, arguments), b[1], b[2]); }), c && (Mc[c] = function () { return this.localeData().ordinal(e.apply(this, arguments), a); }); }
    function H(a) { return a.match(/\[[\s\S]/) ? a.replace(/^\[|\]$/g, "") : a.replace(/\\/g, ""); }
    function I(a) { var b, c, d = a.match(Jc); for (b = 0, c = d.length; c > b; b++)
        Mc[d[b]] ? d[b] = Mc[d[b]] : d[b] = H(d[b]); return function (e) { var f = ""; for (b = 0; c > b; b++)
        f += d[b] instanceof Function ? d[b].call(e, a) : d[b]; return f; }; }
    function J(a, b) { return a.isValid() ? (b = K(b, a.localeData()), Lc[b] || (Lc[b] = I(b)), Lc[b](a)) : a.localeData().invalidDate(); }
    function K(a, b) { function c(a) { return b.longDateFormat(a) || a; } var d = 5; for (Kc.lastIndex = 0; d >= 0 && Kc.test(a);)
        a = a.replace(Kc, c), Kc.lastIndex = 0, d -= 1; return a; }
    function L(a, b, c) { _c[a] = "function" == typeof b ? b : function (a) { return a && c ? c : b; }; }
    function M(a, b) { return f(_c, a) ? _c[a](b._strict, b._locale) : new RegExp(N(a)); }
    function N(a) { return a.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (a, b, c, d, e) { return b || c || d || e; }).replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"); }
    function O(a, b) { var c, d = b; for ("string" == typeof a && (a = [a]), "number" == typeof b && (d = function (a, c) { c[b] = p(a); }), c = 0; c < a.length; c++)
        ad[a[c]] = d; }
    function P(a, b) { O(a, function (a, c, d, e) { d._w = d._w || {}, b(a, d._w, d, e); }); }
    function Q(a, b, c) { null != b && f(ad, a) && ad[a](b, c._a, c, a); }
    function R(a, b) { return new Date(Date.UTC(a, b + 1, 0)).getUTCDate(); }
    function S(a) { return this._months[a.month()]; }
    function T(a) { return this._monthsShort[a.month()]; }
    function U(a, b, c) { var d, e, f; for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), d = 0; 12 > d; d++) {
        if (e = h([2e3, d]), c && !this._longMonthsParse[d] && (this._longMonthsParse[d] = new RegExp("^" + this.months(e, "").replace(".", "") + "$", "i"), this._shortMonthsParse[d] = new RegExp("^" + this.monthsShort(e, "").replace(".", "") + "$", "i")), c || this._monthsParse[d] || (f = "^" + this.months(e, "") + "|^" + this.monthsShort(e, ""), this._monthsParse[d] = new RegExp(f.replace(".", ""), "i")), c && "MMMM" === b && this._longMonthsParse[d].test(a))
            return d;
        if (c && "MMM" === b && this._shortMonthsParse[d].test(a))
            return d;
        if (!c && this._monthsParse[d].test(a))
            return d;
    } }
    function V(a, b) { var c; return "string" == typeof b && (b = a.localeData().monthsParse(b), "number" != typeof b) ? a : (c = Math.min(a.date(), R(a.year(), b)), a._d["set" + (a._isUTC ? "UTC" : "") + "Month"](b, c), a); }
    function W(b) { return null != b ? (V(this, b), a.updateOffset(this, !0), this) : C(this, "Month"); }
    function X() { return R(this.year(), this.month()); }
    function Y(a) { var b, c = a._a; return c && -2 === j(a).overflow && (b = c[cd] < 0 || c[cd] > 11 ? cd : c[dd] < 1 || c[dd] > R(c[bd], c[cd]) ? dd : c[ed] < 0 || c[ed] > 24 || 24 === c[ed] && (0 !== c[fd] || 0 !== c[gd] || 0 !== c[hd]) ? ed : c[fd] < 0 || c[fd] > 59 ? fd : c[gd] < 0 || c[gd] > 59 ? gd : c[hd] < 0 || c[hd] > 999 ? hd : -1, j(a)._overflowDayOfYear && (bd > b || b > dd) && (b = dd), j(a).overflow = b), a; }
    function Z(b) { a.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + b); }
    function $(a, b) { var c = !0, d = a + "\n" + (new Error).stack; return g(function () { return c && (Z(d), c = !1), b.apply(this, arguments); }, b); }
    function _(a, b) { kd[a] || (Z(b), kd[a] = !0); }
    function aa(a) { var b, c, d = a._i, e = ld.exec(d); if (e) {
        for (j(a).iso = !0, b = 0, c = md.length; c > b; b++)
            if (md[b][1].exec(d)) {
                a._f = md[b][0] + (e[6] || " ");
                break;
            }
        for (b = 0, c = nd.length; c > b; b++)
            if (nd[b][1].exec(d)) {
                a._f += nd[b][0];
                break;
            }
        d.match(Yc) && (a._f += "Z"), ta(a);
    }
    else
        a._isValid = !1; }
    function ba(b) { var c = od.exec(b._i); return null !== c ? void (b._d = new Date(+c[1])) : (aa(b), void (b._isValid === !1 && (delete b._isValid, a.createFromInputFallback(b)))); }
    function ca(a, b, c, d, e, f, g) { var h = new Date(a, b, c, d, e, f, g); return 1970 > a && h.setFullYear(a), h; }
    function da(a) { var b = new Date(Date.UTC.apply(null, arguments)); return 1970 > a && b.setUTCFullYear(a), b; }
    function ea(a) { return fa(a) ? 366 : 365; }
    function fa(a) { return a % 4 === 0 && a % 100 !== 0 || a % 400 === 0; }
    function ga() { return fa(this.year()); }
    function ha(a, b, c) { var d, e = c - b, f = c - a.day(); return f > e && (f -= 7), e - 7 > f && (f += 7), d = Aa(a).add(f, "d"), { week: Math.ceil(d.dayOfYear() / 7), year: d.year() }; }
    function ia(a) { return ha(a, this._week.dow, this._week.doy).week; }
    function ja() { return this._week.dow; }
    function ka() { return this._week.doy; }
    function la(a) { var b = this.localeData().week(this); return null == a ? b : this.add(7 * (a - b), "d"); }
    function ma(a) { var b = ha(this, 1, 4).week; return null == a ? b : this.add(7 * (a - b), "d"); }
    function na(a, b, c, d, e) { var f, g, h = da(a, 0, 1).getUTCDay(); return h = 0 === h ? 7 : h, c = null != c ? c : e, f = e - h + (h > d ? 7 : 0) - (e > h ? 7 : 0), g = 7 * (b - 1) + (c - e) + f + 1, { year: g > 0 ? a : a - 1, dayOfYear: g > 0 ? g : ea(a - 1) + g }; }
    function oa(a) { var b = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1; return null == a ? b : this.add(a - b, "d"); }
    function pa(a, b, c) { return null != a ? a : null != b ? b : c; }
    function qa(a) { var b = new Date; return a._useUTC ? [b.getUTCFullYear(), b.getUTCMonth(), b.getUTCDate()] : [b.getFullYear(), b.getMonth(), b.getDate()]; }
    function ra(a) { var b, c, d, e, f = []; if (!a._d) {
        for (d = qa(a), a._w && null == a._a[dd] && null == a._a[cd] && sa(a), a._dayOfYear && (e = pa(a._a[bd], d[bd]), a._dayOfYear > ea(e) && (j(a)._overflowDayOfYear = !0), c = da(e, 0, a._dayOfYear), a._a[cd] = c.getUTCMonth(), a._a[dd] = c.getUTCDate()), b = 0; 3 > b && null == a._a[b]; ++b)
            a._a[b] = f[b] = d[b];
        for (; 7 > b; b++)
            a._a[b] = f[b] = null == a._a[b] ? 2 === b ? 1 : 0 : a._a[b];
        24 === a._a[ed] && 0 === a._a[fd] && 0 === a._a[gd] && 0 === a._a[hd] && (a._nextDay = !0, a._a[ed] = 0), a._d = (a._useUTC ? da : ca).apply(null, f), null != a._tzm && a._d.setUTCMinutes(a._d.getUTCMinutes() - a._tzm), a._nextDay && (a._a[ed] = 24);
    } }
    function sa(a) { var b, c, d, e, f, g, h; b = a._w, null != b.GG || null != b.W || null != b.E ? (f = 1, g = 4, c = pa(b.GG, a._a[bd], ha(Aa(), 1, 4).year), d = pa(b.W, 1), e = pa(b.E, 1)) : (f = a._locale._week.dow, g = a._locale._week.doy, c = pa(b.gg, a._a[bd], ha(Aa(), f, g).year), d = pa(b.w, 1), null != b.d ? (e = b.d, f > e && ++d) : e = null != b.e ? b.e + f : f), h = na(c, d, e, g, f), a._a[bd] = h.year, a._dayOfYear = h.dayOfYear; }
    function ta(b) { if (b._f === a.ISO_8601)
        return void aa(b); b._a = [], j(b).empty = !0; var c, d, e, f, g, h = "" + b._i, i = h.length, k = 0; for (e = K(b._f, b._locale).match(Jc) || [], c = 0; c < e.length; c++)
        f = e[c], d = (h.match(M(f, b)) || [])[0], d && (g = h.substr(0, h.indexOf(d)), g.length > 0 && j(b).unusedInput.push(g), h = h.slice(h.indexOf(d) + d.length), k += d.length), Mc[f] ? (d ? j(b).empty = !1 : j(b).unusedTokens.push(f), Q(f, d, b)) : b._strict && !d && j(b).unusedTokens.push(f); j(b).charsLeftOver = i - k, h.length > 0 && j(b).unusedInput.push(h), j(b).bigHour === !0 && b._a[ed] <= 12 && b._a[ed] > 0 && (j(b).bigHour = void 0), b._a[ed] = ua(b._locale, b._a[ed], b._meridiem), ra(b), Y(b); }
    function ua(a, b, c) { var d; return null == c ? b : null != a.meridiemHour ? a.meridiemHour(b, c) : null != a.isPM ? (d = a.isPM(c), d && 12 > b && (b += 12), d || 12 !== b || (b = 0), b) : b; }
    function va(a) { var b, c, d, e, f; if (0 === a._f.length)
        return j(a).invalidFormat = !0, void (a._d = new Date(0 / 0)); for (e = 0; e < a._f.length; e++)
        f = 0, b = m({}, a), null != a._useUTC && (b._useUTC = a._useUTC), b._f = a._f[e], ta(b), k(b) && (f += j(b).charsLeftOver, f += 10 * j(b).unusedTokens.length, j(b).score = f, (null == d || d > f) && (d = f, c = b)); g(a, c || b); }
    function wa(a) { if (!a._d) {
        var b = A(a._i);
        a._a = [b.year, b.month, b.day || b.date, b.hour, b.minute, b.second, b.millisecond], ra(a);
    } }
    function xa(a) { var b, e = a._i, f = a._f; return a._locale = a._locale || x(a._l), null === e || void 0 === f && "" === e ? l({ nullInput: !0 }) : ("string" == typeof e && (a._i = e = a._locale.preparse(e)), o(e) ? new n(Y(e)) : (c(f) ? va(a) : f ? ta(a) : d(e) ? a._d = e : ya(a), b = new n(Y(a)), b._nextDay && (b.add(1, "d"), b._nextDay = void 0), b)); }
    function ya(b) { var f = b._i; void 0 === f ? b._d = new Date : d(f) ? b._d = new Date(+f) : "string" == typeof f ? ba(b) : c(f) ? (b._a = e(f.slice(0), function (a) { return parseInt(a, 10); }), ra(b)) : "object" == typeof f ? wa(b) : "number" == typeof f ? b._d = new Date(f) : a.createFromInputFallback(b); }
    function za(a, b, c, d, e) { var f = {}; return "boolean" == typeof c && (d = c, c = void 0), f._isAMomentObject = !0, f._useUTC = f._isUTC = e, f._l = c, f._i = a, f._f = b, f._strict = d, xa(f); }
    function Aa(a, b, c, d) { return za(a, b, c, d, !1); }
    function Ba(a, b) { var d, e; if (1 === b.length && c(b[0]) && (b = b[0]), !b.length)
        return Aa(); for (d = b[0], e = 1; e < b.length; ++e)
        b[e][a](d) && (d = b[e]); return d; }
    function Ca() { var a = [].slice.call(arguments, 0); return Ba("isBefore", a); }
    function Da() { var a = [].slice.call(arguments, 0); return Ba("isAfter", a); }
    function Ea(a) { var b = A(a), c = b.year || 0, d = b.quarter || 0, e = b.month || 0, f = b.week || 0, g = b.day || 0, h = b.hour || 0, i = b.minute || 0, j = b.second || 0, k = b.millisecond || 0; this._milliseconds = +k + 1e3 * j + 6e4 * i + 36e5 * h, this._days = +g + 7 * f, this._months = +e + 3 * d + 12 * c, this._data = {}, this._locale = x(), this._bubble(); }
    function Fa(a) { return a instanceof Ea; }
    function Ga(a, b) { G(a, 0, 0, function () { var a = this.utcOffset(), c = "+"; return 0 > a && (a = -a, c = "-"), c + F(~~(a / 60), 2) + b + F(~~a % 60, 2); }); }
    function Ha(a) { var b = (a || "").match(Yc) || [], c = b[b.length - 1] || [], d = (c + "").match(td) || ["-", 0, 0], e = +(60 * d[1]) + p(d[2]); return "+" === d[0] ? e : -e; }
    function Ia(b, c) { var e, f; return c._isUTC ? (e = c.clone(), f = (o(b) || d(b) ? +b : +Aa(b)) - +e, e._d.setTime(+e._d + f), a.updateOffset(e, !1), e) : Aa(b).local(); return c._isUTC ? Aa(b).zone(c._offset || 0) : Aa(b).local(); }
    function Ja(a) { return 15 * -Math.round(a._d.getTimezoneOffset() / 15); }
    function Ka(b, c) { var d, e = this._offset || 0; return null != b ? ("string" == typeof b && (b = Ha(b)), Math.abs(b) < 16 && (b = 60 * b), !this._isUTC && c && (d = Ja(this)), this._offset = b, this._isUTC = !0, null != d && this.add(d, "m"), e !== b && (!c || this._changeInProgress ? $a(this, Va(b - e, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, a.updateOffset(this, !0), this._changeInProgress = null)), this) : this._isUTC ? e : Ja(this); }
    function La(a, b) { return null != a ? ("string" != typeof a && (a = -a), this.utcOffset(a, b), this) : -this.utcOffset(); }
    function Ma(a) { return this.utcOffset(0, a); }
    function Na(a) { return this._isUTC && (this.utcOffset(0, a), this._isUTC = !1, a && this.subtract(Ja(this), "m")), this; }
    function Oa() { return this._tzm ? this.utcOffset(this._tzm) : "string" == typeof this._i && this.utcOffset(Ha(this._i)), this; }
    function Pa(a) { return a = a ? Aa(a).utcOffset() : 0, (this.utcOffset() - a) % 60 === 0; }
    function Qa() { return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset(); }
    function Ra() { if (this._a) {
        var a = this._isUTC ? h(this._a) : Aa(this._a);
        return this.isValid() && q(this._a, a.toArray()) > 0;
    } return !1; }
    function Sa() { return !this._isUTC; }
    function Ta() { return this._isUTC; }
    function Ua() { return this._isUTC && 0 === this._offset; }
    function Va(a, b) { var c, d, e, g = a, h = null; return Fa(a) ? g = { ms: a._milliseconds, d: a._days, M: a._months } : "number" == typeof a ? (g = {}, b ? g[b] = a : g.milliseconds = a) : (h = ud.exec(a)) ? (c = "-" === h[1] ? -1 : 1, g = { y: 0, d: p(h[dd]) * c, h: p(h[ed]) * c, m: p(h[fd]) * c, s: p(h[gd]) * c, ms: p(h[hd]) * c }) : (h = vd.exec(a)) ? (c = "-" === h[1] ? -1 : 1, g = { y: Wa(h[2], c), M: Wa(h[3], c), d: Wa(h[4], c), h: Wa(h[5], c), m: Wa(h[6], c), s: Wa(h[7], c), w: Wa(h[8], c) }) : null == g ? g = {} : "object" == typeof g && ("from" in g || "to" in g) && (e = Ya(Aa(g.from), Aa(g.to)), g = {}, g.ms = e.milliseconds, g.M = e.months), d = new Ea(g), Fa(a) && f(a, "_locale") && (d._locale = a._locale), d; }
    function Wa(a, b) { var c = a && parseFloat(a.replace(",", ".")); return (isNaN(c) ? 0 : c) * b; }
    function Xa(a, b) { var c = { milliseconds: 0, months: 0 }; return c.months = b.month() - a.month() + 12 * (b.year() - a.year()), a.clone().add(c.months, "M").isAfter(b) && --c.months, c.milliseconds = +b - +a.clone().add(c.months, "M"), c; }
    function Ya(a, b) { var c; return b = Ia(b, a), a.isBefore(b) ? c = Xa(a, b) : (c = Xa(b, a), c.milliseconds = -c.milliseconds, c.months = -c.months), c; }
    function Za(a, b) { return function (c, d) { var e, f; return null === d || isNaN(+d) || (_(b, "moment()." + b + "(period, number) is deprecated. Please use moment()." + b + "(number, period)."), f = c, c = d, d = f), c = "string" == typeof c ? +c : c, e = Va(c, d), $a(this, e, a), this; }; }
    function $a(b, c, d, e) { var f = c._milliseconds, g = c._days, h = c._months; e = null == e ? !0 : e, f && b._d.setTime(+b._d + f * d), g && D(b, "Date", C(b, "Date") + g * d), h && V(b, C(b, "Month") + h * d), e && a.updateOffset(b, g || h); }
    function _a(a) { var b = a || Aa(), c = Ia(b, this).startOf("day"), d = this.diff(c, "days", !0), e = -6 > d ? "sameElse" : -1 > d ? "lastWeek" : 0 > d ? "lastDay" : 1 > d ? "sameDay" : 2 > d ? "nextDay" : 7 > d ? "nextWeek" : "sameElse"; return this.format(this.localeData().calendar(e, this, Aa(b))); }
    function ab() { return new n(this); }
    function bb(a, b) { var c; return b = z("undefined" != typeof b ? b : "millisecond"), "millisecond" === b ? (a = o(a) ? a : Aa(a), +this > +a) : (c = o(a) ? +a : +Aa(a), c < +this.clone().startOf(b)); }
    function cb(a, b) { var c; return b = z("undefined" != typeof b ? b : "millisecond"), "millisecond" === b ? (a = o(a) ? a : Aa(a), +a > +this) : (c = o(a) ? +a : +Aa(a), +this.clone().endOf(b) < c); }
    function db(a, b, c) { return this.isAfter(a, c) && this.isBefore(b, c); }
    function eb(a, b) { var c; return b = z(b || "millisecond"), "millisecond" === b ? (a = o(a) ? a : Aa(a), +this === +a) : (c = +Aa(a), +this.clone().startOf(b) <= c && c <= +this.clone().endOf(b)); }
    function fb(a) { return 0 > a ? Math.ceil(a) : Math.floor(a); }
    function gb(a, b, c) { var d, e, f = Ia(a, this), g = 6e4 * (f.utcOffset() - this.utcOffset()); return b = z(b), "year" === b || "month" === b || "quarter" === b ? (e = hb(this, f), "quarter" === b ? e /= 3 : "year" === b && (e /= 12)) : (d = this - f, e = "second" === b ? d / 1e3 : "minute" === b ? d / 6e4 : "hour" === b ? d / 36e5 : "day" === b ? (d - g) / 864e5 : "week" === b ? (d - g) / 6048e5 : d), c ? e : fb(e); }
    function hb(a, b) { var c, d, e = 12 * (b.year() - a.year()) + (b.month() - a.month()), f = a.clone().add(e, "months"); return 0 > b - f ? (c = a.clone().add(e - 1, "months"), d = (b - f) / (f - c)) : (c = a.clone().add(e + 1, "months"), d = (b - f) / (c - f)), -(e + d); }
    function ib() { return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ"); }
    function jb() { var a = this.clone().utc(); return 0 < a.year() && a.year() <= 9999 ? "function" == typeof Date.prototype.toISOString ? this.toDate().toISOString() : J(a, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : J(a, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]"); }
    function kb(b) { var c = J(this, b || a.defaultFormat); return this.localeData().postformat(c); }
    function lb(a, b) { return this.isValid() ? Va({ to: this, from: a }).locale(this.locale()).humanize(!b) : this.localeData().invalidDate(); }
    function mb(a) { return this.from(Aa(), a); }
    function nb(a, b) { return this.isValid() ? Va({ from: this, to: a }).locale(this.locale()).humanize(!b) : this.localeData().invalidDate(); }
    function ob(a) { return this.to(Aa(), a); }
    function pb(a) { var b; return void 0 === a ? this._locale._abbr : (b = x(a), null != b && (this._locale = b), this); }
    function qb() { return this._locale; }
    function rb(a) { switch (a = z(a)) {
        case "year": this.month(0);
        case "quarter":
        case "month": this.date(1);
        case "week":
        case "isoWeek":
        case "day": this.hours(0);
        case "hour": this.minutes(0);
        case "minute": this.seconds(0);
        case "second": this.milliseconds(0);
    } return "week" === a && this.weekday(0), "isoWeek" === a && this.isoWeekday(1), "quarter" === a && this.month(3 * Math.floor(this.month() / 3)), this; }
    function sb(a) { return a = z(a), void 0 === a || "millisecond" === a ? this : this.startOf(a).add(1, "isoWeek" === a ? "week" : a).subtract(1, "ms"); }
    function tb() { return +this._d - 6e4 * (this._offset || 0); }
    function ub() { return Math.floor(+this / 1e3); }
    function vb() { return this._offset ? new Date(+this) : this._d; }
    function wb() { var a = this; return [a.year(), a.month(), a.date(), a.hour(), a.minute(), a.second(), a.millisecond()]; }
    function xb() { return k(this); }
    function yb() { return g({}, j(this)); }
    function zb() { return j(this).overflow; }
    function Ab(a, b) { G(0, [a, a.length], 0, b); }
    function Bb(a, b, c) { return ha(Aa([a, 11, 31 + b - c]), b, c).week; }
    function Cb(a) { var b = ha(this, this.localeData()._week.dow, this.localeData()._week.doy).year; return null == a ? b : this.add(a - b, "y"); }
    function Db(a) { var b = ha(this, 1, 4).year; return null == a ? b : this.add(a - b, "y"); }
    function Eb() { return Bb(this.year(), 1, 4); }
    function Fb() { var a = this.localeData()._week; return Bb(this.year(), a.dow, a.doy); }
    function Gb(a) { return null == a ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (a - 1) + this.month() % 3); }
    function Hb(a, b) { if ("string" == typeof a)
        if (isNaN(a)) {
            if (a = b.weekdaysParse(a), "number" != typeof a)
                return null;
        }
        else
            a = parseInt(a, 10); return a; }
    function Ib(a) { return this._weekdays[a.day()]; }
    function Jb(a) { return this._weekdaysShort[a.day()]; }
    function Kb(a) { return this._weekdaysMin[a.day()]; }
    function Lb(a) { var b, c, d; for (this._weekdaysParse || (this._weekdaysParse = []), b = 0; 7 > b; b++)
        if (this._weekdaysParse[b] || (c = Aa([2e3, 1]).day(b), d = "^" + this.weekdays(c, "") + "|^" + this.weekdaysShort(c, "") + "|^" + this.weekdaysMin(c, ""), this._weekdaysParse[b] = new RegExp(d.replace(".", ""), "i")), this._weekdaysParse[b].test(a))
            return b; }
    function Mb(a) { var b = this._isUTC ? this._d.getUTCDay() : this._d.getDay(); return null != a ? (a = Hb(a, this.localeData()), this.add(a - b, "d")) : b; }
    function Nb(a) { var b = (this.day() + 7 - this.localeData()._week.dow) % 7; return null == a ? b : this.add(a - b, "d"); }
    function Ob(a) { return null == a ? this.day() || 7 : this.day(this.day() % 7 ? a : a - 7); }
    function Pb(a, b) { G(a, 0, 0, function () { return this.localeData().meridiem(this.hours(), this.minutes(), b); }); }
    function Qb(a, b) { return b._meridiemParse; }
    function Rb(a) { return "p" === (a + "").toLowerCase().charAt(0); }
    function Sb(a, b, c) { return a > 11 ? c ? "pm" : "PM" : c ? "am" : "AM"; }
    function Tb(a) { G(0, [a, 3], 0, "millisecond"); }
    function Ub() { return this._isUTC ? "UTC" : ""; }
    function Vb() { return this._isUTC ? "Coordinated Universal Time" : ""; }
    function Wb(a) { return Aa(1e3 * a); }
    function Xb() { return Aa.apply(null, arguments).parseZone(); }
    function Yb(a, b, c) { var d = this._calendar[a]; return "function" == typeof d ? d.call(b, c) : d; }
    function Zb(a) { var b = this._longDateFormat[a]; return !b && this._longDateFormat[a.toUpperCase()] && (b = this._longDateFormat[a.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (a) { return a.slice(1); }), this._longDateFormat[a] = b), b; }
    function $b() { return this._invalidDate; }
    function _b(a) { return this._ordinal.replace("%d", a); }
    function ac(a) { return a; }
    function bc(a, b, c, d) { var e = this._relativeTime[c]; return "function" == typeof e ? e(a, b, c, d) : e.replace(/%d/i, a); }
    function cc(a, b) { var c = this._relativeTime[a > 0 ? "future" : "past"]; return "function" == typeof c ? c(b) : c.replace(/%s/i, b); }
    function dc(a) { var b, c; for (c in a)
        b = a[c], "function" == typeof b ? this[c] = b : this["_" + c] = b; this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source); }
    function ec(a, b, c, d) { var e = x(), f = h().set(d, b); return e[c](f, a); }
    function fc(a, b, c, d, e) { if ("number" == typeof a && (b = a, a = void 0), a = a || "", null != b)
        return ec(a, b, c, e); var f, g = []; for (f = 0; d > f; f++)
        g[f] = ec(a, f, c, e); return g; }
    function gc(a, b) { return fc(a, b, "months", 12, "month"); }
    function hc(a, b) { return fc(a, b, "monthsShort", 12, "month"); }
    function ic(a, b) { return fc(a, b, "weekdays", 7, "day"); }
    function jc(a, b) { return fc(a, b, "weekdaysShort", 7, "day"); }
    function kc(a, b) { return fc(a, b, "weekdaysMin", 7, "day"); }
    function lc() { var a = this._data; return this._milliseconds = Rd(this._milliseconds), this._days = Rd(this._days), this._months = Rd(this._months), a.milliseconds = Rd(a.milliseconds), a.seconds = Rd(a.seconds), a.minutes = Rd(a.minutes), a.hours = Rd(a.hours), a.months = Rd(a.months), a.years = Rd(a.years), this; }
    function mc(a, b, c, d) { var e = Va(b, c); return a._milliseconds += d * e._milliseconds, a._days += d * e._days, a._months += d * e._months, a._bubble(); }
    function nc(a, b) { return mc(this, a, b, 1); }
    function oc(a, b) { return mc(this, a, b, -1); }
    function pc() { var a, b, c, d = this._milliseconds, e = this._days, f = this._months, g = this._data, h = 0; return g.milliseconds = d % 1e3, a = fb(d / 1e3), g.seconds = a % 60, b = fb(a / 60), g.minutes = b % 60, c = fb(b / 60), g.hours = c % 24, e += fb(c / 24), h = fb(qc(e)), e -= fb(rc(h)), f += fb(e / 30), e %= 30, h += fb(f / 12), f %= 12, g.days = e, g.months = f, g.years = h, this; }
    function qc(a) { return 400 * a / 146097; }
    function rc(a) { return 146097 * a / 400; }
    function sc(a) { var b, c, d = this._milliseconds; if (a = z(a), "month" === a || "year" === a)
        return b = this._days + d / 864e5, c = this._months + 12 * qc(b), "month" === a ? c : c / 12; switch (b = this._days + Math.round(rc(this._months / 12)), a) {
        case "week": return b / 7 + d / 6048e5;
        case "day": return b + d / 864e5;
        case "hour": return 24 * b + d / 36e5;
        case "minute": return 1440 * b + d / 6e4;
        case "second": return 86400 * b + d / 1e3;
        case "millisecond": return Math.floor(864e5 * b) + d;
        default: throw new Error("Unknown unit " + a);
    } }
    function tc() { return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * p(this._months / 12); }
    function uc(a) { return function () { return this.as(a); }; }
    function vc(a) { return a = z(a), this[a + "s"](); }
    function wc(a) { return function () { return this._data[a]; }; }
    function xc() { return fb(this.days() / 7); }
    function yc(a, b, c, d, e) { return e.relativeTime(b || 1, !!c, a, d); }
    function zc(a, b, c) { var d = Va(a).abs(), e = fe(d.as("s")), f = fe(d.as("m")), g = fe(d.as("h")), h = fe(d.as("d")), i = fe(d.as("M")), j = fe(d.as("y")), k = e < ge.s && ["s", e] || 1 === f && ["m"] || f < ge.m && ["mm", f] || 1 === g && ["h"] || g < ge.h && ["hh", g] || 1 === h && ["d"] || h < ge.d && ["dd", h] || 1 === i && ["M"] || i < ge.M && ["MM", i] || 1 === j && ["y"] || ["yy", j]; return k[2] = b, k[3] = +a > 0, k[4] = c, yc.apply(null, k); }
    function Ac(a, b) { return void 0 === ge[a] ? !1 : void 0 === b ? ge[a] : (ge[a] = b, !0); }
    function Bc(a) { var b = this.localeData(), c = zc(this, !a, b); return a && (c = b.pastFuture(+this, c)), b.postformat(c); }
    function Cc() { var a = he(this.years()), b = he(this.months()), c = he(this.days()), d = he(this.hours()), e = he(this.minutes()), f = he(this.seconds() + this.milliseconds() / 1e3), g = this.asSeconds(); return g ? (0 > g ? "-" : "") + "P" + (a ? a + "Y" : "") + (b ? b + "M" : "") + (c ? c + "D" : "") + (d || e || f ? "T" : "") + (d ? d + "H" : "") + (e ? e + "M" : "") + (f ? f + "S" : "") : "P0D"; }
    var Dc, Ec, Fc = a.momentProperties = [], Gc = !1, Hc = {}, Ic = {}, Jc = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, Kc = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Lc = {}, Mc = {}, Nc = /\d/, Oc = /\d\d/, Pc = /\d{3}/, Qc = /\d{4}/, Rc = /[+-]?\d{6}/, Sc = /\d\d?/, Tc = /\d{1,3}/, Uc = /\d{1,4}/, Vc = /[+-]?\d{1,6}/, Wc = /\d+/, Xc = /[+-]?\d+/, Yc = /Z|[+-]\d\d:?\d\d/gi, Zc = /[+-]?\d+(\.\d{1,3})?/, $c = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, _c = {}, ad = {}, bd = 0, cd = 1, dd = 2, ed = 3, fd = 4, gd = 5, hd = 6;
    G("M", ["MM", 2], "Mo", function () { return this.month() + 1; }), G("MMM", 0, 0, function (a) { return this.localeData().monthsShort(this, a); }), G("MMMM", 0, 0, function (a) { return this.localeData().months(this, a); }), y("month", "M"), L("M", Sc), L("MM", Sc, Oc), L("MMM", $c), L("MMMM", $c), O(["M", "MM"], function (a, b) { b[cd] = p(a) - 1; }), O(["MMM", "MMMM"], function (a, b, c, d) { var e = c._locale.monthsParse(a, d, c._strict); null != e ? b[cd] = e : j(c).invalidMonth = a; });
    var id = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), jd = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), kd = {};
    a.suppressDeprecationWarnings = !1;
    var ld = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, md = [["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/], ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/], ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/], ["GGGG-[W]WW", /\d{4}-W\d{2}/], ["YYYY-DDD", /\d{4}-\d{3}/]], nd = [["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/], ["HH:mm", /(T| )\d\d:\d\d/], ["HH", /(T| )\d\d/]], od = /^\/?Date\((\-?\d+)/i;
    a.createFromInputFallback = $("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.", function (a) { a._d = new Date(a._i + (a._useUTC ? " UTC" : "")); }), G(0, ["YY", 2], 0, function () { return this.year() % 100; }), G(0, ["YYYY", 4], 0, "year"), G(0, ["YYYYY", 5], 0, "year"), G(0, ["YYYYYY", 6, !0], 0, "year"), y("year", "y"), L("Y", Xc), L("YY", Sc, Oc), L("YYYY", Uc, Qc), L("YYYYY", Vc, Rc), L("YYYYYY", Vc, Rc), O(["YYYY", "YYYYY", "YYYYYY"], bd), O("YY", function (b, c) { c[bd] = a.parseTwoDigitYear(b); }), a.parseTwoDigitYear = function (a) { return p(a) + (p(a) > 68 ? 1900 : 2e3); };
    var pd = B("FullYear", !1);
    G("w", ["ww", 2], "wo", "week"), G("W", ["WW", 2], "Wo", "isoWeek"), y("week", "w"), y("isoWeek", "W"), L("w", Sc), L("ww", Sc, Oc), L("W", Sc), L("WW", Sc, Oc), P(["w", "ww", "W", "WW"], function (a, b, c, d) { b[d.substr(0, 1)] = p(a); });
    var qd = { dow: 0, doy: 6 };
    G("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), y("dayOfYear", "DDD"), L("DDD", Tc), L("DDDD", Pc), O(["DDD", "DDDD"], function (a, b, c) { c._dayOfYear = p(a); }), a.ISO_8601 = function () { };
    var rd = $("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function () { var a = Aa.apply(null, arguments); return this > a ? this : a; }), sd = $("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function () { var a = Aa.apply(null, arguments); return a > this ? this : a; });
    Ga("Z", ":"), Ga("ZZ", ""), L("Z", Yc), L("ZZ", Yc), O(["Z", "ZZ"], function (a, b, c) { c._useUTC = !0, c._tzm = Ha(a); });
    var td = /([\+\-]|\d\d)/gi;
    a.updateOffset = function () { };
    var ud = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, vd = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;
    Va.fn = Ea.prototype;
    var wd = Za(1, "add"), xd = Za(-1, "subtract");
    a.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    var yd = $("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (a) { return void 0 === a ? this.localeData() : this.locale(a); });
    G(0, ["gg", 2], 0, function () { return this.weekYear() % 100; }), G(0, ["GG", 2], 0, function () { return this.isoWeekYear() % 100; }), Ab("gggg", "weekYear"), Ab("ggggg", "weekYear"), Ab("GGGG", "isoWeekYear"), Ab("GGGGG", "isoWeekYear"), y("weekYear", "gg"), y("isoWeekYear", "GG"), L("G", Xc), L("g", Xc), L("GG", Sc, Oc), L("gg", Sc, Oc), L("GGGG", Uc, Qc), L("gggg", Uc, Qc), L("GGGGG", Vc, Rc), L("ggggg", Vc, Rc), P(["gggg", "ggggg", "GGGG", "GGGGG"], function (a, b, c, d) { b[d.substr(0, 2)] = p(a); }), P(["gg", "GG"], function (b, c, d, e) { c[e] = a.parseTwoDigitYear(b); }), G("Q", 0, 0, "quarter"), y("quarter", "Q"), L("Q", Nc), O("Q", function (a, b) { b[cd] = 3 * (p(a) - 1); }), G("D", ["DD", 2], "Do", "date"), y("date", "D"), L("D", Sc), L("DD", Sc, Oc), L("Do", function (a, b) { return a ? b._ordinalParse : b._ordinalParseLenient; }), O(["D", "DD"], dd), O("Do", function (a, b) { b[dd] = p(a.match(Sc)[0], 10); });
    var zd = B("Date", !0);
    G("d", 0, "do", "day"), G("dd", 0, 0, function (a) { return this.localeData().weekdaysMin(this, a); }), G("ddd", 0, 0, function (a) { return this.localeData().weekdaysShort(this, a); }), G("dddd", 0, 0, function (a) { return this.localeData().weekdays(this, a); }), G("e", 0, 0, "weekday"), G("E", 0, 0, "isoWeekday"), y("day", "d"), y("weekday", "e"), y("isoWeekday", "E"), L("d", Sc), L("e", Sc), L("E", Sc), L("dd", $c), L("ddd", $c), L("dddd", $c), P(["dd", "ddd", "dddd"], function (a, b, c) { var d = c._locale.weekdaysParse(a); null != d ? b.d = d : j(c).invalidWeekday = a; }), P(["d", "e", "E"], function (a, b, c, d) { b[d] = p(a); });
    var Ad = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), Bd = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Cd = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
    G("H", ["HH", 2], 0, "hour"), G("h", ["hh", 2], 0, function () { return this.hours() % 12 || 12; }), Pb("a", !0), Pb("A", !1), y("hour", "h"), L("a", Qb), L("A", Qb), L("H", Sc), L("h", Sc), L("HH", Sc, Oc), L("hh", Sc, Oc), O(["H", "HH"], ed), O(["a", "A"], function (a, b, c) { c._isPm = c._locale.isPM(a), c._meridiem = a; }), O(["h", "hh"], function (a, b, c) { b[ed] = p(a), j(c).bigHour = !0; });
    var Dd = /[ap]\.?m?\.?/i, Ed = B("Hours", !0);
    G("m", ["mm", 2], 0, "minute"), y("minute", "m"), L("m", Sc), L("mm", Sc, Oc), O(["m", "mm"], fd);
    var Fd = B("Minutes", !1);
    G("s", ["ss", 2], 0, "second"), y("second", "s"), L("s", Sc), L("ss", Sc, Oc), O(["s", "ss"], gd);
    var Gd = B("Seconds", !1);
    G("S", 0, 0, function () { return ~~(this.millisecond() / 100); }), G(0, ["SS", 2], 0, function () { return ~~(this.millisecond() / 10); }), Tb("SSS"), Tb("SSSS"), y("millisecond", "ms"), L("S", Tc, Nc), L("SS", Tc, Oc), L("SSS", Tc, Pc), L("SSSS", Wc), O(["S", "SS", "SSS", "SSSS"], function (a, b) { b[hd] = p(1e3 * ("0." + a)); });
    var Hd = B("Milliseconds", !1);
    G("z", 0, 0, "zoneAbbr"), G("zz", 0, 0, "zoneName");
    var Id = n.prototype;
    Id.add = wd, Id.calendar = _a, Id.clone = ab, Id.diff = gb, Id.endOf = sb, Id.format = kb, Id.from = lb, Id.fromNow = mb, Id.to = nb, Id.toNow = ob, Id.get = E, Id.invalidAt = zb, Id.isAfter = bb, Id.isBefore = cb, Id.isBetween = db, Id.isSame = eb, Id.isValid = xb, Id.lang = yd, Id.locale = pb, Id.localeData = qb, Id.max = sd, Id.min = rd, Id.parsingFlags = yb, Id.set = E, Id.startOf = rb, Id.subtract = xd, Id.toArray = wb, Id.toDate = vb, Id.toISOString = jb, Id.toJSON = jb, Id.toString = ib, Id.unix = ub, Id.valueOf = tb, Id.year = pd, Id.isLeapYear = ga, Id.weekYear = Cb, Id.isoWeekYear = Db, Id.quarter = Id.quarters = Gb, Id.month = W, Id.daysInMonth = X, Id.week = Id.weeks = la, Id.isoWeek = Id.isoWeeks = ma, Id.weeksInYear = Fb, Id.isoWeeksInYear = Eb, Id.date = zd, Id.day = Id.days = Mb, Id.weekday = Nb, Id.isoWeekday = Ob, Id.dayOfYear = oa, Id.hour = Id.hours = Ed, Id.minute = Id.minutes = Fd, Id.second = Id.seconds = Gd, Id.millisecond = Id.milliseconds = Hd, Id.utcOffset = Ka, Id.utc = Ma, Id.local = Na, Id.parseZone = Oa, Id.hasAlignedHourOffset = Pa, Id.isDST = Qa, Id.isDSTShifted = Ra, Id.isLocal = Sa, Id.isUtcOffset = Ta, Id.isUtc = Ua, Id.isUTC = Ua, Id.zoneAbbr = Ub, Id.zoneName = Vb, Id.dates = $("dates accessor is deprecated. Use date instead.", zd), Id.months = $("months accessor is deprecated. Use month instead", W), Id.years = $("years accessor is deprecated. Use year instead", pd), Id.zone = $("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", La);
    var Jd = Id, Kd = { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, Ld = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY LT", LLLL: "dddd, MMMM D, YYYY LT" }, Md = "Invalid date", Nd = "%d", Od = /\d{1,2}/, Pd = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour",
        hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, Qd = r.prototype;
    Qd._calendar = Kd, Qd.calendar = Yb, Qd._longDateFormat = Ld, Qd.longDateFormat = Zb, Qd._invalidDate = Md, Qd.invalidDate = $b, Qd._ordinal = Nd, Qd.ordinal = _b, Qd._ordinalParse = Od, Qd.preparse = ac, Qd.postformat = ac, Qd._relativeTime = Pd, Qd.relativeTime = bc, Qd.pastFuture = cc, Qd.set = dc, Qd.months = S, Qd._months = id, Qd.monthsShort = T, Qd._monthsShort = jd, Qd.monthsParse = U, Qd.week = ia, Qd._week = qd, Qd.firstDayOfYear = ka, Qd.firstDayOfWeek = ja, Qd.weekdays = Ib, Qd._weekdays = Ad, Qd.weekdaysMin = Kb, Qd._weekdaysMin = Cd, Qd.weekdaysShort = Jb, Qd._weekdaysShort = Bd, Qd.weekdaysParse = Lb, Qd.isPM = Rb, Qd._meridiemParse = Dd, Qd.meridiem = Sb, v("en", { ordinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (a) { var b = a % 10, c = 1 === p(a % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th"; return a + c; } }), a.lang = $("moment.lang is deprecated. Use moment.locale instead.", v), a.langData = $("moment.langData is deprecated. Use moment.localeData instead.", x);
    var Rd = Math.abs, Sd = uc("ms"), Td = uc("s"), Ud = uc("m"), Vd = uc("h"), Wd = uc("d"), Xd = uc("w"), Yd = uc("M"), Zd = uc("y"), $d = wc("milliseconds"), _d = wc("seconds"), ae = wc("minutes"), be = wc("hours"), ce = wc("days"), de = wc("months"), ee = wc("years"), fe = Math.round, ge = { s: 45, m: 45, h: 22, d: 26, M: 11 }, he = Math.abs, ie = Ea.prototype;
    ie.abs = lc, ie.add = nc, ie.subtract = oc, ie.as = sc, ie.asMilliseconds = Sd, ie.asSeconds = Td, ie.asMinutes = Ud, ie.asHours = Vd, ie.asDays = Wd, ie.asWeeks = Xd, ie.asMonths = Yd, ie.asYears = Zd, ie.valueOf = tc, ie._bubble = pc, ie.get = vc, ie.milliseconds = $d, ie.seconds = _d, ie.minutes = ae, ie.hours = be, ie.days = ce, ie.weeks = xc, ie.months = de, ie.years = ee, ie.humanize = Bc, ie.toISOString = Cc, ie.toString = Cc, ie.toJSON = Cc, ie.locale = pb, ie.localeData = qb, ie.toIsoString = $("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Cc), ie.lang = yd, G("X", 0, 0, "unix"), G("x", 0, 0, "valueOf"), L("x", Xc), L("X", Zc), O("X", function (a, b, c) { c._d = new Date(1e3 * parseFloat(a, 10)); }), O("x", function (a, b, c) { c._d = new Date(p(a)); }), a.version = "2.10.3", b(Aa), a.fn = Jd, a.min = Ca, a.max = Da, a.utc = h, a.unix = Wb, a.months = gc, a.isDate = d, a.locale = v, a.invalid = l, a.duration = Va, a.isMoment = o, a.weekdays = ic, a.parseZone = Xb, a.localeData = x, a.isDuration = Fa, a.monthsShort = hc, a.weekdaysMin = kc, a.defineLocale = w, a.weekdaysShort = jc, a.normalizeUnits = z, a.relativeTimeThreshold = Ac;
    var je = a;
    return je;
});
(function (so) {
    'use strict';
    var uidList = [], uid;
    uidList.push(uid = function () {
        return this;
    });
    so.pushUid = function (method) {
        uidList.push(method);
        uid = method;
        return method;
    };
    so.popUid = function () {
        var prev;
        uidList.length > 1 && (prev = uidList.pop());
        uid = uidList[uidList.length - 1];
        return prev || null;
    };
    function process(a, b, evaluator) {
        var hist = Object.create(null), out = [], ukey, k;
        a.forEach(function (value) {
            ukey = uid.call(value);
            if (!hist[ukey]) {
                hist[ukey] = { value: value, freq: 1 };
            }
        });
        b.forEach(function (value) {
            ukey = uid.call(value);
            if (hist[ukey]) {
                if (hist[ukey].freq === 1)
                    hist[ukey].freq = 3;
            }
            else {
                hist[ukey] = { value: value, freq: 2 };
            }
        });
        if (evaluator) {
            for (k in hist) {
                if (evaluator(hist[k].freq))
                    out.push(hist[k].value);
            }
            return out;
        }
        else {
            return hist;
        }
    }
    ;
    so.union = function (a, b) {
        return process(a, b, function (freq) {
            return true;
        });
    };
    so.intersection = function (a, b) {
        return process(a, b, function (freq) {
            return freq === 3;
        });
    };
    so.difference = function (a, b) {
        return process(a, b, function (freq) {
            return freq < 3;
        });
    };
    so.complement = function (a, b) {
        return process(a, b, function (freq) {
            return freq === 1;
        });
    };
    so.equals = function (a, b) {
        var max = 0, min = Math.pow(2, 53), key, hist = process(a, b);
        for (var key in hist) {
            max = Math.max(max, hist[key].freq);
            min = Math.min(min, hist[key].freq);
        }
        return min === 3 && max === 3;
    };
})(window.setOps = window.setOps || Object.create(null));
(function (global) {
    "use strict";
    var IS_WORKER = !global.document, LOADED_SYNC = false, AUTO_SCRIPT_PATH;
    var workers = {}, workerIdCounter = 0;
    global.Papa = {};
    global.Papa.parse = CsvToJson;
    global.Papa.unparse = JsonToCsv;
    global.Papa.RECORD_SEP = String.fromCharCode(30);
    global.Papa.UNIT_SEP = String.fromCharCode(31);
    global.Papa.BYTE_ORDER_MARK = "\ufeff";
    global.Papa.BAD_DELIMITERS = ["\r", "\n", "\"", global.Papa.BYTE_ORDER_MARK];
    global.Papa.WORKERS_SUPPORTED = !!global.Worker;
    global.Papa.SCRIPT_PATH = null;
    global.Papa.LocalChunkSize = 1024 * 1024 * 10;
    global.Papa.RemoteChunkSize = 1024 * 1024 * 5;
    global.Papa.DefaultDelimiter = ",";
    global.Papa.Parser = Parser;
    global.Papa.ParserHandle = ParserHandle;
    global.Papa.NetworkStreamer = NetworkStreamer;
    global.Papa.FileStreamer = FileStreamer;
    global.Papa.StringStreamer = StringStreamer;
    if (global.jQuery) {
        var $ = global.jQuery;
        $.fn.parse = function (options) {
            var config = options.config || {};
            var queue = [];
            this.each(function (idx) {
                var supported = $(this).prop('tagName').toUpperCase() == "INPUT"
                    && $(this).attr('type').toLowerCase() == "file"
                    && global.FileReader;
                if (!supported || !this.files || this.files.length == 0)
                    return true;
                for (var i = 0; i < this.files.length; i++) {
                    queue.push({
                        file: this.files[i],
                        inputElem: this,
                        instanceConfig: $.extend({}, config)
                    });
                }
            });
            parseNextFile();
            return this;
            function parseNextFile() {
                if (queue.length == 0) {
                    if (isFunction(options.complete))
                        options.complete();
                    return;
                }
                var f = queue[0];
                if (isFunction(options.before)) {
                    var returned = options.before(f.file, f.inputElem);
                    if (typeof returned === 'object') {
                        if (returned.action == "abort") {
                            error("AbortError", f.file, f.inputElem, returned.reason);
                            return;
                        }
                        else if (returned.action == "skip") {
                            fileComplete();
                            return;
                        }
                        else if (typeof returned.config === 'object')
                            f.instanceConfig = $.extend(f.instanceConfig, returned.config);
                    }
                    else if (returned == "skip") {
                        fileComplete();
                        return;
                    }
                }
                var userCompleteFunc = f.instanceConfig.complete;
                f.instanceConfig.complete = function (results) {
                    if (isFunction(userCompleteFunc))
                        userCompleteFunc(results, f.file, f.inputElem);
                    fileComplete();
                };
                Papa.parse(f.file, f.instanceConfig);
            }
            function error(name, file, elem, reason) {
                if (isFunction(options.error))
                    options.error({ name: name }, file, elem, reason);
            }
            function fileComplete() {
                queue.splice(0, 1);
                parseNextFile();
            }
        };
    }
    if (IS_WORKER) {
        global.onmessage = workerThreadReceivedMessage;
    }
    else if (Papa.WORKERS_SUPPORTED) {
        AUTO_SCRIPT_PATH = getScriptPath();
        if (!document.body) {
            LOADED_SYNC = true;
        }
        else {
            document.addEventListener('DOMContentLoaded', function () {
                LOADED_SYNC = true;
            }, true);
        }
    }
    function CsvToJson(_input, _config) {
        _config = _config || {};
        if (_config.worker && Papa.WORKERS_SUPPORTED) {
            var w = newWorker();
            w.userStep = _config.step;
            w.userChunk = _config.chunk;
            w.userComplete = _config.complete;
            w.userError = _config.error;
            _config.step = isFunction(_config.step);
            _config.chunk = isFunction(_config.chunk);
            _config.complete = isFunction(_config.complete);
            _config.error = isFunction(_config.error);
            delete _config.worker;
            w.postMessage({
                input: _input,
                config: _config,
                workerId: w.id
            });
            return;
        }
        var streamer = null;
        if (typeof _input === 'string') {
            if (_config.download)
                streamer = new NetworkStreamer(_config);
            else
                streamer = new StringStreamer(_config);
        }
        else if ((global.File && _input instanceof File) || _input instanceof Object)
            streamer = new FileStreamer(_config);
        return streamer.stream(_input);
    }
    function JsonToCsv(_input, _config) {
        var _output = "";
        var _fields = [];
        var _quotes = false;
        var _delimiter = ",";
        var _newline = "\r\n";
        unpackConfig();
        if (typeof _input === 'string')
            _input = JSON.parse(_input);
        if (_input instanceof Array) {
            if (!_input.length || _input[0] instanceof Array)
                return serialize(null, _input);
            else if (typeof _input[0] === 'object')
                return serialize(objectKeys(_input[0]), _input);
        }
        else if (typeof _input === 'object') {
            if (typeof _input.data === 'string')
                _input.data = JSON.parse(_input.data);
            if (_input.data instanceof Array) {
                if (!_input.fields)
                    _input.fields = _input.data[0] instanceof Array
                        ? _input.fields
                        : objectKeys(_input.data[0]);
                if (!(_input.data[0] instanceof Array) && typeof _input.data[0] !== 'object')
                    _input.data = [_input.data];
            }
            return serialize(_input.fields || [], _input.data || []);
        }
        throw "exception: Unable to serialize unrecognized input";
        function unpackConfig() {
            if (typeof _config !== 'object')
                return;
            if (typeof _config.delimiter === 'string'
                && _config.delimiter.length == 1
                && global.Papa.BAD_DELIMITERS.indexOf(_config.delimiter) == -1) {
                _delimiter = _config.delimiter;
            }
            if (typeof _config.quotes === 'boolean'
                || _config.quotes instanceof Array)
                _quotes = _config.quotes;
            if (typeof _config.newline === 'string')
                _newline = _config.newline;
        }
        function objectKeys(obj) {
            if (typeof obj !== 'object')
                return [];
            var keys = [];
            for (var key in obj)
                keys.push(key);
            return keys;
        }
        function serialize(fields, data) {
            var csv = "";
            if (typeof fields === 'string')
                fields = JSON.parse(fields);
            if (typeof data === 'string')
                data = JSON.parse(data);
            var hasHeader = fields instanceof Array && fields.length > 0;
            var dataKeyedByField = !(data[0] instanceof Array);
            if (hasHeader) {
                for (var i = 0; i < fields.length; i++) {
                    if (i > 0)
                        csv += _delimiter;
                    csv += safe(fields[i], i);
                }
                if (data.length > 0)
                    csv += _newline;
            }
            for (var row = 0; row < data.length; row++) {
                var maxCol = hasHeader ? fields.length : data[row].length;
                for (var col = 0; col < maxCol; col++) {
                    if (col > 0)
                        csv += _delimiter;
                    var colIdx = hasHeader && dataKeyedByField ? fields[col] : col;
                    csv += safe(data[row][colIdx], col);
                }
                if (row < data.length - 1)
                    csv += _newline;
            }
            return csv;
        }
        function safe(str, col) {
            if (typeof str === "undefined" || str === null)
                return "";
            str = str.toString().replace(/"/g, '""');
            var needsQuotes = (typeof _quotes === 'boolean' && _quotes)
                || (_quotes instanceof Array && _quotes[col])
                || hasAny(str, global.Papa.BAD_DELIMITERS)
                || str.indexOf(_delimiter) > -1
                || str.charAt(0) == ' '
                || str.charAt(str.length - 1) == ' ';
            return needsQuotes ? '"' + str + '"' : str;
        }
        function hasAny(str, substrings) {
            for (var i = 0; i < substrings.length; i++)
                if (str.indexOf(substrings[i]) > -1)
                    return true;
            return false;
        }
    }
    function ChunkStreamer(config) {
        this._handle = null;
        this._paused = false;
        this._finished = false;
        this._input = null;
        this._baseIndex = 0;
        this._partialLine = "";
        this._rowCount = 0;
        this._start = 0;
        this._nextChunk = null;
        replaceConfig.call(this, config);
        this.parseChunk = function (chunk) {
            var aggregate = this._partialLine + chunk;
            this._partialLine = "";
            var results = this._handle.parse(aggregate, this._baseIndex, !this._finished);
            if (this._handle.paused())
                return;
            var lastIndex = results.meta.cursor;
            if (!this._finished) {
                this._partialLine = aggregate.substring(lastIndex - this._baseIndex);
                this._baseIndex = lastIndex;
            }
            if (results && results.data)
                this._rowCount += results.data.length;
            var finishedIncludingPreview = this._finished || (this._config.preview && this._rowCount >= this._config.preview);
            if (IS_WORKER) {
                global.postMessage({
                    results: results,
                    workerId: Papa.WORKER_ID,
                    finished: finishedIncludingPreview
                });
            }
            else if (isFunction(this._config.chunk)) {
                this._config.chunk(results, this._handle);
                if (this._paused)
                    return;
                results = undefined;
            }
            if (finishedIncludingPreview && isFunction(this._config.complete) && (!results || !results.meta.aborted))
                this._config.complete(results);
            if (!finishedIncludingPreview && (!results || !results.meta.paused))
                this._nextChunk();
            return results;
        };
        this._sendError = function (error) {
            if (isFunction(this._config.error))
                this._config.error(error);
            else if (IS_WORKER && this._config.error) {
                global.postMessage({
                    workerId: Papa.WORKER_ID,
                    error: error,
                    finished: false
                });
            }
        };
        function replaceConfig(config) {
            var configCopy = copy(config);
            configCopy.chunkSize = parseInt(configCopy.chunkSize);
            this._handle = new ParserHandle(configCopy);
            this._handle.streamer = this;
            this._config = configCopy;
        }
    }
    function NetworkStreamer(config) {
        config = config || {};
        if (!config.chunkSize)
            config.chunkSize = Papa.RemoteChunkSize;
        ChunkStreamer.call(this, config);
        var xhr;
        if (IS_WORKER) {
            this._nextChunk = function () {
                this._readChunk();
                this._chunkLoaded();
            };
        }
        else {
            this._nextChunk = function () {
                this._readChunk();
            };
        }
        this.stream = function (url) {
            this._input = url;
            this._nextChunk();
        };
        this._readChunk = function () {
            if (this._finished) {
                this._chunkLoaded();
                return;
            }
            xhr = new XMLHttpRequest();
            if (!IS_WORKER) {
                xhr.onload = bindFunction(this._chunkLoaded, this);
                xhr.onerror = bindFunction(this._chunkError, this);
            }
            xhr.open("GET", this._input, !IS_WORKER);
            if (this._config.step || this._config.chunk) {
                var end = this._start + this._config.chunkSize - 1;
                xhr.setRequestHeader("Range", "bytes=" + this._start + "-" + end);
                xhr.setRequestHeader("If-None-Match", "webkit-no-cache");
            }
            try {
                xhr.send();
            }
            catch (err) {
                this._chunkError(err.message);
            }
            if (IS_WORKER && xhr.status == 0)
                this._chunkError();
            else
                this._start += this._config.chunkSize;
        };
        this._chunkLoaded = function () {
            if (xhr.readyState != 4)
                return;
            if (xhr.status < 200 || xhr.status >= 400) {
                this._chunkError();
                return;
            }
            this._finished = (!this._config.step && !this._config.chunk) || this._start > getFileSize(xhr);
            this.parseChunk(xhr.responseText);
        };
        this._chunkError = function (errorMessage) {
            var errorText = xhr.statusText || errorMessage;
            this._sendError(errorText);
        };
        function getFileSize(xhr) {
            var contentRange = xhr.getResponseHeader("Content-Range");
            return parseInt(contentRange.substr(contentRange.lastIndexOf("/") + 1));
        }
    }
    NetworkStreamer.prototype = Object.create(ChunkStreamer.prototype);
    NetworkStreamer.prototype.constructor = NetworkStreamer;
    function FileStreamer(config) {
        config = config || {};
        if (!config.chunkSize)
            config.chunkSize = Papa.LocalChunkSize;
        ChunkStreamer.call(this, config);
        var reader, slice;
        var usingAsyncReader = typeof FileReader !== 'undefined';
        this.stream = function (file) {
            this._input = file;
            slice = file.slice || file.webkitSlice || file.mozSlice;
            if (usingAsyncReader) {
                reader = new FileReader();
                reader.onload = bindFunction(this._chunkLoaded, this);
                reader.onerror = bindFunction(this._chunkError, this);
            }
            else
                reader = new FileReaderSync();
            this._nextChunk();
        };
        this._nextChunk = function () {
            if (!this._finished && (!this._config.preview || this._rowCount < this._config.preview))
                this._readChunk();
        };
        this._readChunk = function () {
            var end = Math.min(this._start + this._config.chunkSize, this._input.size);
            var txt = reader.readAsText(slice.call(this._input, this._start, end), this._config.encoding);
            if (!usingAsyncReader)
                this._chunkLoaded({ target: { result: txt } });
        };
        this._chunkLoaded = function (event) {
            this._start += this._config.chunkSize;
            this._finished = this._start >= this._input.size;
            this.parseChunk(event.target.result);
        };
        this._chunkError = function () {
            this._sendError(reader.error);
        };
    }
    FileStreamer.prototype = Object.create(ChunkStreamer.prototype);
    FileStreamer.prototype.constructor = FileStreamer;
    function StringStreamer(config) {
        config = config || {};
        ChunkStreamer.call(this, config);
        var string;
        var remaining;
        this.stream = function (s) {
            string = s;
            remaining = s;
            return this._nextChunk();
        };
        this._nextChunk = function () {
            if (this._finished)
                return;
            var size = this._config.chunkSize;
            var chunk = size ? remaining.substr(0, size) : remaining;
            remaining = size ? remaining.substr(size) : '';
            this._finished = !remaining;
            return this.parseChunk(chunk);
        };
    }
    StringStreamer.prototype = Object.create(StringStreamer.prototype);
    StringStreamer.prototype.constructor = StringStreamer;
    function ParserHandle(_config) {
        var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;
        var self = this;
        var _stepCounter = 0;
        var _input;
        var _parser;
        var _paused = false;
        var _delimiterError;
        var _fields = [];
        var _results = {
            data: [],
            errors: [],
            meta: {}
        };
        if (isFunction(_config.step)) {
            var userStep = _config.step;
            _config.step = function (results) {
                _results = results;
                if (needsHeaderRow())
                    processResults();
                else {
                    processResults();
                    if (_results.data.length == 0)
                        return;
                    _stepCounter += results.data.length;
                    if (_config.preview && _stepCounter > _config.preview)
                        _parser.abort();
                    else
                        userStep(_results, self);
                }
            };
        }
        this.parse = function (input, baseIndex, ignoreLastRow) {
            if (!_config.newline)
                _config.newline = guessLineEndings(input);
            _delimiterError = false;
            if (!_config.delimiter) {
                var delimGuess = guessDelimiter(input);
                if (delimGuess.successful)
                    _config.delimiter = delimGuess.bestDelimiter;
                else {
                    _delimiterError = true;
                    _config.delimiter = Papa.DefaultDelimiter;
                }
                _results.meta.delimiter = _config.delimiter;
            }
            var parserConfig = copy(_config);
            if (_config.preview && _config.header)
                parserConfig.preview++;
            _input = input;
            _parser = new Parser(parserConfig);
            _results = _parser.parse(_input, baseIndex, ignoreLastRow);
            processResults();
            return _paused ? { meta: { paused: true } } : (_results || { meta: { paused: false } });
        };
        this.paused = function () {
            return _paused;
        };
        this.pause = function () {
            _paused = true;
            _parser.abort();
            _input = _input.substr(_parser.getCharIndex());
        };
        this.resume = function () {
            _paused = false;
            self.streamer.parseChunk(_input);
        };
        this.abort = function () {
            _parser.abort();
            if (isFunction(_config.complete))
                _config.complete(_results);
            _input = "";
        };
        function processResults() {
            if (_results && _delimiterError) {
                addError("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + Papa.DefaultDelimiter + "'");
                _delimiterError = false;
            }
            if (_config.skipEmptyLines) {
                for (var i = 0; i < _results.data.length; i++)
                    if (_results.data[i].length == 1 && _results.data[i][0] == "")
                        _results.data.splice(i--, 1);
            }
            if (needsHeaderRow())
                fillHeaderFields();
            return applyHeaderAndDynamicTyping();
        }
        function needsHeaderRow() {
            return _config.header && _fields.length == 0;
        }
        function fillHeaderFields() {
            if (!_results)
                return;
            for (var i = 0; needsHeaderRow() && i < _results.data.length; i++)
                for (var j = 0; j < _results.data[i].length; j++)
                    _fields.push(_results.data[i][j]);
            _results.data.splice(0, 1);
        }
        function applyHeaderAndDynamicTyping() {
            if (!_results || (!_config.header && !_config.dynamicTyping))
                return _results;
            for (var i = 0; i < _results.data.length; i++) {
                var row = {};
                for (var j = 0; j < _results.data[i].length; j++) {
                    if (_config.dynamicTyping) {
                        var value = _results.data[i][j];
                        if (value == "true")
                            _results.data[i][j] = true;
                        else if (value == "false")
                            _results.data[i][j] = false;
                        else
                            _results.data[i][j] = tryParseFloat(value);
                    }
                    if (_config.header) {
                        if (j >= _fields.length) {
                            if (!row["__parsed_extra"])
                                row["__parsed_extra"] = [];
                            row["__parsed_extra"].push(_results.data[i][j]);
                        }
                        else
                            row[_fields[j]] = _results.data[i][j];
                    }
                }
                if (_config.header) {
                    _results.data[i] = row;
                    if (j > _fields.length)
                        addError("FieldMismatch", "TooManyFields", "Too many fields: expected " + _fields.length + " fields but parsed " + j, i);
                    else if (j < _fields.length)
                        addError("FieldMismatch", "TooFewFields", "Too few fields: expected " + _fields.length + " fields but parsed " + j, i);
                }
            }
            if (_config.header && _results.meta)
                _results.meta.fields = _fields;
            return _results;
        }
        function guessDelimiter(input) {
            var delimChoices = [",", "\t", "|", ";", Papa.RECORD_SEP, Papa.UNIT_SEP];
            var bestDelim, bestDelta, fieldCountPrevRow;
            for (var i = 0; i < delimChoices.length; i++) {
                var delim = delimChoices[i];
                var delta = 0, avgFieldCount = 0;
                fieldCountPrevRow = undefined;
                var preview = new Parser({
                    delimiter: delim,
                    preview: 10
                }).parse(input);
                for (var j = 0; j < preview.data.length; j++) {
                    var fieldCount = preview.data[j].length;
                    avgFieldCount += fieldCount;
                    if (typeof fieldCountPrevRow === 'undefined') {
                        fieldCountPrevRow = fieldCount;
                        continue;
                    }
                    else if (fieldCount > 1) {
                        delta += Math.abs(fieldCount - fieldCountPrevRow);
                        fieldCountPrevRow = fieldCount;
                    }
                }
                avgFieldCount /= preview.data.length;
                if ((typeof bestDelta === 'undefined' || delta < bestDelta)
                    && avgFieldCount > 1.99) {
                    bestDelta = delta;
                    bestDelim = delim;
                }
            }
            _config.delimiter = bestDelim;
            return {
                successful: !!bestDelim,
                bestDelimiter: bestDelim
            };
        }
        function guessLineEndings(input) {
            input = input.substr(0, 1024 * 1024);
            var r = input.split('\r');
            if (r.length == 1)
                return '\n';
            var numWithN = 0;
            for (var i = 0; i < r.length; i++) {
                if (r[i][0] == '\n')
                    numWithN++;
            }
            return numWithN >= r.length / 2 ? '\r\n' : '\r';
        }
        function tryParseFloat(val) {
            var isNumber = FLOAT.test(val);
            return isNumber ? parseFloat(val) : val;
        }
        function addError(type, code, msg, row) {
            _results.errors.push({
                type: type,
                code: code,
                message: msg,
                row: row
            });
        }
    }
    function Parser(config) {
        config = config || {};
        var delim = config.delimiter;
        var newline = config.newline;
        var comments = config.comments;
        var step = config.step;
        var preview = config.preview;
        var fastMode = config.fastMode;
        if (typeof delim !== 'string'
            || delim.length != 1
            || Papa.BAD_DELIMITERS.indexOf(delim) > -1)
            delim = ",";
        if (comments === delim)
            throw "Comment character same as delimiter";
        else if (comments === true)
            comments = "#";
        else if (typeof comments !== 'string'
            || Papa.BAD_DELIMITERS.indexOf(comments) > -1)
            comments = false;
        if (newline != '\n' && newline != '\r' && newline != '\r\n')
            newline = '\n';
        var cursor = 0;
        var aborted = false;
        this.parse = function (input, baseIndex, ignoreLastRow) {
            if (typeof input !== 'string')
                throw "Input must be a string";
            var inputLen = input.length, delimLen = delim.length, newlineLen = newline.length, commentsLen = comments.length;
            var stepIsFunction = typeof step === 'function';
            cursor = 0;
            var data = [], errors = [], row = [], lastCursor = 0;
            if (!input)
                return returnable();
            if (fastMode || (fastMode !== false && input.indexOf('"') === -1)) {
                var rows = input.split(newline);
                for (var i = 0; i < rows.length; i++) {
                    var row = rows[i];
                    cursor += row.length;
                    if (i !== rows.length - 1)
                        cursor += newline.length;
                    else if (ignoreLastRow)
                        return returnable();
                    if (comments && row.substr(0, commentsLen) == comments)
                        continue;
                    if (stepIsFunction) {
                        data = [];
                        pushRow(row.split(delim));
                        doStep();
                        if (aborted)
                            return returnable();
                    }
                    else
                        pushRow(row.split(delim));
                    if (preview && i >= preview) {
                        data = data.slice(0, preview);
                        return returnable(true);
                    }
                }
                return returnable();
            }
            var nextDelim = input.indexOf(delim, cursor);
            var nextNewline = input.indexOf(newline, cursor);
            for (;;) {
                if (input[cursor] == '"') {
                    var quoteSearch = cursor;
                    cursor++;
                    for (;;) {
                        var quoteSearch = input.indexOf('"', quoteSearch + 1);
                        if (quoteSearch === -1) {
                            if (!ignoreLastRow) {
                                errors.push({
                                    type: "Quotes",
                                    code: "MissingQuotes",
                                    message: "Quoted field unterminated",
                                    row: data.length,
                                    index: cursor
                                });
                            }
                            return finish();
                        }
                        if (quoteSearch === inputLen - 1) {
                            var value = input.substring(cursor, quoteSearch).replace(/""/g, '"');
                            return finish(value);
                        }
                        if (input[quoteSearch + 1] == '"') {
                            quoteSearch++;
                            continue;
                        }
                        if (input[quoteSearch + 1] == delim) {
                            row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
                            cursor = quoteSearch + 1 + delimLen;
                            nextDelim = input.indexOf(delim, cursor);
                            nextNewline = input.indexOf(newline, cursor);
                            break;
                        }
                        if (input.substr(quoteSearch + 1, newlineLen) === newline) {
                            row.push(input.substring(cursor, quoteSearch).replace(/""/g, '"'));
                            saveRow(quoteSearch + 1 + newlineLen);
                            nextDelim = input.indexOf(delim, cursor);
                            if (stepIsFunction) {
                                doStep();
                                if (aborted)
                                    return returnable();
                            }
                            if (preview && data.length >= preview)
                                return returnable(true);
                            break;
                        }
                    }
                    continue;
                }
                if (comments && row.length === 0 && input.substr(cursor, commentsLen) === comments) {
                    if (nextNewline == -1)
                        return returnable();
                    cursor = nextNewline + newlineLen;
                    nextNewline = input.indexOf(newline, cursor);
                    nextDelim = input.indexOf(delim, cursor);
                    continue;
                }
                if (nextDelim !== -1 && (nextDelim < nextNewline || nextNewline === -1)) {
                    row.push(input.substring(cursor, nextDelim));
                    cursor = nextDelim + delimLen;
                    nextDelim = input.indexOf(delim, cursor);
                    continue;
                }
                if (nextNewline !== -1) {
                    row.push(input.substring(cursor, nextNewline));
                    saveRow(nextNewline + newlineLen);
                    if (stepIsFunction) {
                        doStep();
                        if (aborted)
                            return returnable();
                    }
                    if (preview && data.length >= preview)
                        return returnable(true);
                    continue;
                }
                break;
            }
            return finish();
            function pushRow(row) {
                data.push(row);
                lastCursor = cursor;
            }
            function finish(value) {
                if (ignoreLastRow)
                    return returnable();
                if (!value)
                    value = input.substr(cursor);
                row.push(value);
                cursor = inputLen;
                pushRow(row);
                if (stepIsFunction)
                    doStep();
                return returnable();
            }
            function saveRow(newCursor) {
                cursor = newCursor;
                pushRow(row);
                row = [];
                nextNewline = input.indexOf(newline, cursor);
            }
            function returnable(stopped) {
                return {
                    data: data,
                    errors: errors,
                    meta: {
                        delimiter: delim,
                        linebreak: newline,
                        aborted: aborted,
                        truncated: !!stopped,
                        cursor: lastCursor + (baseIndex || 0)
                    }
                };
            }
            function doStep() {
                step(returnable());
                data = [], errors = [];
            }
        };
        this.abort = function () {
            aborted = true;
        };
        this.getCharIndex = function () {
            return cursor;
        };
    }
    function getScriptPath() {
        var scripts = document.getElementsByTagName('script');
        return scripts.length ? scripts[scripts.length - 1].src : '';
    }
    function newWorker() {
        if (!Papa.WORKERS_SUPPORTED)
            return false;
        if (!LOADED_SYNC && Papa.SCRIPT_PATH === null)
            throw new Error('Script path cannot be determined automatically when Papa Parse is loaded asynchronously. ' +
                'You need to set Papa.SCRIPT_PATH manually.');
        var w = new global.Worker(Papa.SCRIPT_PATH || AUTO_SCRIPT_PATH);
        w.onmessage = mainThreadReceivedMessage;
        w.id = workerIdCounter++;
        workers[w.id] = w;
        return w;
    }
    function mainThreadReceivedMessage(e) {
        var msg = e.data;
        var worker = workers[msg.workerId];
        var aborted = false;
        if (msg.error)
            worker.userError(msg.error, msg.file);
        else if (msg.results && msg.results.data) {
            var abort = function () {
                aborted = true;
                completeWorker(msg.workerId, { data: [], errors: [], meta: { aborted: true } });
            };
            var handle = {
                abort: abort,
                pause: notImplemented,
                resume: notImplemented
            };
            if (isFunction(worker.userStep)) {
                for (var i = 0; i < msg.results.data.length; i++) {
                    worker.userStep({
                        data: [msg.results.data[i]],
                        errors: msg.results.errors,
                        meta: msg.results.meta
                    }, handle);
                    if (aborted)
                        break;
                }
                delete msg.results;
            }
            else if (isFunction(worker.userChunk)) {
                worker.userChunk(msg.results, handle, msg.file);
                delete msg.results;
            }
        }
        if (msg.finished && !aborted)
            completeWorker(msg.workerId, msg.results);
    }
    function completeWorker(workerId, results) {
        var worker = workers[workerId];
        if (isFunction(worker.userComplete))
            worker.userComplete(results);
        worker.terminate();
        delete workers[workerId];
    }
    function notImplemented() {
        throw "Not implemented.";
    }
    function workerThreadReceivedMessage(e) {
        var msg = e.data;
        if (typeof Papa.WORKER_ID === 'undefined' && msg)
            Papa.WORKER_ID = msg.workerId;
        if (typeof msg.input === 'string') {
            global.postMessage({
                workerId: Papa.WORKER_ID,
                results: Papa.parse(msg.input, msg.config),
                finished: true
            });
        }
        else if ((global.File && msg.input instanceof File) || msg.input instanceof Object) {
            var results = Papa.parse(msg.input, msg.config);
            if (results)
                global.postMessage({
                    workerId: Papa.WORKER_ID,
                    results: results,
                    finished: true
                });
        }
    }
    function copy(obj) {
        if (typeof obj !== 'object')
            return obj;
        var cpy = obj instanceof Array ? [] : {};
        for (var key in obj)
            cpy[key] = copy(obj[key]);
        return cpy;
    }
    function bindFunction(f, self) {
        return function () {
            f.apply(self, arguments);
        };
    }
    function isFunction(func) {
        return typeof func === 'function';
    }
})(this);
(function (exports) {
    (function (exports) {
        var science = exports.science = { version: "1.9.1" };
        science.ascending = function (a, b) {
            return a - b;
        };
        science.EULER = .5772156649015329;
        science.expm1 = function (x) {
            return (x < 1e-5 && x > -1e-5) ? x + .5 * x * x : Math.exp(x) - 1;
        };
        science.functor = function (v) {
            return typeof v === "function" ? v : function () { return v; };
        };
        science.hypot = function (x, y) {
            x = Math.abs(x);
            y = Math.abs(y);
            var max, min;
            if (x > y) {
                max = x;
                min = y;
            }
            else {
                max = y;
                min = x;
            }
            var r = min / max;
            return max * Math.sqrt(1 + r * r);
        };
        science.quadratic = function () {
            var complex = false;
            function quadratic(a, b, c) {
                var d = b * b - 4 * a * c;
                if (d > 0) {
                    d = Math.sqrt(d) / (2 * a);
                    return complex
                        ? [{ r: -b - d, i: 0 }, { r: -b + d, i: 0 }]
                        : [-b - d, -b + d];
                }
                else if (d === 0) {
                    d = -b / (2 * a);
                    return complex ? [{ r: d, i: 0 }] : [d];
                }
                else {
                    if (complex) {
                        d = Math.sqrt(-d) / (2 * a);
                        return [
                            { r: -b, i: -d },
                            { r: -b, i: d }
                        ];
                    }
                    return [];
                }
            }
            quadratic.complex = function (x) {
                if (!arguments.length)
                    return complex;
                complex = x;
                return quadratic;
            };
            return quadratic;
        };
        science.zeroes = function (n) {
            var i = -1, a = [];
            if (arguments.length === 1)
                while (++i < n)
                    a[i] = 0;
            else
                while (++i < n)
                    a[i] = science.zeroes.apply(this, Array.prototype.slice.call(arguments, 1));
            return a;
        };
    })(this);
    (function (exports) {
        science.lin = {};
        science.lin.decompose = function () {
            function decompose(A) {
                var n = A.length, V = [], d = [], e = [];
                for (var i = 0; i < n; i++) {
                    V[i] = [];
                    d[i] = [];
                    e[i] = [];
                }
                var symmetric = true;
                for (var j = 0; j < n; j++) {
                    for (var i = 0; i < n; i++) {
                        if (A[i][j] !== A[j][i]) {
                            symmetric = false;
                            break;
                        }
                    }
                }
                if (symmetric) {
                    for (var i = 0; i < n; i++)
                        V[i] = A[i].slice();
                    science_lin_decomposeTred2(d, e, V);
                    science_lin_decomposeTql2(d, e, V);
                }
                else {
                    var H = [];
                    for (var i = 0; i < n; i++)
                        H[i] = A[i].slice();
                    science_lin_decomposeOrthes(H, V);
                    science_lin_decomposeHqr2(d, e, H, V);
                }
                var D = [];
                for (var i = 0; i < n; i++) {
                    var row = D[i] = [];
                    for (var j = 0; j < n; j++)
                        row[j] = i === j ? d[i] : 0;
                    D[i][e[i] > 0 ? i + 1 : i - 1] = e[i];
                }
                return { D: D, V: V };
            }
            return decompose;
        };
        function science_lin_decomposeTred2(d, e, V) {
            var n = V.length;
            for (var j = 0; j < n; j++)
                d[j] = V[n - 1][j];
            for (var i = n - 1; i > 0; i--) {
                var scale = 0, h = 0;
                for (var k = 0; k < i; k++)
                    scale += Math.abs(d[k]);
                if (scale === 0) {
                    e[i] = d[i - 1];
                    for (var j = 0; j < i; j++) {
                        d[j] = V[i - 1][j];
                        V[i][j] = 0;
                        V[j][i] = 0;
                    }
                }
                else {
                    for (var k = 0; k < i; k++) {
                        d[k] /= scale;
                        h += d[k] * d[k];
                    }
                    var f = d[i - 1];
                    var g = Math.sqrt(h);
                    if (f > 0)
                        g = -g;
                    e[i] = scale * g;
                    h = h - f * g;
                    d[i - 1] = f - g;
                    for (var j = 0; j < i; j++)
                        e[j] = 0;
                    for (var j = 0; j < i; j++) {
                        f = d[j];
                        V[j][i] = f;
                        g = e[j] + V[j][j] * f;
                        for (var k = j + 1; k <= i - 1; k++) {
                            g += V[k][j] * d[k];
                            e[k] += V[k][j] * f;
                        }
                        e[j] = g;
                    }
                    f = 0;
                    for (var j = 0; j < i; j++) {
                        e[j] /= h;
                        f += e[j] * d[j];
                    }
                    var hh = f / (h + h);
                    for (var j = 0; j < i; j++)
                        e[j] -= hh * d[j];
                    for (var j = 0; j < i; j++) {
                        f = d[j];
                        g = e[j];
                        for (var k = j; k <= i - 1; k++)
                            V[k][j] -= (f * e[k] + g * d[k]);
                        d[j] = V[i - 1][j];
                        V[i][j] = 0;
                    }
                }
                d[i] = h;
            }
            for (var i = 0; i < n - 1; i++) {
                V[n - 1][i] = V[i][i];
                V[i][i] = 1.0;
                var h = d[i + 1];
                if (h != 0) {
                    for (var k = 0; k <= i; k++)
                        d[k] = V[k][i + 1] / h;
                    for (var j = 0; j <= i; j++) {
                        var g = 0;
                        for (var k = 0; k <= i; k++)
                            g += V[k][i + 1] * V[k][j];
                        for (var k = 0; k <= i; k++)
                            V[k][j] -= g * d[k];
                    }
                }
                for (var k = 0; k <= i; k++)
                    V[k][i + 1] = 0;
            }
            for (var j = 0; j < n; j++) {
                d[j] = V[n - 1][j];
                V[n - 1][j] = 0;
            }
            V[n - 1][n - 1] = 1;
            e[0] = 0;
        }
        function science_lin_decomposeTql2(d, e, V) {
            var n = V.length;
            for (var i = 1; i < n; i++)
                e[i - 1] = e[i];
            e[n - 1] = 0;
            var f = 0;
            var tst1 = 0;
            var eps = 1e-12;
            for (var l = 0; l < n; l++) {
                tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
                var m = l;
                while (m < n) {
                    if (Math.abs(e[m]) <= eps * tst1) {
                        break;
                    }
                    m++;
                }
                if (m > l) {
                    var iter = 0;
                    do {
                        iter++;
                        var g = d[l];
                        var p = (d[l + 1] - g) / (2 * e[l]);
                        var r = science.hypot(p, 1);
                        if (p < 0)
                            r = -r;
                        d[l] = e[l] / (p + r);
                        d[l + 1] = e[l] * (p + r);
                        var dl1 = d[l + 1];
                        var h = g - d[l];
                        for (var i = l + 2; i < n; i++)
                            d[i] -= h;
                        f += h;
                        p = d[m];
                        var c = 1;
                        var c2 = c;
                        var c3 = c;
                        var el1 = e[l + 1];
                        var s = 0;
                        var s2 = 0;
                        for (var i = m - 1; i >= l; i--) {
                            c3 = c2;
                            c2 = c;
                            s2 = s;
                            g = c * e[i];
                            h = c * p;
                            r = science.hypot(p, e[i]);
                            e[i + 1] = s * r;
                            s = e[i] / r;
                            c = p / r;
                            p = c * d[i] - s * g;
                            d[i + 1] = h + s * (c * g + s * d[i]);
                            for (var k = 0; k < n; k++) {
                                h = V[k][i + 1];
                                V[k][i + 1] = s * V[k][i] + c * h;
                                V[k][i] = c * V[k][i] - s * h;
                            }
                        }
                        p = -s * s2 * c3 * el1 * e[l] / dl1;
                        e[l] = s * p;
                        d[l] = c * p;
                    } while (Math.abs(e[l]) > eps * tst1);
                }
                d[l] = d[l] + f;
                e[l] = 0;
            }
            for (var i = 0; i < n - 1; i++) {
                var k = i;
                var p = d[i];
                for (var j = i + 1; j < n; j++) {
                    if (d[j] < p) {
                        k = j;
                        p = d[j];
                    }
                }
                if (k != i) {
                    d[k] = d[i];
                    d[i] = p;
                    for (var j = 0; j < n; j++) {
                        p = V[j][i];
                        V[j][i] = V[j][k];
                        V[j][k] = p;
                    }
                }
            }
        }
        function science_lin_decomposeOrthes(H, V) {
            var n = H.length;
            var ort = [];
            var low = 0;
            var high = n - 1;
            for (var m = low + 1; m < high; m++) {
                var scale = 0;
                for (var i = m; i <= high; i++)
                    scale += Math.abs(H[i][m - 1]);
                if (scale !== 0) {
                    var h = 0;
                    for (var i = high; i >= m; i--) {
                        ort[i] = H[i][m - 1] / scale;
                        h += ort[i] * ort[i];
                    }
                    var g = Math.sqrt(h);
                    if (ort[m] > 0)
                        g = -g;
                    h = h - ort[m] * g;
                    ort[m] = ort[m] - g;
                    for (var j = m; j < n; j++) {
                        var f = 0;
                        for (var i = high; i >= m; i--)
                            f += ort[i] * H[i][j];
                        f /= h;
                        for (var i = m; i <= high; i++)
                            H[i][j] -= f * ort[i];
                    }
                    for (var i = 0; i <= high; i++) {
                        var f = 0;
                        for (var j = high; j >= m; j--)
                            f += ort[j] * H[i][j];
                        f /= h;
                        for (var j = m; j <= high; j++)
                            H[i][j] -= f * ort[j];
                    }
                    ort[m] = scale * ort[m];
                    H[m][m - 1] = scale * g;
                }
            }
            for (var i = 0; i < n; i++) {
                for (var j = 0; j < n; j++)
                    V[i][j] = i === j ? 1 : 0;
            }
            for (var m = high - 1; m >= low + 1; m--) {
                if (H[m][m - 1] !== 0) {
                    for (var i = m + 1; i <= high; i++)
                        ort[i] = H[i][m - 1];
                    for (var j = m; j <= high; j++) {
                        var g = 0;
                        for (var i = m; i <= high; i++)
                            g += ort[i] * V[i][j];
                        g = (g / ort[m]) / H[m][m - 1];
                        for (var i = m; i <= high; i++)
                            V[i][j] += g * ort[i];
                    }
                }
            }
        }
        function science_lin_decomposeHqr2(d, e, H, V) {
            var nn = H.length, n = nn - 1, low = 0, high = nn - 1, eps = 1e-12, exshift = 0, p = 0, q = 0, r = 0, s = 0, z = 0, t, w, x, y;
            var norm = 0;
            for (var i = 0; i < nn; i++) {
                if (i < low || i > high) {
                    d[i] = H[i][i];
                    e[i] = 0;
                }
                for (var j = Math.max(i - 1, 0); j < nn; j++)
                    norm += Math.abs(H[i][j]);
            }
            var iter = 0;
            while (n >= low) {
                var l = n;
                while (l > low) {
                    s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);
                    if (s === 0)
                        s = norm;
                    if (Math.abs(H[l][l - 1]) < eps * s)
                        break;
                    l--;
                }
                if (l === n) {
                    H[n][n] = H[n][n] + exshift;
                    d[n] = H[n][n];
                    e[n] = 0;
                    n--;
                    iter = 0;
                }
                else if (l === n - 1) {
                    w = H[n][n - 1] * H[n - 1][n];
                    p = (H[n - 1][n - 1] - H[n][n]) / 2;
                    q = p * p + w;
                    z = Math.sqrt(Math.abs(q));
                    H[n][n] = H[n][n] + exshift;
                    H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;
                    x = H[n][n];
                    if (q >= 0) {
                        z = p + (p >= 0 ? z : -z);
                        d[n - 1] = x + z;
                        d[n] = d[n - 1];
                        if (z !== 0)
                            d[n] = x - w / z;
                        e[n - 1] = 0;
                        e[n] = 0;
                        x = H[n][n - 1];
                        s = Math.abs(x) + Math.abs(z);
                        p = x / s;
                        q = z / s;
                        r = Math.sqrt(p * p + q * q);
                        p /= r;
                        q /= r;
                        for (var j = n - 1; j < nn; j++) {
                            z = H[n - 1][j];
                            H[n - 1][j] = q * z + p * H[n][j];
                            H[n][j] = q * H[n][j] - p * z;
                        }
                        for (var i = 0; i <= n; i++) {
                            z = H[i][n - 1];
                            H[i][n - 1] = q * z + p * H[i][n];
                            H[i][n] = q * H[i][n] - p * z;
                        }
                        for (var i = low; i <= high; i++) {
                            z = V[i][n - 1];
                            V[i][n - 1] = q * z + p * V[i][n];
                            V[i][n] = q * V[i][n] - p * z;
                        }
                    }
                    else {
                        d[n - 1] = x + p;
                        d[n] = x + p;
                        e[n - 1] = z;
                        e[n] = -z;
                    }
                    n = n - 2;
                    iter = 0;
                }
                else {
                    x = H[n][n];
                    y = 0;
                    w = 0;
                    if (l < n) {
                        y = H[n - 1][n - 1];
                        w = H[n][n - 1] * H[n - 1][n];
                    }
                    if (iter == 10) {
                        exshift += x;
                        for (var i = low; i <= n; i++) {
                            H[i][i] -= x;
                        }
                        s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);
                        x = y = 0.75 * s;
                        w = -0.4375 * s * s;
                    }
                    if (iter == 30) {
                        s = (y - x) / 2.0;
                        s = s * s + w;
                        if (s > 0) {
                            s = Math.sqrt(s);
                            if (y < x) {
                                s = -s;
                            }
                            s = x - w / ((y - x) / 2.0 + s);
                            for (var i = low; i <= n; i++) {
                                H[i][i] -= s;
                            }
                            exshift += s;
                            x = y = w = 0.964;
                        }
                    }
                    iter++;
                    var m = n - 2;
                    while (m >= l) {
                        z = H[m][m];
                        r = x - z;
                        s = y - z;
                        p = (r * s - w) / H[m + 1][m] + H[m][m + 1];
                        q = H[m + 1][m + 1] - z - r - s;
                        r = H[m + 2][m + 1];
                        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
                        p = p / s;
                        q = q / s;
                        r = r / s;
                        if (m == l)
                            break;
                        if (Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) <
                            eps * (Math.abs(p) * (Math.abs(H[m - 1][m - 1]) + Math.abs(z) +
                                Math.abs(H[m + 1][m + 1])))) {
                            break;
                        }
                        m--;
                    }
                    for (var i = m + 2; i <= n; i++) {
                        H[i][i - 2] = 0;
                        if (i > m + 2)
                            H[i][i - 3] = 0;
                    }
                    for (var k = m; k <= n - 1; k++) {
                        var notlast = (k != n - 1);
                        if (k != m) {
                            p = H[k][k - 1];
                            q = H[k + 1][k - 1];
                            r = (notlast ? H[k + 2][k - 1] : 0);
                            x = Math.abs(p) + Math.abs(q) + Math.abs(r);
                            if (x != 0) {
                                p /= x;
                                q /= x;
                                r /= x;
                            }
                        }
                        if (x == 0)
                            break;
                        s = Math.sqrt(p * p + q * q + r * r);
                        if (p < 0) {
                            s = -s;
                        }
                        if (s != 0) {
                            if (k != m)
                                H[k][k - 1] = -s * x;
                            else if (l != m)
                                H[k][k - 1] = -H[k][k - 1];
                            p += s;
                            x = p / s;
                            y = q / s;
                            z = r / s;
                            q /= p;
                            r /= p;
                            for (var j = k; j < nn; j++) {
                                p = H[k][j] + q * H[k + 1][j];
                                if (notlast) {
                                    p = p + r * H[k + 2][j];
                                    H[k + 2][j] = H[k + 2][j] - p * z;
                                }
                                H[k][j] = H[k][j] - p * x;
                                H[k + 1][j] = H[k + 1][j] - p * y;
                            }
                            for (var i = 0; i <= Math.min(n, k + 3); i++) {
                                p = x * H[i][k] + y * H[i][k + 1];
                                if (notlast) {
                                    p += z * H[i][k + 2];
                                    H[i][k + 2] = H[i][k + 2] - p * r;
                                }
                                H[i][k] = H[i][k] - p;
                                H[i][k + 1] = H[i][k + 1] - p * q;
                            }
                            for (var i = low; i <= high; i++) {
                                p = x * V[i][k] + y * V[i][k + 1];
                                if (notlast) {
                                    p = p + z * V[i][k + 2];
                                    V[i][k + 2] = V[i][k + 2] - p * r;
                                }
                                V[i][k] = V[i][k] - p;
                                V[i][k + 1] = V[i][k + 1] - p * q;
                            }
                        }
                    }
                }
            }
            if (norm == 0) {
                return;
            }
            for (n = nn - 1; n >= 0; n--) {
                p = d[n];
                q = e[n];
                if (q == 0) {
                    var l = n;
                    H[n][n] = 1.0;
                    for (var i = n - 1; i >= 0; i--) {
                        w = H[i][i] - p;
                        r = 0;
                        for (var j = l; j <= n; j++) {
                            r = r + H[i][j] * H[j][n];
                        }
                        if (e[i] < 0) {
                            z = w;
                            s = r;
                        }
                        else {
                            l = i;
                            if (e[i] === 0) {
                                H[i][n] = -r / (w !== 0 ? w : eps * norm);
                            }
                            else {
                                x = H[i][i + 1];
                                y = H[i + 1][i];
                                q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
                                t = (x * s - z * r) / q;
                                H[i][n] = t;
                                if (Math.abs(x) > Math.abs(z)) {
                                    H[i + 1][n] = (-r - w * t) / x;
                                }
                                else {
                                    H[i + 1][n] = (-s - y * t) / z;
                                }
                            }
                            t = Math.abs(H[i][n]);
                            if ((eps * t) * t > 1) {
                                for (var j = i; j <= n; j++)
                                    H[j][n] = H[j][n] / t;
                            }
                        }
                    }
                }
                else if (q < 0) {
                    var l = n - 1;
                    if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {
                        H[n - 1][n - 1] = q / H[n][n - 1];
                        H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];
                    }
                    else {
                        var zz = science_lin_decomposeCdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);
                        H[n - 1][n - 1] = zz[0];
                        H[n - 1][n] = zz[1];
                    }
                    H[n][n - 1] = 0;
                    H[n][n] = 1;
                    for (var i = n - 2; i >= 0; i--) {
                        var ra = 0, sa = 0, vr, vi;
                        for (var j = l; j <= n; j++) {
                            ra = ra + H[i][j] * H[j][n - 1];
                            sa = sa + H[i][j] * H[j][n];
                        }
                        w = H[i][i] - p;
                        if (e[i] < 0) {
                            z = w;
                            r = ra;
                            s = sa;
                        }
                        else {
                            l = i;
                            if (e[i] == 0) {
                                var zz = science_lin_decomposeCdiv(-ra, -sa, w, q);
                                H[i][n - 1] = zz[0];
                                H[i][n] = zz[1];
                            }
                            else {
                                x = H[i][i + 1];
                                y = H[i + 1][i];
                                vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
                                vi = (d[i] - p) * 2.0 * q;
                                if (vr == 0 & vi == 0) {
                                    vr = eps * norm * (Math.abs(w) + Math.abs(q) +
                                        Math.abs(x) + Math.abs(y) + Math.abs(z));
                                }
                                var zz = science_lin_decomposeCdiv(x * r - z * ra + q * sa, x * s - z * sa - q * ra, vr, vi);
                                H[i][n - 1] = zz[0];
                                H[i][n] = zz[1];
                                if (Math.abs(x) > (Math.abs(z) + Math.abs(q))) {
                                    H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;
                                    H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;
                                }
                                else {
                                    var zz = science_lin_decomposeCdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);
                                    H[i + 1][n - 1] = zz[0];
                                    H[i + 1][n] = zz[1];
                                }
                            }
                            t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));
                            if ((eps * t) * t > 1) {
                                for (var j = i; j <= n; j++) {
                                    H[j][n - 1] = H[j][n - 1] / t;
                                    H[j][n] = H[j][n] / t;
                                }
                            }
                        }
                    }
                }
            }
            for (var i = 0; i < nn; i++) {
                if (i < low || i > high) {
                    for (var j = i; j < nn; j++)
                        V[i][j] = H[i][j];
                }
            }
            for (var j = nn - 1; j >= low; j--) {
                for (var i = low; i <= high; i++) {
                    z = 0;
                    for (var k = low; k <= Math.min(j, high); k++)
                        z += V[i][k] * H[k][j];
                    V[i][j] = z;
                }
            }
        }
        function science_lin_decomposeCdiv(xr, xi, yr, yi) {
            if (Math.abs(yr) > Math.abs(yi)) {
                var r = yi / yr, d = yr + r * yi;
                return [(xr + r * xi) / d, (xi - r * xr) / d];
            }
            else {
                var r = yr / yi, d = yi + r * yr;
                return [(r * xr + xi) / d, (r * xi - xr) / d];
            }
        }
        science.lin.cross = function (a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],
                a[2] * b[0] - a[0] * b[2],
                a[0] * b[1] - a[1] * b[0]
            ];
        };
        science.lin.dot = function (a, b) {
            var s = 0, i = -1, n = Math.min(a.length, b.length);
            while (++i < n)
                s += a[i] * b[i];
            return s;
        };
        science.lin.length = function (p) {
            return Math.sqrt(science.lin.dot(p, p));
        };
        science.lin.normalize = function (p) {
            var length = science.lin.length(p);
            return p.map(function (d) { return d / length; });
        };
        science.lin.determinant = function (matrix) {
            var m = matrix[0].concat(matrix[1]).concat(matrix[2]).concat(matrix[3]);
            return (m[12] * m[9] * m[6] * m[3] - m[8] * m[13] * m[6] * m[3] -
                m[12] * m[5] * m[10] * m[3] + m[4] * m[13] * m[10] * m[3] +
                m[8] * m[5] * m[14] * m[3] - m[4] * m[9] * m[14] * m[3] -
                m[12] * m[9] * m[2] * m[7] + m[8] * m[13] * m[2] * m[7] +
                m[12] * m[1] * m[10] * m[7] - m[0] * m[13] * m[10] * m[7] -
                m[8] * m[1] * m[14] * m[7] + m[0] * m[9] * m[14] * m[7] +
                m[12] * m[5] * m[2] * m[11] - m[4] * m[13] * m[2] * m[11] -
                m[12] * m[1] * m[6] * m[11] + m[0] * m[13] * m[6] * m[11] +
                m[4] * m[1] * m[14] * m[11] - m[0] * m[5] * m[14] * m[11] -
                m[8] * m[5] * m[2] * m[15] + m[4] * m[9] * m[2] * m[15] +
                m[8] * m[1] * m[6] * m[15] - m[0] * m[9] * m[6] * m[15] -
                m[4] * m[1] * m[10] * m[15] + m[0] * m[5] * m[10] * m[15]);
        };
        science.lin.gaussjordan = function (m, eps) {
            if (!eps)
                eps = 1e-10;
            var h = m.length, w = m[0].length, y = -1, y2, x;
            while (++y < h) {
                var maxrow = y;
                y2 = y;
                while (++y2 < h) {
                    if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
                        maxrow = y2;
                }
                var tmp = m[y];
                m[y] = m[maxrow];
                m[maxrow] = tmp;
                if (Math.abs(m[y][y]) <= eps)
                    return false;
                y2 = y;
                while (++y2 < h) {
                    var c = m[y2][y] / m[y][y];
                    x = y - 1;
                    while (++x < w) {
                        m[y2][x] -= m[y][x] * c;
                    }
                }
            }
            y = h;
            while (--y >= 0) {
                var c = m[y][y];
                y2 = -1;
                while (++y2 < y) {
                    x = w;
                    while (--x >= y) {
                        m[y2][x] -= m[y][x] * m[y2][y] / c;
                    }
                }
                m[y][y] /= c;
                x = h - 1;
                while (++x < w) {
                    m[y][x] /= c;
                }
            }
            return true;
        };
        science.lin.inverse = function (m) {
            var n = m.length, i = -1;
            if (n !== m[0].length)
                return;
            m = m.map(function (row, i) {
                var identity = new Array(n), j = -1;
                while (++j < n)
                    identity[j] = i === j ? 1 : 0;
                return row.concat(identity);
            });
            science.lin.gaussjordan(m);
            while (++i < n) {
                m[i] = m[i].slice(n);
            }
            return m;
        };
        science.lin.multiply = function (a, b) {
            var m = a.length, n = b[0].length, p = b.length, i = -1, j, k;
            if (p !== a[0].length)
                throw { "error": "columns(a) != rows(b); " + a[0].length + " != " + p };
            var ab = new Array(m);
            while (++i < m) {
                ab[i] = new Array(n);
                j = -1;
                while (++j < n) {
                    var s = 0;
                    k = -1;
                    while (++k < p)
                        s += a[i][k] * b[k][j];
                    ab[i][j] = s;
                }
            }
            return ab;
        };
        science.lin.transpose = function (a) {
            var m = a.length, n = a[0].length, i = -1, j, b = new Array(n);
            while (++i < n) {
                b[i] = new Array(m);
                j = -1;
                while (++j < m)
                    b[i][j] = a[j][i];
            }
            return b;
        };
        science.lin.tridag = function (a, b, c, d, x, n) {
            var i, m;
            for (i = 1; i < n; i++) {
                m = a[i] / b[i - 1];
                b[i] -= m * c[i - 1];
                d[i] -= m * d[i - 1];
            }
            x[n - 1] = d[n - 1] / b[n - 1];
            for (i = n - 2; i >= 0; i--) {
                x[i] = (d[i] - c[i] * x[i + 1]) / b[i];
            }
        };
    })(this);
    (function (exports) {
        science.stats = {};
        science.stats.bandwidth = {
            nrd0: function (x) {
                var hi = Math.sqrt(science.stats.variance(x));
                if (!(lo = Math.min(hi, science.stats.iqr(x) / 1.34)))
                    (lo = hi) || (lo = Math.abs(x[1])) || (lo = 1);
                return .9 * lo * Math.pow(x.length, -.2);
            },
            nrd: function (x) {
                var h = science.stats.iqr(x) / 1.34;
                return 1.06 * Math.min(Math.sqrt(science.stats.variance(x)), h)
                    * Math.pow(x.length, -1 / 5);
            }
        };
        science.stats.distance = {
            euclidean: function (a, b) {
                var n = a.length, i = -1, s = 0, x;
                while (++i < n) {
                    x = a[i] - b[i];
                    s += x * x;
                }
                return Math.sqrt(s);
            },
            manhattan: function (a, b) {
                var n = a.length, i = -1, s = 0;
                while (++i < n)
                    s += Math.abs(a[i] - b[i]);
                return s;
            },
            minkowski: function (p) {
                return function (a, b) {
                    var n = a.length, i = -1, s = 0;
                    while (++i < n)
                        s += Math.pow(Math.abs(a[i] - b[i]), p);
                    return Math.pow(s, 1 / p);
                };
            },
            chebyshev: function (a, b) {
                var n = a.length, i = -1, max = 0, x;
                while (++i < n) {
                    x = Math.abs(a[i] - b[i]);
                    if (x > max)
                        max = x;
                }
                return max;
            },
            hamming: function (a, b) {
                var n = a.length, i = -1, d = 0;
                while (++i < n)
                    if (a[i] !== b[i])
                        d++;
                return d;
            },
            jaccard: function (a, b) {
                var n = a.length, i = -1, s = 0;
                while (++i < n)
                    if (a[i] === b[i])
                        s++;
                return s / n;
            },
            braycurtis: function (a, b) {
                var n = a.length, i = -1, s0 = 0, s1 = 0, ai, bi;
                while (++i < n) {
                    ai = a[i];
                    bi = b[i];
                    s0 += Math.abs(ai - bi);
                    s1 += Math.abs(ai + bi);
                }
                return s0 / s1;
            }
        };
        science.stats.erf = function (x) {
            var a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
            var sign = x < 0 ? -1 : 1;
            if (x < 0) {
                sign = -1;
                x = -x;
            }
            var t = 1 / (1 + p * x);
            return sign * (1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1)
                * t * Math.exp(-x * x));
        };
        science.stats.phi = function (x) {
            return .5 * (1 + science.stats.erf(x / Math.SQRT2));
        };
        science.stats.kernel = {
            uniform: function (u) {
                if (u <= 1 && u >= -1)
                    return .5;
                return 0;
            },
            triangular: function (u) {
                if (u <= 1 && u >= -1)
                    return 1 - Math.abs(u);
                return 0;
            },
            epanechnikov: function (u) {
                if (u <= 1 && u >= -1)
                    return .75 * (1 - u * u);
                return 0;
            },
            quartic: function (u) {
                if (u <= 1 && u >= -1) {
                    var tmp = 1 - u * u;
                    return (15 / 16) * tmp * tmp;
                }
                return 0;
            },
            triweight: function (u) {
                if (u <= 1 && u >= -1) {
                    var tmp = 1 - u * u;
                    return (35 / 32) * tmp * tmp * tmp;
                }
                return 0;
            },
            gaussian: function (u) {
                return 1 / Math.sqrt(2 * Math.PI) * Math.exp(-.5 * u * u);
            },
            cosine: function (u) {
                if (u <= 1 && u >= -1)
                    return Math.PI / 4 * Math.cos(Math.PI / 2 * u);
                return 0;
            }
        };
        science.stats.kde = function () {
            var kernel = science.stats.kernel.gaussian, sample = [], bandwidth = science.stats.bandwidth.nrd;
            function kde(points, i) {
                var bw = bandwidth.call(this, sample);
                return points.map(function (x) {
                    var i = -1, y = 0, n = sample.length;
                    while (++i < n) {
                        y += kernel((x - sample[i]) / bw);
                    }
                    return [x, y / bw / n];
                });
            }
            kde.kernel = function (x) {
                if (!arguments.length)
                    return kernel;
                kernel = x;
                return kde;
            };
            kde.sample = function (x) {
                if (!arguments.length)
                    return sample;
                sample = x;
                return kde;
            };
            kde.bandwidth = function (x) {
                if (!arguments.length)
                    return bandwidth;
                bandwidth = science.functor(x);
                return kde;
            };
            return kde;
        };
        science.stats.kmeans = function () {
            var distance = science.stats.distance.euclidean, maxIterations = 1000, k = 1;
            function kmeans(vectors) {
                var n = vectors.length, assignments = [], clusterSizes = [], repeat = 1, iterations = 0, centroids = science_stats_kmeansRandom(k, vectors), newCentroids, i, j, x, d, min, best;
                while (repeat && iterations < maxIterations) {
                    j = -1;
                    while (++j < k) {
                        clusterSizes[j] = 0;
                    }
                    i = -1;
                    while (++i < n) {
                        x = vectors[i];
                        min = Infinity;
                        j = -1;
                        while (++j < k) {
                            d = distance.call(this, centroids[j], x);
                            if (d < min) {
                                min = d;
                                best = j;
                            }
                        }
                        clusterSizes[assignments[i] = best]++;
                    }
                    newCentroids = [];
                    i = -1;
                    while (++i < n) {
                        x = assignments[i];
                        d = newCentroids[x];
                        if (d == null)
                            newCentroids[x] = vectors[i].slice();
                        else {
                            j = -1;
                            while (++j < d.length) {
                                d[j] += vectors[i][j];
                            }
                        }
                    }
                    j = -1;
                    while (++j < k) {
                        x = newCentroids[j];
                        d = 1 / clusterSizes[j];
                        i = -1;
                        while (++i < x.length)
                            x[i] *= d;
                    }
                    repeat = 0;
                    j = -1;
                    while (++j < k) {
                        if (!science_stats_kmeansCompare(newCentroids[j], centroids[j])) {
                            repeat = 1;
                            break;
                        }
                    }
                    centroids = newCentroids;
                    iterations++;
                }
                return { assignments: assignments, centroids: centroids };
            }
            kmeans.k = function (x) {
                if (!arguments.length)
                    return k;
                k = x;
                return kmeans;
            };
            kmeans.distance = function (x) {
                if (!arguments.length)
                    return distance;
                distance = x;
                return kmeans;
            };
            return kmeans;
        };
        function science_stats_kmeansCompare(a, b) {
            if (!a || !b || a.length !== b.length)
                return false;
            var n = a.length, i = -1;
            while (++i < n)
                if (a[i] !== b[i])
                    return false;
            return true;
        }
        function science_stats_kmeansRandom(k, vectors) {
            var n = vectors.length;
            if (k > n)
                return null;
            var selected_vectors = [];
            var selected_indices = [];
            var tested_indices = {};
            var tested = 0;
            var selected = 0;
            var i, vector, select;
            while (selected < k) {
                if (tested === n)
                    return null;
                var random_index = Math.floor(Math.random() * n);
                if (random_index in tested_indices)
                    continue;
                tested_indices[random_index] = 1;
                tested++;
                vector = vectors[random_index];
                select = true;
                for (i = 0; i < selected; i++) {
                    if (science_stats_kmeansCompare(vector, selected_vectors[i])) {
                        select = false;
                        break;
                    }
                }
                if (select) {
                    selected_vectors[selected] = vector;
                    selected_indices[selected] = random_index;
                    selected++;
                }
            }
            return selected_vectors;
        }
        science.stats.hcluster = function () {
            var distance = science.stats.distance.euclidean, linkage = "simple";
            function hcluster(vectors) {
                var n = vectors.length, dMin = [], cSize = [], distMatrix = [], clusters = [], c1, c2, c1Cluster, c2Cluster, p, root, i, j;
                i = -1;
                while (++i < n) {
                    dMin[i] = 0;
                    distMatrix[i] = [];
                    j = -1;
                    while (++j < n) {
                        distMatrix[i][j] = i === j ? Infinity : distance(vectors[i], vectors[j]);
                        if (distMatrix[i][dMin[i]] > distMatrix[i][j])
                            dMin[i] = j;
                    }
                }
                i = -1;
                while (++i < n) {
                    clusters[i] = [];
                    clusters[i][0] = {
                        left: null,
                        right: null,
                        dist: 0,
                        centroid: vectors[i],
                        size: 1,
                        depth: 0
                    };
                    cSize[i] = 1;
                }
                for (p = 0; p < n - 1; p++) {
                    c1 = 0;
                    for (i = 0; i < n; i++) {
                        if (distMatrix[i][dMin[i]] < distMatrix[c1][dMin[c1]])
                            c1 = i;
                    }
                    c2 = dMin[c1];
                    c1Cluster = clusters[c1][0];
                    c2Cluster = clusters[c2][0];
                    newCluster = {
                        left: c1Cluster,
                        right: c2Cluster,
                        dist: distMatrix[c1][c2],
                        centroid: calculateCentroid(c1Cluster.size, c1Cluster.centroid, c2Cluster.size, c2Cluster.centroid),
                        size: c1Cluster.size + c2Cluster.size,
                        depth: 1 + Math.max(c1Cluster.depth, c2Cluster.depth)
                    };
                    clusters[c1].splice(0, 0, newCluster);
                    cSize[c1] += cSize[c2];
                    for (j = 0; j < n; j++) {
                        switch (linkage) {
                            case "single":
                                if (distMatrix[c1][j] > distMatrix[c2][j])
                                    distMatrix[j][c1] = distMatrix[c1][j] = distMatrix[c2][j];
                                break;
                            case "complete":
                                if (distMatrix[c1][j] < distMatrix[c2][j])
                                    distMatrix[j][c1] = distMatrix[c1][j] = distMatrix[c2][j];
                                break;
                            case "average":
                                distMatrix[j][c1] = distMatrix[c1][j] = (cSize[c1] * distMatrix[c1][j] + cSize[c2] * distMatrix[c2][j]) / (cSize[c1] + cSize[j]);
                                break;
                        }
                    }
                    distMatrix[c1][c1] = Infinity;
                    for (i = 0; i < n; i++)
                        distMatrix[i][c2] = distMatrix[c2][i] = Infinity;
                    for (j = 0; j < n; j++) {
                        if (dMin[j] == c2)
                            dMin[j] = c1;
                        if (distMatrix[c1][j] < distMatrix[c1][dMin[c1]])
                            dMin[c1] = j;
                    }
                    root = newCluster;
                }
                return root;
            }
            hcluster.distance = function (x) {
                if (!arguments.length)
                    return distance;
                distance = x;
                return hcluster;
            };
            return hcluster;
        };
        function calculateCentroid(c1Size, c1Centroid, c2Size, c2Centroid) {
            var newCentroid = [], newSize = c1Size + c2Size, n = c1Centroid.length, i = -1;
            while (++i < n) {
                newCentroid[i] = (c1Size * c1Centroid[i] + c2Size * c2Centroid[i]) / newSize;
            }
            return newCentroid;
        }
        science.stats.iqr = function (x) {
            var quartiles = science.stats.quantiles(x, [.25, .75]);
            return quartiles[1] - quartiles[0];
        };
        science.stats.loess = function () {
            var bandwidth = .3, robustnessIters = 2, accuracy = 1e-12;
            function smooth(xval, yval, weights) {
                var n = xval.length, i;
                if (n !== yval.length)
                    throw { error: "Mismatched array lengths" };
                if (n == 0)
                    throw { error: "At least one point required." };
                if (arguments.length < 3) {
                    weights = [];
                    i = -1;
                    while (++i < n)
                        weights[i] = 1;
                }
                science_stats_loessFiniteReal(xval);
                science_stats_loessFiniteReal(yval);
                science_stats_loessFiniteReal(weights);
                science_stats_loessStrictlyIncreasing(xval);
                if (n == 1)
                    return [yval[0]];
                if (n == 2)
                    return [yval[0], yval[1]];
                var bandwidthInPoints = Math.floor(bandwidth * n);
                if (bandwidthInPoints < 2)
                    throw { error: "Bandwidth too small." };
                var res = [], residuals = [], robustnessWeights = [];
                i = -1;
                while (++i < n) {
                    res[i] = 0;
                    residuals[i] = 0;
                    robustnessWeights[i] = 1;
                }
                var iter = -1;
                while (++iter <= robustnessIters) {
                    var bandwidthInterval = [0, bandwidthInPoints - 1];
                    var x;
                    i = -1;
                    while (++i < n) {
                        x = xval[i];
                        if (i > 0) {
                            science_stats_loessUpdateBandwidthInterval(xval, weights, i, bandwidthInterval);
                        }
                        var ileft = bandwidthInterval[0], iright = bandwidthInterval[1];
                        var edge = (xval[i] - xval[ileft]) > (xval[iright] - xval[i]) ? ileft : iright;
                        var sumWeights = 0, sumX = 0, sumXSquared = 0, sumY = 0, sumXY = 0, denom = Math.abs(1 / (xval[edge] - x));
                        for (var k = ileft; k <= iright; ++k) {
                            var xk = xval[k], yk = yval[k], dist = k < i ? x - xk : xk - x, w = science_stats_loessTricube(dist * denom) * robustnessWeights[k] * weights[k], xkw = xk * w;
                            sumWeights += w;
                            sumX += xkw;
                            sumXSquared += xk * xkw;
                            sumY += yk * w;
                            sumXY += yk * xkw;
                        }
                        var meanX = sumX / sumWeights, meanY = sumY / sumWeights, meanXY = sumXY / sumWeights, meanXSquared = sumXSquared / sumWeights;
                        var beta = (Math.sqrt(Math.abs(meanXSquared - meanX * meanX)) < accuracy)
                            ? 0 : ((meanXY - meanX * meanY) / (meanXSquared - meanX * meanX));
                        var alpha = meanY - beta * meanX;
                        res[i] = beta * x + alpha;
                        residuals[i] = Math.abs(yval[i] - res[i]);
                    }
                    if (iter === robustnessIters) {
                        break;
                    }
                    var sortedResiduals = residuals.slice();
                    sortedResiduals.sort();
                    var medianResidual = sortedResiduals[Math.floor(n / 2)];
                    if (Math.abs(medianResidual) < accuracy)
                        break;
                    var arg, w;
                    i = -1;
                    while (++i < n) {
                        arg = residuals[i] / (6 * medianResidual);
                        robustnessWeights[i] = (arg >= 1) ? 0 : ((w = 1 - arg * arg) * w);
                    }
                }
                return res;
            }
            smooth.bandwidth = function (x) {
                if (!arguments.length)
                    return x;
                bandwidth = x;
                return smooth;
            };
            smooth.robustnessIterations = function (x) {
                if (!arguments.length)
                    return x;
                robustnessIters = x;
                return smooth;
            };
            smooth.accuracy = function (x) {
                if (!arguments.length)
                    return x;
                accuracy = x;
                return smooth;
            };
            return smooth;
        };
        function science_stats_loessFiniteReal(values) {
            var n = values.length, i = -1;
            while (++i < n)
                if (!isFinite(values[i]))
                    return false;
            return true;
        }
        function science_stats_loessStrictlyIncreasing(xval) {
            var n = xval.length, i = 0;
            while (++i < n)
                if (xval[i - 1] >= xval[i])
                    return false;
            return true;
        }
        function science_stats_loessTricube(x) {
            return (x = 1 - x * x * x) * x * x;
        }
        function science_stats_loessUpdateBandwidthInterval(xval, weights, i, bandwidthInterval) {
            var left = bandwidthInterval[0], right = bandwidthInterval[1];
            var nextRight = science_stats_loessNextNonzero(weights, right);
            if ((nextRight < xval.length) && (xval[nextRight] - xval[i]) < (xval[i] - xval[left])) {
                var nextLeft = science_stats_loessNextNonzero(weights, left);
                bandwidthInterval[0] = nextLeft;
                bandwidthInterval[1] = nextRight;
            }
        }
        function science_stats_loessNextNonzero(weights, i) {
            var j = i + 1;
            while (j < weights.length && weights[j] === 0)
                j++;
            return j;
        }
        science.stats.mean = function (x) {
            var n = x.length;
            if (n === 0)
                return NaN;
            var m = 0, i = -1;
            while (++i < n)
                m += (x[i] - m) / (i + 1);
            return m;
        };
        science.stats.median = function (x) {
            return science.stats.quantiles(x, [.5])[0];
        };
        science.stats.mode = function (x) {
            x = x.slice().sort(science.ascending);
            var mode, n = x.length, i = -1, l = i, last = null, max = 0, tmp, v;
            while (++i < n) {
                if ((v = x[i]) !== last) {
                    if ((tmp = i - l) > max) {
                        max = tmp;
                        mode = last;
                    }
                    last = v;
                    l = i;
                }
            }
            return mode;
        };
        science.stats.quantiles = function (d, quantiles) {
            d = d.slice().sort(science.ascending);
            var n_1 = d.length - 1;
            return quantiles.map(function (q) {
                if (q === 0)
                    return d[0];
                else if (q === 1)
                    return d[n_1];
                var index = 1 + q * n_1, lo = Math.floor(index), h = index - lo, a = d[lo - 1];
                return h === 0 ? a : a + h * (d[lo] - a);
            });
        };
        science.stats.variance = function (x) {
            var n = x.length;
            if (n < 1)
                return NaN;
            if (n === 1)
                return 0;
            var mean = science.stats.mean(x), i = -1, s = 0;
            while (++i < n) {
                var v = x[i] - mean;
                s += v * v;
            }
            return s / (n - 1);
        };
        science.stats.distribution = {};
        science.stats.distribution.gaussian = function () {
            var random = Math.random, mean = 0, sigma = 1, variance = 1;
            function gaussian() {
                var x1, x2, rad, y1;
                do {
                    x1 = 2 * random() - 1;
                    x2 = 2 * random() - 1;
                    rad = x1 * x1 + x2 * x2;
                } while (rad >= 1 || rad === 0);
                return mean + sigma * x1 * Math.sqrt(-2 * Math.log(rad) / rad);
            }
            gaussian.pdf = function (x) {
                x = (x - mu) / sigma;
                return science_stats_distribution_gaussianConstant * Math.exp(-.5 * x * x) / sigma;
            };
            gaussian.cdf = function (x) {
                x = (x - mu) / sigma;
                return .5 * (1 + science.stats.erf(x / Math.SQRT2));
            };
            gaussian.mean = function (x) {
                if (!arguments.length)
                    return mean;
                mean = +x;
                return gaussian;
            };
            gaussian.variance = function (x) {
                if (!arguments.length)
                    return variance;
                sigma = Math.sqrt(variance = +x);
                return gaussian;
            };
            gaussian.random = function (x) {
                if (!arguments.length)
                    return random;
                random = x;
                return gaussian;
            };
            return gaussian;
        };
        science_stats_distribution_gaussianConstant = 1 / Math.sqrt(2 * Math.PI);
    })(this);
})(this);
(function (a) { function b(a, b) { return !isNaN(a) && !isNaN(b) && a != Infinity && b != Infinity; } function c(a, b, c, d) { var e = [], f = a + c, g = b.length, h = -1; while (++h < g)
    e[h] = (a * b[h] + c * d[h]) / f; return e; } function d(a) { var b = science.lin.length(a), c = a.length; while (c-- > 0)
    a[c] /= b; return a; } reorder = { version: "0.0.1" }, reorder.dot = science.lin.dot, reorder.length = science.lin.length, reorder.normalize = science.lin.normalize, reorder.printmat = function (a) { var b, c, d, e; for (b = 0; b < a.length; b++) {
    d = a[b], e = "";
    for (c = 0; c < d.length; c++)
        e.length != 0 && (e += ", "), e += d[c].toFixed(4);
    console.log(b.toPrecision(3) + ": " + e);
} }, reorder.assert = function (a, b) { if (!a)
    throw console.log(b), b || "Assertion failed"; }, reorder.printhcluster = function (a, b) { return a.left == null ? Array(b + 1).join(" ") + "id: " + a.id : Array(b + 1).join(" ") + "id: " + a.id + ", dist: " + a.dist + "\n" + reorder.printhcluster(a.left, b + 1) + "\n" + reorder.printhcluster(a.right, b + 1); }, reorder.mean = science.stats.mean, reorder.meantranspose = function (a, b) { var c = a.length; if (c == 0)
    return NaN; var d = a[0].length, e = 0, f = -1, g; while (++f < c)
    e += (a[f][b] - e) / (f + 1); return e; }, reorder.meancolumns = function (a) { var b = a.length; if (b == 0)
    return NaN; var c = a[0].length, d = a[0].slice(0), e = 0, f, g; while (++e < b) {
    g = a[e];
    for (f = 0; f < c; f++)
        d[f] += (g[f] - d[f]) / (e + 1);
} return d; }, reorder.sum = function (a) { var b = a.length, c = a[0]; while (b-- > 1)
    c += a[b]; return c; }, reorder.distance = { euclidean: function (a, c) { var d = a.length, e = 0, f; while (d-- > 0)
        b(a[d], c[d]) && (f = a[d] - c[d], e += f * f); return Math.sqrt(e); }, manhattan: function (a, c) { var d = a.length, e = 0; while (d-- > 0)
        b(a[d], c[d]) && (e += Math.abs(a[d] - c[d])); return e; }, minkowski: function (a) { return function (c, d) { var e = c.length, f = 0; while (e-- > 0)
        b(c[e], d[e]) && (f += Math.pow(Math.abs(c[e] - d[e]), a)); return Math.pow(f, 1 / a); }; }, chebyshev: function (a, c) { var d = a.length, e = 0, f; while (d-- > 0)
        b(a[d], c[d]) && (f = Math.abs(a[d] - c[d]), f > e && (e = f)); return e; }, hamming: function (a, c) { var d = a.length, e = 0; while (d-- > 0)
        b(a[d], c[d]) && a[d] !== c[d] && e++; return e; }, jaccard: function (a, c) { var d = 0, e = a.length, f = 0; while (e-- > 0)
        b(a[e], c[e]) && (a[e] === c[e] && f++, d++); return d == 0 ? 0 : f / d; }, braycurtis: function (a, c) { var d = a.length, e = 0, f = 0, g, h; while (d-- > 0)
        g = a[d], h = c[d], b(g, h) && (e += Math.abs(g - h), f += Math.abs(g + h)); return f == 0 ? 0 : e / f; } }, reorder.range = function (a, b, c) { arguments.length < 3 && (c = 1, arguments.length < 2 && (b = a, a = 0)); var d = [], e = a; if (c < 0)
    for (; e > b; e += c)
        d.push(e);
else
    for (; e < b; e += c)
        d.push(e); return d; }, reorder.transpose = science.lin.transpose, reorder.transposeSlice = function (a, b, c) { arguments.length < 3 && (c = a[0].length, arguments.length < 2 && (b = 0)); var d = a.length, e = c, f = b - 1, g, h = new Array(c - b); while (++f < e) {
    h[f] = new Array(d), g = -1;
    while (++g < d)
        h[f - b][g] = a[g][f];
} return h; }, reorder.correlation = { pearson: function (a, b) { var c = science.stats.mean(a), d = science.stats.mean(b), e = 0, f = 0, g = 0, h, i, j, k = Math.min(a.length, b.length); if (k === 0)
        return NaN; for (h = 0; h < k; h++)
        i = a[h] - c, j = b[h] - d, e += i * j, f += i * i, g += j * j; return e / Math.sqrt(f * g); }, pearsonMatrix: function (a) { var b, c, d, e, f, g = a.length, h, i, j, k; if (g === 0)
        return NaN; i = Array(g), j = science.zeroes(g), k = science.zeroes(g); for (d = 0; d < g; d++)
        i[d] = science.stats.mean(a[d]); for (d = 0; d < g; d++) {
        b = a[d], c = i[d];
        for (e = 0; e < g; e++)
            f = b[e] - c, j[e] += f, k[e] += f * f;
    } h = Array(g); for (d = 0; d < g; d++) {
        h[d] = Array(g);
        for (e = 0; e < g; e++)
            h[d][e] = j[d] * j[e] / Math.sqrt(k[d] * k[e]);
    } return h; } }, reorder.heap = function (a) { function e(a) { return a * 2 + 1; } function f(a) { return a * 2 + 2; } function g(a) { return Math.floor((a - 1) / 2); } function h(a, d) { var e = b[a], f = b[d]; b[a] = f, c[f] = a, b[d] = e, c[e] = d; } function i(a) { var b = k(c[a], a); j(b); } function j(c) { for (;;) {
    var d = e(c), g = f(c), i;
    d < b.length && a(b[d], b[c]) < 0 ? i = d : i = c, g < b.length && a(b[g], b[i]) < 0 && (i = g);
    if (c == i)
        return;
    h(c, i), c = i;
} } function k(d, e) { var f = d; for (par = g(f); f > 0 && a(b[par], e) > 0; par = g(par)) {
    var h = b[par];
    b[f] = h, c[h] = f, f = par;
} return b[f] = e, c[e] = f, f; } var b = [], c = {}, d = {}; return d.length = function () { return b.length; }, d.insert = function (a) { var c = b.length; b.push(null), k(c, a); }, d.isEmpty = function () { return b.length == 0; }, d.peek = function () { if (b.length == 0)
    throw { error: "Empty heap" }; return b[0]; }, d.pop = function () { if (b.length == 0)
    throw { error: "Empty heap" }; var a = b[0]; if (a == null)
    return a; var d = b[b.length - 1]; return b[0] = d, c[d] = 0, b.pop(), b.length > 1 && j(0), delete c[a], a; }, d; }, reorder.permutation = reorder.range, reorder.graph = function (a, b) { function g() { var g, h, i = a.length, j = b.length; for (g = 0; g < i; ++g)
    (h = a[g]).index = g, h.weight = 0; for (g = 0; g < j; ++g)
    (h = b[g]).index = g, typeof h.source == "number" && (h.source = a[h.source]), typeof h.target == "number" && (h.target = a[h.target]), ++h.source.weight, ++h.target.weight; f = []; if (typeof d == "function")
    for (g = 0; g < j; ++g)
        f[g] = +d.call(this, b[g], g);
else
    for (g = 0; g < j; ++g)
        f[g] = d; e = Array(a.length); for (g = 0; g < a.length; ++g)
    e[g] = []; for (g = 0; g < b.length; ++g) {
    var h = b[g];
    e[h.source.index].push(h), h.source.index != h.target.index && e[h.target.index].push(h);
} return c; } function h(a) { return f[a]; } var c = {}, d = 1, e, f; return c.nodes = function (b) { return arguments.length ? (a = b, c) : a; }, c.links = function (a) { return arguments.length ? (b = a, c) : b; }, c.linkDistance = function (a) { return arguments.length ? (d = typeof a == "function" ? a : +a, c) : d; }, c.init = g, c.edges = function (a) { return e[a]; }, c.distance = h, c.neighbors = function (a) { var b = e[a], c = []; for (var d = 0; d < b.length; ++d) {
    var f = b[d];
    f.source.index == a ? c.push(f.target) : c.push(f.source);
} return c; }, c.other = function (a, c) { return typeof a == "number" && (a = b[a]), a.source.index == c ? a.target : a.source; }, c; }, reorder.dijkstra = function (a) { function d(b, c) { var d = {}, e, f, g, h, i, j, k = reorder.heap(function (a, b) { return d[a].weight - d[b].weight; }), l = { edge: -1, vertex: b, weight: 0 }, m; c || (c = {}), c[b] = l, k.insert(b); while (!k.isEmpty()) {
    l = c[k.pop()], f = l.vertex, e = a.edges(f);
    for (var n = 0; n < e.length; n++)
        h = e[n].index, i = l.weight + a.distance(h), g = a.other(h, f).index, j = c[g], j ? j.weight > i && (j.weight = i, j.edge = h, k.update(j.vertex)) : (m = { edge: h, vertex: g, weight: i }, k.insert(g), c[g] = m);
} return c; } var b = a, c = {}; return c.shortestPath = function (b, c) { var e = d(b), f, g; g = e[c], f = [g]; while (g.edge != -1)
    g = e[a.other(g.edge, g.vertex).index], f.unshift(g); return f; }, c; }, reorder.distmax = function (a) { var b = 0, c = a.length, d, e, f; for (d = 0; d < c; d++) {
    f = a[d];
    for (e = d + 1; e < c; e++)
        f[e] > b && (b = f[e]);
} return b; }, reorder.distmin = function (a) { var b = Infinity, c = a.length, d, e, f; for (d = 0; d < c; d++) {
    f = a[d];
    for (e = d + 1; e < c; e++)
        f[e] < b && (b = f[e]);
} return b; }, reorder.dist = function () { function b(b) { var c = b.length, d = []; for (var e = 0; e < c; e++) {
    var f = [];
    d[e] = f;
    for (var g = 0; g < c; g++)
        g < e ? f.push(d[g][e]) : e === g ? f.push(0) : f.push(a(b[e], b[g]));
} return d; } var a = reorder.distance.euclidean; return b.distance = function (c) { return arguments.length ? (a = c, b) : a; }, b; }, reorder.dist_remove = function (a, b, c) { arguments.length < 3 && (c = b + 1); var d; a.splice(b, c - b); for (d = a.length; d-- > 0;)
    a[d].splice(b, c - b); return a; }, reorder.randomPermute = function (a, b, c) { arguments.length < 3 && (c = a.length, arguments.length < 2 && (b = 0)); var d = c - b, e, f; while (d > 0)
    f = b + Math.floor(Math.random() * d--), e = a[b + d], a[b + d] = a[f], a[f] = e; return a; }, reorder.randomPermutation = function (a) { return reorder.randomPermute(reorder.permutation(a)); }, reorder.permute = function (a, b) { var c = b.length, d = a.slice(0); while (c--)
    d[c] = a[b[c]]; return d; }, reorder.permutetranspose = function (a, b) { var c = a.length; while (c-- > 0)
    a[c] = reorder.permute(a[c], b); return a; }, reorder.stablepermute = function (a, b) { var c = reorder.permute(a, b); return c[0] > c[c.length - 1] && c.reverse(), c; }, typeof science == "undefined" && (science = { version: "1.9.1" }, science.stats = {}), science.stats.hcluster = function () { function e(e) { var f = e.length, g = [], h = [], i = [], j, k, l, m, n, o, p, q, r = 0; if (d == null) {
    d = [], p = -1;
    while (++p < f) {
        g[p] = 0, d[p] = [], q = -1;
        while (++q < f)
            d[p][q] = p === q ? Infinity : a(e[p], e[q]), d[p][g[p]] > d[p][q] && (g[p] = q);
    }
}
else {
    if (d.length < f || d[0].length < f)
        throw { error: "Provided distance matrix length " + d.length + " instead of " + f };
    p = -1;
    while (++p < f) {
        g[p] = 0, q = -1;
        while (++q < f)
            p === q && (d[p][q] = Infinity), d[p][g[p]] > d[p][q] && (g[p] = q);
    }
} p = -1; while (++p < f)
    i[p] = [], i[p][0] = { left: null, right: null, dist: 0, centroid: e[p], id: r++, size: 1, depth: 0 }, h[p] = 1; for (n = 0; n < f - 1; n++) {
    j = 0;
    for (p = 0; p < f; p++)
        d[p][g[p]] < d[j][g[j]] && (j = p);
    k = g[j], l = i[j][0], m = i[k][0];
    var s = { left: l, right: m, dist: d[j][k], centroid: c(l.size, l.centroid, m.size, m.centroid), id: r++, size: l.size + m.size, depth: 1 + Math.max(l.depth, m.depth) };
    i[j].splice(0, 0, s), h[j] += h[k];
    for (q = 0; q < f; q++)
        switch (b) {
            case "single":
                d[j][q] > d[k][q] && (d[q][j] = d[j][q] = d[k][q]);
                break;
            case "complete":
                d[j][q] < d[k][q] && (d[q][j] = d[j][q] = d[k][q]);
                break;
            case "average": d[q][j] = d[j][q] = (h[j] * d[j][q] + h[k] * d[k][q]) / (h[j] + h[q]);
        }
    d[j][j] = Infinity;
    for (p = 0; p < f; p++)
        d[p][k] = d[k][p] = Infinity;
    for (q = 0; q < f; q++)
        g[q] == k && (g[q] = j), d[j][q] < d[j][g[j]] && (g[j] = q);
    o = s;
} return o; } var a = reorder.distance.euclidean, b = "simple", d = null; return e.linkage = function (a) { return arguments.length ? (b = a, e) : b; }, e.distance = function (b) { return arguments.length ? (a = b, e) : a; }, e.distanceMatrix = function (a) { return arguments.length ? (d = a.map(function (a) { return a.slice(0); }), e) : d; }, e; }, reorder.leafOrder = function () { function g(a) { return a.depth == 0; } function h(a) { return a == null ? [] : a.id in e ? e[a.id] : e[a.id] = i(a); } function i(a) { return a == null ? [] : a.depth == 0 ? [a.id] : h(a.left).concat(h(a.right)); } function j(a, b, c) { var d = "k" + a.id + "-" + b + "-" + c; return d in f ? f[d] : f[d] = k(a, b, c); } function k(b, c, d) { if (b.depth == 0)
    return [0, [b.id]]; var e = b.left, f = b.right, g = h(e), i = h(f), k, l; if (g.indexOf(c) != -1 && i.indexOf(d) != -1)
    k = e, l = f;
else {
    if (i.indexOf(c) == -1 || g.indexOf(d) == -1)
        throw { error: "Node is not common ancestor of " + c + ", " + d };
    k = f, l = e;
} var m = h(k.left), n = h(k.right), o = n.indexOf(c) != -1 ? m : n; o.length == 0 && (o = [c]); var p = h(l.left), q = h(l.right), r = q.indexOf(d) != -1 ? p : q; r.length == 0 && (r = [d]); var s = Infinity, t = []; for (var u = 0; u < o.length; u++) {
    var v = j(k, c, o[u]);
    for (var w = 0; w < r.length; w++) {
        var x = j(l, r[w], d), y = v[0] + a[o[u]][r[w]] + x[0];
        y < s && (s = y, t = v[1].concat(x[1]));
    }
} return [s, t]; } function l(b) { e = {}, f = {}; var c = Infinity, g = [], i = h(b.left), k = h(b.right); d && console.log(reorder.printhcluster(b, 0)); for (var l = 0; l < i.length; l++)
    for (var m = 0; m < k.length; m++) {
        var n = j(b, i[l], k[m]);
        n[0] < c && (c = n[0], g = n[1]);
    } return a = null, g; } function m(d) { a == null && (a = reorder.dist().distance(b)(d)); var e = science.stats.hcluster().linkage(c).distanceMatrix(a); return l(e(d)); } var a = null, b = reorder.distance.euclidean, c = "complete", d = 0, e = {}, f = {}; return m.debug = function (a) { return arguments.length ? (d = a, m) : d; }, m.distance = function (c) { return arguments.length ? (b = c, a = null, m) : b; }, m.linkage = function (a) { return arguments.length ? (c = a, m) : c; }, m.distanceMatrix = function (b) { return arguments.length ? (a = b.map(function (a) { return a.slice(0); }), m) : a; }, m.orderFull = l, m; }, reorder.order = function () { function j() { a = reorder.distance.euclidean, b = reorder.leafOrder, c = "complete", d = null, e = null, f = [], g = 0, h = 0, i = Infinity; } function k(a) { e = a, i = Math.min(i, a.length); var b = h > 0 ? h - 1 : 0, c = i < e.length ? i + 1 : i, d, g, k; for (d = f.length - 1; d > 0; d -= 2)
    g = f[d - 1], k = f[d], k >= c ? c > i ? (c = Math.min(c, g + 1), f.splice(d - 1, 2)) : k = c : g <= b ? b < h ? (b = Math.max(b, k - 1), f.splice(d - 1, 2)) : g = b : k - g < 3 && f.splice(d - 1, 2); try {
    return l(b, c);
}
finally {
    j();
} } function l(a, b) { var c = e, j, k, l, n; e = e.slice(a, b); if (h == 0 && i == e.length)
    return m(); g && console.log("i0=" + a + " j0=" + b), d != null ? (b != e.length && reorder.dist_remove(d, b, e.length), a > 0 && reorder.dist_remove(d, 0, a)) : s(); var o = reorder.distmax(d); if (a < h) {
    k = d[0];
    for (l = k.length; l-- > 1;)
        k[l] += o;
    for (l = d.length; l-- > 1;)
        d[l][0] += o;
    o += o;
    if (a != 0)
        for (l = 0; l < f.length; l++)
            f[l] -= a;
} if (b > i) {
    n = d.length - 1, k = d[n];
    for (l = n; l-- > 0;)
        k[l] += o, d[l][n] += o;
} return j = m(), a < h ? (j[0] != 0 && j.reverse(), b > i ? reorder.assert(j[0] == 0 && j[j.length - 1] == j.length - 1, "Invalid constrained permutation endpoints") : reorder.assert(j[0] == 0, "Invalid constrained permutation start")) : b > i && (j[j.length - 1] != j.length - 1 && (j = j.reverse()), reorder.assert(j[j.length - 1] == j.length - 1, "Invalid constrained permutation end")), a != 0 && (j = reorder.permutation(a).concat(j.map(function (b) { return b + a; }))), c.length > b && (j = j.concat(reorder.range(b, c.length))), j; } function m() { var a, b, c, h, i, j; if (f.length == 0)
    return n(); s(); for (b = f.length - 1; b > 0; b -= 2)
    h = f[b - 1], i = f[b], d = reorder.dist_remove(d, h + 1, i - 1), e.splice(h + 1, i - h - 2), g && console.log("Except[" + h + ", " + i + "]"), d[h][h + 1] != 0 && (d[h][h + 1] = d[h + 1][h] = -1); a = n(); for (b = 0; b < f.length; b += 2) {
    h = f[b], i = f[b + 1];
    for (c = 0; c < a.length; c++)
        a[c] > h ? a[c] += i - h - 2 : a[c] == h && (j = c);
    if (j > 0 && a[j - 1] == i - 1)
        Array.prototype.splice.apply(a, [j, 0].concat(reorder.range(i - 2, h, -1)));
    else {
        if (a[j + 1] != i - 1)
            throw "Range not respected";
        Array.prototype.splice.apply(a, [j + 1, 0].concat(reorder.range(h + 1, i - 1)));
    }
} return a; } function n() { var a, b, c, f, g, h, i, j, k = !1, l = [], m = {}; s(); for (g = 0; g < d.length - 1; g++) {
    b = d[g], c = [], f = b.indexOf(-1), f != -1 && (m[g] = [g, f], k = !0);
    for (h = b.length; --h > g;)
        b[h] == 0 ? (f = d[h].indexOf(-1), f != -1 && (m[g] = [h, f], d[f][g] = b[f] = -1, k = !0), c.unshift(h), d = reorder.dist_remove(d, h), e.splice(h, 1)) : b[h] < 0 && (k = !0);
    c.length != 0 && (c.unshift(g), l.push(c));
} if (k)
    for (g = 0; g < d.length - 1; g++) {
        b = d[g];
        for (h = g + 1; h < b.length - 1; h++)
            d[h][h + 1] == -1 && (d[h + 1][h] = d[h][h + 1] = 0);
    } a = q(); for (g = l.length; g-- > 0;) {
    c = l[g], h = a.indexOf(c[0]), i = m[c[0]], i && i[0] == c[0] && (h = o(a, h, i[0], i[1], 0), i = undefined);
    for (j = 1; j < c.length; j++)
        a = r(a, h, c[j]), i && i[0] == c[j] && (h = o(a, h, i[0], i[1], j), i = undefined);
} return a; } function o(a, b, c, d, e) { var f, g, h; if (b > 0 && a[b - 1] == d)
    return p(a, b, a.indexOf(c)), b + 1; if (a[b + e + 1] == d)
    return p(a, b + e, a.indexOf(c)), b; throw "Index not found"; } function p(a, b, c) { if (b == c)
    return; var d = a[b]; a[b] = a[c], a[c] = d; } function q() { g > 1 && reorder.printmat(d), g > 2 && reorder.printmat(e); var a = b().debug(g).linkage(c).distanceMatrix(d)(e); return g && console.log("Permutation: " + a), a; } function r(a, b, c) { return a = a.map(function (a) { return a < c ? a : a + 1; }), a.splice(b, 0, c), a; } function s() { return d == null && (d = reorder.dist().distance(a)(e)), d; } function t(c, d, e) { var f = reorder.dist().distance(a)(c), g, h, i, j = !1, k, l = -1; f[d][d + 1] = 0, f[d + 1][d] = 0; var m = b().distanceMatrix(f)(c); l = m.indexOf(d); for (h = 0; h < m.length; h++)
    i = m[h], i > d && (m[h] += e - d - 2); return l != 0 && m[l - 1] == e - 1 && (j = !0), j && (m.reverse(), l = m.length - l - 1), k = [l + 1, 0].concat(reorder.range(d + 1, e - 1)), Array.prototype.splice.apply(m, k), m; } var a = reorder.distance.euclidean, b = reorder.leafOrder, c = "complete", d, e, f = [], g = 0, h = 0, i = Infinity; return k.debug = function (a) { return arguments.length ? (g = a, k) : g; }, k.distance = function (b) { return arguments.length ? (a = b, k) : a; }, k.linkage = function (a) { return arguments.length ? (c = a, k) : c; }, k.limits = function (a, b) { return arguments.length ? (h = a, i = b, k) : [h, i]; }, k.except = function (a) { return arguments.length ? (f = a.sort(function (a, b) { if (a >= b)
    throw "Invalid list, indices not sorted"; return a - b; }), k) : f.slice(0); }, k.orderrowsexcept = k.orderexcept, k; }, reorder.covariance = science.lin.dot, reorder.covariancetranspose = function (a, b, c) { var d = a.length, e = 0, f; for (f = 0; f < d; f++)
    e += a[f][b] * a[f][c]; return e; }, reorder.variancecovariance = function (a) { var b = a[0].length, c = Array(b), d, e; for (d = 0; d < b; d++)
    c[d] = Array(b); for (d = 0; d < b; d++)
    for (e = d; e < b; e++)
        c[d][e] = c[e][d] = reorder.covariancetranspose(a, d, e); return c; }, reorder.poweriteration = function (a, b) { arguments.length < 2 && (b = 1e-4); var c = a.length, e = Array(c), f, g, h = Array(c), i, j = 10; reorder.assert(c == a[0].length, "poweriteration needs a square matrix"); for (f = 0; f < c; f++)
    e[f] = Math.random(); e = d(e); while (j-- > 0) {
    for (f = 0; f < c; f++) {
        h[f] = 0;
        for (g = 0; g < c; g++)
            h[f] += a[f][g] * e[g];
    }
    h = d(h);
    var k = h;
    h = e, e = k;
} return h; }, reorder.sortorder = function (a) { return reorder.range(0, a.length).sort(function (b, c) { return a[b] - a[c]; }); }, reorder.center = function (a) { var b = a.length; if (b == 0)
    return null; var c = reorder.meancolumns(a), d = c.length, e = Array(b), f, g, h; for (f = 0; f < b; f++) {
    h = a[f].slice(0);
    for (g = 0; g < d; g++)
        h[g] -= c[g];
    e[f] = h;
} return e; }, reorder.pca1d = function (a, b) { arguments.length < 2 && (b = 1e-4); var c = a.length; if (a.length == 0)
    return null; a = reorder.center(a); var d = reorder.variancecovariance(a); return reorder.poweriteration(d, b); }, reorder.pca1dorder = function (a, b) { return reorder.sortorder(pca1d(a, b)); }, reorder.sumlines = function (a) { var b = a.length, c = a[0].length, d = Array(b), e, f, g, h; for (e = 0; e < b; e++) {
    g = a[e], h = 0;
    for (f = 0; f < c; f++)
        h += g[f];
    d[e] = h;
} return d; }, reorder.sumcols = function (a) { var b = a.length, c = a[0].length, d = science.zeroes(c), e, f, g; for (e = 0; e < b; e++) {
    g = a[e];
    for (f = 0; f < c; f++)
        d[f] += g[f];
} return d; }, reorder.ca = function (a, b) { arguments.length < 2 && (b = 1e-4); var c = a.length, d = a[0].length, e = reorder.sumlines(a), f = reorder.sumcols(a), g = reorder.sum(f), h, i, j; for (h = 0; h < c; h++)
    a[h] = a[h].map(function (a) { return a / g; }); e = reorder.sumlines(a), f = reorder.sumcols(a); var k = Array(c), l; for (h = 0; h < c; h++) {
    k[h] = Array(d);
    for (i = 0; i < d; i++)
        l = e[h] * f[i], k[h][i] = (a[h][i] - l) / Math.sqrt(l);
} for (h = 0; h < c; h++)
    for (i = 0; i < d; i++)
        l = e[h] * f[i], a[h][i] = (a[h][i] - l) / (f[i] * Math.sqrt(e[h])); var m = Array(c); for (h = 0; h < c; h++)
    m[h] = Array(c); for (h = 0; h < c; h++)
    for (i = h; i < c; i++)
        m[h][i] = m[i][h] = reorder.covariance(k[h], k[i]); var n = reorder.poweriteration(m, b), o = 0; for (h = 0; h < c; h++)
    o += n[h] * m[h][0]; return o /= n[0], n; }; })(this);
var BSpline = function (points, degree, copy) {
    if (copy) {
        this.points = [];
        for (var i = 0; i < points.length; i++) {
            this.points.push(points[i]);
        }
    }
    else {
        this.points = points;
    }
    this.degree = degree;
    this.dimension = points[0].length;
    if (degree == 2) {
        this.baseFunc = this.basisDeg2;
        this.baseFuncRangeInt = 2;
    }
    else if (degree == 3) {
        this.baseFunc = this.basisDeg3;
        this.baseFuncRangeInt = 2;
    }
    else if (degree == 4) {
        this.baseFunc = this.basisDeg4;
        this.baseFuncRangeInt = 3;
    }
    else if (degree == 5) {
        this.baseFunc = this.basisDeg5;
        this.baseFuncRangeInt = 3;
    }
};
BSpline.prototype.seqAt = function (dim) {
    var points = this.points;
    var margin = this.degree + 1;
    return function (n) {
        if (n < margin) {
            return points[0][dim];
        }
        else if (points.length + margin <= n) {
            return points[points.length - 1][dim];
        }
        else {
            return points[n - margin][dim];
        }
    };
};
BSpline.prototype.basisDeg2 = function (x) {
    if (-0.5 <= x && x < 0.5) {
        return 0.75 - x * x;
    }
    else if (0.5 <= x && x <= 1.5) {
        return 1.125 + (-1.5 + x / 2.0) * x;
    }
    else if (-1.5 <= x && x < -0.5) {
        return 1.125 + (1.5 + x / 2.0) * x;
    }
    else {
        return 0;
    }
};
BSpline.prototype.basisDeg3 = function (x) {
    if (-1 <= x && x < 0) {
        return 2.0 / 3.0 + (-1.0 - x / 2.0) * x * x;
    }
    else if (1 <= x && x <= 2) {
        return 4.0 / 3.0 + x * (-2.0 + (1.0 - x / 6.0) * x);
    }
    else if (-2 <= x && x < -1) {
        return 4.0 / 3.0 + x * (2.0 + (1.0 + x / 6.0) * x);
    }
    else if (0 <= x && x < 1) {
        return 2.0 / 3.0 + (-1.0 + x / 2.0) * x * x;
    }
    else {
        return 0;
    }
};
BSpline.prototype.basisDeg4 = function (x) {
    if (-1.5 <= x && x < -0.5) {
        return 55.0 / 96.0 + x * (-(5.0 / 24.0) + x * (-(5.0 / 4.0) + (-(5.0 / 6.0) - x / 6.0) * x));
    }
    else if (0.5 <= x && x < 1.5) {
        return 55.0 / 96.0 + x * (5.0 / 24.0 + x * (-(5.0 / 4.0) + (5.0 / 6.0 - x / 6.0) * x));
    }
    else if (1.5 <= x && x <= 2.5) {
        return 625.0 / 384.0 + x * (-(125.0 / 48.0) + x * (25.0 / 16.0 + (-(5.0 / 12.0) + x / 24.0) * x));
    }
    else if (-2.5 <= x && x <= -1.5) {
        return 625.0 / 384.0 + x * (125.0 / 48.0 + x * (25.0 / 16.0 + (5.0 / 12.0 + x / 24.0) * x));
    }
    else if (-1.5 <= x && x < 1.5) {
        return 115.0 / 192.0 + x * x * (-(5.0 / 8.0) + x * x / 4.0);
    }
    else {
        return 0;
    }
};
BSpline.prototype.basisDeg5 = function (x) {
    if (-2 <= x && x < -1) {
        return 17.0 / 40.0 + x * (-(5.0 / 8.0) + x * (-(7.0 / 4.0) + x * (-(5.0 / 4.0) + (-(3.0 / 8.0) - x / 24.0) * x)));
    }
    else if (0 <= x && x < 1) {
        return 11.0 / 20.0 + x * x * (-(1.0 / 2.0) + (1.0 / 4.0 - x / 12.0) * x * x);
    }
    else if (2 <= x && x <= 3) {
        return 81.0 / 40.0 + x * (-(27.0 / 8.0) + x * (9.0 / 4.0 + x * (-(3.0 / 4.0) + (1.0 / 8.0 - x / 120.0) * x)));
    }
    else if (-3 <= x && x < -2) {
        return 81.0 / 40.0 + x * (27.0 / 8.0 + x * (9.0 / 4.0 + x * (3.0 / 4.0 + (1.0 / 8.0 + x / 120.0) * x)));
    }
    else if (1 <= x && x < 2) {
        return 17.0 / 40.0 + x * (5.0 / 8.0 + x * (-(7.0 / 4.0) + x * (5.0 / 4.0 + (-(3.0 / 8.0) + x / 24.0) * x)));
    }
    else if (-1 <= x && x < 0) {
        return 11.0 / 20.0 + x * x * (-(1.0 / 2.0) + (1.0 / 4.0 + x / 12.0) * x * x);
    }
    else {
        return 0;
    }
};
BSpline.prototype.getInterpol = function (seq, t) {
    var f = this.baseFunc;
    var rangeInt = this.baseFuncRangeInt;
    var tInt = Math.floor(t);
    var result = 0;
    for (var i = tInt - rangeInt; i <= tInt + rangeInt; i++) {
        result += seq(i) * f(t - i);
    }
    return result;
};
BSpline.prototype.calcAt = function (t) {
    t = t * ((this.degree + 1) * 2 + this.points.length);
    if (this.dimension == 2) {
        return [this.getInterpol(this.seqAt(0), t), this.getInterpol(this.seqAt(1), t)];
    }
    else if (this.dimension == 3) {
        return [this.getInterpol(this.seqAt(0), t), this.getInterpol(this.seqAt(1), t), this.getInterpol(this.seqAt(2), t)];
    }
    else {
        var res = [];
        for (var i = 0; i < this.dimension; i++) {
            res.push(this.getInterpol(this.seqAt(i), t));
        }
        return res;
    }
};
var saveAs = saveAs || function (e) {
    "use strict";
    if ("undefined" == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
        var t = e.document, n = function () { return e.URL || e.webkitURL || e; }, o = t.createElementNS("http://www.w3.org/1999/xhtml", "a"), r = "download" in o, i = function (e) { var t = new MouseEvent("click"); e.dispatchEvent(t); }, a = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent), c = e.webkitRequestFileSystem, d = e.requestFileSystem || c || e.mozRequestFileSystem, u = function (t) { (e.setImmediate || e.setTimeout)(function () { throw t; }, 0); }, s = "application/octet-stream", f = 0, l = 4e4, v = function (e) { var t = function () { "string" == typeof e ? n().revokeObjectURL(e) : e.remove(); }; setTimeout(t, l); }, p = function (e, t, n) { t = [].concat(t); for (var o = t.length; o--;) {
            var r = e["on" + t[o]];
            if ("function" == typeof r)
                try {
                    r.call(e, n || e);
                }
                catch (i) {
                    u(i);
                }
        } }, w = function (e) { return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type) ? new Blob(["\uFEFF", e], { type: e.type }) : e; }, y = function (t, u, l) { l || (t = w(t)); var y, m, S, h = this, R = t.type, O = !1, g = function () { p(h, "writestart progress write writeend".split(" ")); }, b = function () { if (m && a && "undefined" != typeof FileReader) {
            var o = new FileReader;
            return o.onloadend = function () { var e = o.result; m.location.href = "data:attachment/file" + e.slice(e.search(/[,;]/)), h.readyState = h.DONE, g(); }, o.readAsDataURL(t), void (h.readyState = h.INIT);
        } if ((O || !y) && (y = n().createObjectURL(t)), m)
            m.location.href = y;
        else {
            var r = e.open(y, "_blank");
            void 0 === r && a && (e.location.href = y);
        } h.readyState = h.DONE, g(), v(y); }, E = function (e) { return function () { return h.readyState !== h.DONE ? e.apply(this, arguments) : void 0; }; }, N = { create: !0, exclusive: !1 }; return h.readyState = h.INIT, u || (u = "download"), r ? (y = n().createObjectURL(t), void setTimeout(function () { o.href = y, o.download = u, i(o), g(), v(y), h.readyState = h.DONE; })) : (e.chrome && R && R !== s && (S = t.slice || t.webkitSlice, t = S.call(t, 0, t.size, s), O = !0), c && "download" !== u && (u += ".download"), (R === s || c) && (m = e), d ? (f += t.size, void d(e.TEMPORARY, f, E(function (e) { e.root.getDirectory("saved", N, E(function (e) { var n = function () { e.getFile(u, N, E(function (e) { e.createWriter(E(function (n) { n.onwriteend = function (t) { m.location.href = e.toURL(), h.readyState = h.DONE, p(h, "writeend", t), v(e); }, n.onerror = function () { var e = n.error; e.code !== e.ABORT_ERR && b(); }, "writestart progress write abort".split(" ").forEach(function (e) { n["on" + e] = h["on" + e]; }), n.write(t), h.abort = function () { n.abort(), h.readyState = h.DONE; }, h.readyState = h.WRITING; }), b); }), b); }; e.getFile(u, { create: !1 }, E(function (e) { e.remove(), n(); }), E(function (e) { e.code === e.NOT_FOUND_ERR ? n() : b(); })); }), b); }), b)) : void b()); }, m = y.prototype, S = function (e, t, n) { return new y(e, t, n); };
        return "undefined" != typeof navigator && navigator.msSaveOrOpenBlob ? function (e, t, n) { return n || (e = w(e)), navigator.msSaveOrOpenBlob(e, t || "download"); } : (m.abort = function () { var e = this; e.readyState = e.DONE, p(e, "abort"); }, m.readyState = m.INIT = 0, m.WRITING = 1, m.DONE = 2, m.error = m.onwritestart = m.onprogress = m.onwrite = m.onabort = m.onerror = m.onwriteend = null, S);
    }
}("undefined" != typeof self && self || "undefined" != typeof window && window || this.content);
"undefined" != typeof module && module.exports ? module.exports.saveAs = saveAs : "undefined" != typeof define && null !== define && null !== define.amd && define([], function () { return saveAs; });
/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */
(function (view) {
    "use strict";
    var Uint8Array = view.Uint8Array, HTMLCanvasElement = view.HTMLCanvasElement, canvas_proto = HTMLCanvasElement && HTMLCanvasElement.prototype, is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i, to_data_url = "toDataURL", base64_ranks, decode_base64 = function (base64) {
        var len = base64.length, buffer = new Uint8Array(len / 4 * 3 | 0), i = 0, outptr = 0, last = [0, 0], state = 0, save = 0, rank, code, undef;
        while (len--) {
            code = base64.charCodeAt(i++);
            rank = base64_ranks[code - 43];
            if (rank !== 255 && rank !== undef) {
                last[1] = last[0];
                last[0] = code;
                save = (save << 6) | rank;
                state++;
                if (state === 4) {
                    buffer[outptr++] = save >>> 16;
                    if (last[1] !== 61) {
                        buffer[outptr++] = save >>> 8;
                    }
                    if (last[0] !== 61) {
                        buffer[outptr++] = save;
                    }
                    state = 0;
                }
            }
        }
        return buffer;
    };
    if (Uint8Array) {
        base64_ranks = new Uint8Array([
            62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1,
            -1, -1, 0, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
            10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
            -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
            36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
        ]);
    }
    if (HTMLCanvasElement && (!canvas_proto.toBlob || !canvas_proto.toBlobHD)) {
        if (!canvas_proto.toBlob)
            canvas_proto.toBlob = function (callback, type) {
                if (!type) {
                    type = "image/png";
                }
                if (this.mozGetAsFile) {
                    callback(this.mozGetAsFile("canvas", type));
                    return;
                }
                if (this.msToBlob && /^\s*image\/png\s*(?:$|;)/i.test(type)) {
                    callback(this.msToBlob());
                    return;
                }
                var args = Array.prototype.slice.call(arguments, 1), dataURI = this[to_data_url].apply(this, args), header_end = dataURI.indexOf(","), data = dataURI.substring(header_end + 1), is_base64 = is_base64_regex.test(dataURI.substring(0, header_end)), blob;
                if (Blob.fake) {
                    blob = new Blob;
                    if (is_base64) {
                        blob.encoding = "base64";
                    }
                    else {
                        blob.encoding = "URI";
                    }
                    blob.data = data;
                    blob.size = data.length;
                }
                else if (Uint8Array) {
                    if (is_base64) {
                        blob = new Blob([decode_base64(data)], { type: type });
                    }
                    else {
                        blob = new Blob([decodeURIComponent(data)], { type: type });
                    }
                }
                callback(blob);
            };
        if (!canvas_proto.toBlobHD && canvas_proto.toDataURLHD) {
            canvas_proto.toBlobHD = function () {
                to_data_url = "toDataURLHD";
                var blob = this.toBlob();
                to_data_url = "toDataURL";
                return blob;
            };
        }
        else {
            canvas_proto.toBlobHD = canvas_proto.toBlob;
        }
    }
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));
var colorSchemes;
(function (colorSchemes) {
    colorSchemes.schema1 = [
        '#775566',
        '#6688bb',
        '#556677',
        '#88aa88',
        '#88bb33',
        '#cc7744',
        '#003366',
        '#994422',
        '#331111'
    ];
    colorSchemes.schema2 = [
        '#44B3C2',
        '#F1A94E',
        '#E45641',
        '#5D4C46',
        '#7B8D8E',
        '#2ca02c',
        '#003366',
        '#9467bd',
        '#bcbd22',
        '#e377c2'
    ];
    colorSchemes.schema3 = [
        '#001166',
        '#0055aa',
        '#1199cc',
        '#99ccdd',
        '#002222',
        '#ddffff',
        '#446655',
        '#779988',
        '#115522'
    ];
    colorSchemes.schema4 = [
        '#1f77b4',
        '#ff7f0e',
        '#2ca02c',
        '#d62728',
        '#9467bd',
        '#8c564b',
        '#e377c2',
        '#7f7f7f',
        '#bcbd22',
        '#17becf'
    ];
    colorSchemes.schema5 = [
        '#1f77b4',
        '#aec7e8',
        '#ff7f0e',
        '#ffbb78',
        '#2ca02c',
        '#98df8a',
        '#d62728',
        '#ff9896',
        '#9467bd',
        '#c5b0d5',
        '#8c564b',
        '#c49c94',
        '#e377c2',
        '#f7b6d2',
        '#7f7f7f',
        '#c7c7c7',
        '#bcbd22',
        '#dbdb8d',
        '#17becf',
        '#9edae5'
    ];
    colorSchemes.schema6 = [
        '#a6cee3',
        '#1f78b4',
        '#b2df8a',
        '#33a02c',
        '#fb9a99',
        '#e31a1c',
        '#fdbf6f',
        '#ff7f00',
        '#cab2d6',
        '#6a3d9a',
        '#ffff99',
        '#b15928'
    ];
})(colorSchemes || (colorSchemes = {}));
var networkcube;
(function (networkcube) {
    function getPriorityColor(element) {
        var j = 0;
        var selections = element.getSelections();
        while (!selections[j].showColor) {
            j++;
            if (j == selections.length) {
                j = -1;
                return;
            }
        }
        return element.getSelections()[j].color;
    }
    networkcube.getPriorityColor = getPriorityColor;
    function sortByPriority(s1, s2) {
        return s1.priority - s2.priority;
    }
    networkcube.sortByPriority = sortByPriority;
    function getUrlVars() {
        var vars = {};
        var params = window.location.search.replace("?", "").split('&');
        var tmp, value;
        params.forEach(function (item) {
            tmp = item.split("=");
            value = decodeURIComponent(tmp[1]);
            vars[tmp[0]] = value;
        });
        return vars;
    }
    networkcube.getUrlVars = getUrlVars;
    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }
    networkcube.capitalizeFirstLetter = capitalizeFirstLetter;
    function isValidIndex(v) {
        return v != undefined && v > -1;
    }
    networkcube.isValidIndex = isValidIndex;
    function array(value, size) {
        var array = [];
        while (size--)
            array[size] = value;
        return array;
    }
    networkcube.array = array;
    function doubleArray(size1, size2, value) {
        var array = [];
        if (value == undefined)
            value = [];
        var a = [];
        if (size2) {
            while (size2--)
                a[size2] = value;
        }
        while (size1--)
            array[size1] = a.slice(0);
        return array;
    }
    networkcube.doubleArray = doubleArray;
    function isBefore(t1, t2) {
        return t1.time < t2.time;
    }
    networkcube.isBefore = isBefore;
    function isAfter(t1, t2) {
        return t1.time > t2.time;
    }
    networkcube.isAfter = isAfter;
    function hex2Rgb(hex) {
        return [hexToR(hex), hexToG(hex), hexToB(hex)];
    }
    networkcube.hex2Rgb = hex2Rgb;
    function hexToR(h) { return parseInt((cutHex(h)).substring(0, 2), 16); }
    function hexToG(h) { return parseInt((cutHex(h)).substring(2, 4), 16); }
    function hexToB(h) { return parseInt((cutHex(h)).substring(4, 6), 16); }
    function cutHex(h) { return (h.charAt(0) == "#") ? h.substring(1, 7) : h; }
    function hex2web(v) {
        v = v + '';
        return v.replace('0x', '#');
    }
    networkcube.hex2web = hex2web;
    function hex2RgbNormalized(hex) {
        return [hexToR(hex) / 255, hexToG(hex) / 255, hexToB(hex) / 255];
    }
    networkcube.hex2RgbNormalized = hex2RgbNormalized;
    function getType(elements) {
        if (elements.length == 0)
            return;
        var type;
        if (elements[0] instanceof networkcube.Node)
            type = 'node';
        else if (elements[0] instanceof networkcube.Link) {
            type = 'link';
        }
        else if (elements[0] instanceof networkcube.Time) {
            type = 'time';
        }
        else if (elements[0] instanceof networkcube.NodePair) {
            type = 'nodePair';
        }
        else if (elements[0] instanceof networkcube.LinkType) {
            type = 'linkType';
        }
        else if (typeof elements[0] == 'number') {
            type = 'number';
        }
        return type;
    }
    networkcube.getType = getType;
    function areEqualShallow(a, b) {
        for (var key in a) {
            if (!(key in b) || a[key] !== b[key]) {
                return false;
            }
        }
        for (var key in b) {
            if (!(key in a) || a[key] !== b[key]) {
                return false;
            }
        }
        return true;
    }
    networkcube.areEqualShallow = areEqualShallow;
    function compareTypesShallow(a, b) {
        if (a == null || b == null)
            return a == b;
        if (typeof a != typeof b)
            return false;
        else if (typeof a != 'object')
            return true;
        else if (a.constructor !== b.constructor)
            return false;
        else {
            return true;
        }
    }
    networkcube.compareTypesShallow = compareTypesShallow;
    function compareTypesDeep(a, b, depth) {
        var result = true;
        if (a == null || b == null)
            return a == b;
        if (typeof a != typeof b)
            return false;
        else if (typeof a != 'object')
            return true;
        else if (a.constructor !== b.constructor)
            return false;
        else {
            if (depth > 0) {
                for (var key in a) {
                    if (key in b
                        && a.hasOwnProperty(key)
                        && b.hasOwnProperty(key)
                        && !compareTypesDeep(a[key], b[key], depth - 1)) {
                        console.log("compareFailed for key", key, a[key], b[key]);
                        result = false;
                    }
                }
            }
            return result;
        }
    }
    networkcube.compareTypesDeep = compareTypesDeep;
    function copyPropsShallow(source, target) {
        for (var p in source) {
            if (source.hasOwnProperty(p))
                target[p] = source[p];
        }
        return target;
    }
    networkcube.copyPropsShallow = copyPropsShallow;
    function copyTimeseriesPropsShallow(source, target) {
        for (var q in source) {
            if (source.hasOwnProperty(q)) {
                for (var p in source[q]) {
                    if (source[q].hasOwnProperty(p)) {
                        target[q][p] = source[q][p];
                    }
                }
            }
        }
        return target;
    }
    networkcube.copyTimeseriesPropsShallow = copyTimeseriesPropsShallow;
    function copyArray(arr, ctorFunc) {
        var arrayClone = [];
        for (var elem in arr) {
            arrayClone.push(copyPropsShallow(arr[elem], ctorFunc()));
        }
        return arrayClone;
    }
    networkcube.copyArray = copyArray;
    function copyTimeSeries(arr, ctorFunc) {
        var arrayClone = [];
        for (var elem in arr) {
            arrayClone.push(copyTimeseriesPropsShallow(arr[elem], ctorFunc()));
        }
        return arrayClone;
    }
    networkcube.copyTimeSeries = copyTimeSeries;
    var Box = (function () {
        function Box(x1, y1, x2, y2) {
            this.x1 = Math.min(x1, x2);
            this.x2 = Math.max(x1, x2);
            this.y1 = Math.min(y1, y2);
            this.y2 = Math.max(y1, y2);
        }
        Object.defineProperty(Box.prototype, "width", {
            get: function () {
                return this.x2 - this.x1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Box.prototype, "height", {
            get: function () {
                return this.y2 - this.y1;
            },
            enumerable: true,
            configurable: true
        });
        Box.prototype.isPoint = function () {
            return (this.width == 0) && (this.height == 0);
        };
        return Box;
    }());
    networkcube.Box = Box;
    function inBox(x, y, box) {
        return (x > box.x1
            && x < box.x2
            && y > box.y1
            && y < box.y2);
    }
    networkcube.inBox = inBox;
    function isSame(a, b) {
        if (a.length != b.length)
            return false;
        var found = true;
        for (var i = 0; i < a.length; i++) {
            found = false;
            for (var j = 0; j < b.length; j++) {
                if (a[i] == b[j])
                    found = true;
            }
            if (!found)
                return false;
        }
        return true;
    }
    networkcube.isSame = isSame;
    function sortNumber(a, b) {
        return a - b;
    }
    networkcube.sortNumber = sortNumber;
    var ElementCompound = (function () {
        function ElementCompound() {
            this.nodes = [];
            this.links = [];
            this.times = [];
            this.nodePairs = [];
            this.locations = [];
        }
        return ElementCompound;
    }());
    networkcube.ElementCompound = ElementCompound;
    var IDCompound = (function () {
        function IDCompound() {
            this.nodeIds = [];
            this.linkIds = [];
            this.timeIds = [];
            this.nodePairIds = [];
            this.locationIds = [];
        }
        return IDCompound;
    }());
    networkcube.IDCompound = IDCompound;
    function cloneCompound(compound) {
        var result = new IDCompound();
        if (compound.nodeIds) {
            result.nodeIds = [];
            for (var i = 0; i < compound.nodeIds.length; i++) {
                result.nodeIds.push(compound.nodeIds[i]);
            }
        }
        if (compound.linkIds) {
            result.linkIds = [];
            for (var i = 0; i < compound.linkIds.length; i++) {
                result.linkIds.push(compound.linkIds[i]);
            }
        }
        if (compound.nodePairIds) {
            result.nodePairIds = [];
            for (var i = 0; i < compound.nodePairIds.length; i++) {
                result.nodePairIds.push(compound.nodePairIds[i]);
            }
        }
        if (compound.timeIds) {
            result.timeIds = [];
            for (var i = 0; i < compound.timeIds.length; i++) {
                result.timeIds.push(compound.timeIds[i]);
            }
        }
        return result;
    }
    networkcube.cloneCompound = cloneCompound;
    function makeIdCompound(elements) {
        var result = new IDCompound;
        if (elements != undefined) {
            if (elements.nodes) {
                result.nodeIds = elements.nodes.map(function (n, i) { return n.id(); });
            }
            if (elements.links) {
                result.linkIds = elements.links.map(function (n, i) { return n.id(); });
            }
            if (elements.times) {
                result.timeIds = elements.times.map(function (n, i) { return n.id(); });
            }
            if (elements.nodePairs) {
                result.nodePairIds = elements.nodePairs.map(function (n, i) { return n.id(); });
            }
        }
        return result;
    }
    networkcube.makeIdCompound = makeIdCompound;
    function makeElementCompound(elements, g) {
        var result = new ElementCompound;
        if (elements != undefined) {
            if (elements.nodeIds) {
                result.nodes = elements.nodeIds.map(function (id, i) { return g.node(id); });
            }
            if (elements.linkIds) {
                result.links = elements.linkIds.map(function (id, i) { return g.link(id); });
            }
            if (elements.timeIds) {
                result.times = elements.timeIds.map(function (id, i) { return g.time(id); });
            }
            if (elements.nodePairIds) {
                result.nodePairs = elements.nodePairIds.map(function (id, i) { return g.nodePair(id); });
            }
        }
        return result;
    }
    networkcube.makeElementCompound = makeElementCompound;
    function attributeSort(a, b, attributeName, asc) {
        var value = a.attr(attributeName);
        var result;
        if (typeof value == 'string') {
            result = a.attr(attributeName).localeCompare(b.attr(attributeName));
        }
        else if (typeof value == 'number') {
            result = b.attr(attributeName) - a.attr(attributeName);
        }
        else {
            result = 0;
        }
        if (asc == false) {
            result = -result;
        }
        return result;
    }
    networkcube.attributeSort = attributeSort;
    function formatAtGranularity(time, granualarity) {
        switch (granualarity) {
            case 0: return time.millisecond();
            case 1: return time.second();
            case 2: return time.minute();
            case 3: return time.hour();
            case 4: return time.day();
            case 5: return time.week();
            case 6: return time.month() + 1;
            case 7: return time.year();
        }
    }
    networkcube.formatAtGranularity = formatAtGranularity;
    function arraysEqual(a, b) {
        if (a === b)
            return true;
        if (a == null || b == null)
            return false;
        if (a.length != b.length)
            return false;
        for (var i = 0; i < a.length; ++i) {
            if (a[i] !== b[i])
                return false;
        }
        return true;
    }
    networkcube.arraysEqual = arraysEqual;
    function encapsulate(array, attrName) {
        if (attrName == undefined) {
            attrName = 'element';
        }
        var a = [];
        var o;
        for (var i = 0; i < array.length; i++) {
            o = {
                index: i,
            };
            o[attrName] = array[i];
            a.push(o);
        }
        return a;
    }
    networkcube.encapsulate = encapsulate;
    function isPointInPolyArray(poly, pt) {
        for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
            ((poly[i][1] <= pt[1] && pt[1] < poly[j][1]) || (poly[j][1] <= pt[1] && pt[1] < poly[i][1])) && (pt[0] < (poly[j][0] - poly[i][0]) * (pt[1] - poly[i][1]) / (poly[j][1] - poly[i][1]) + poly[i][0]) && (c = !c);
        return c;
    }
    networkcube.isPointInPolyArray = isPointInPolyArray;
    function formatTimeAtGranularity(time, granualarity) {
        var momentTime = moment(time.unixTime());
        switch (granualarity) {
            case 0: return momentTime.millisecond();
            case 1: return momentTime.second();
            case 2: return momentTime.minute();
            case 3: return momentTime.hour();
            case 4: return momentTime.day();
            case 5: return momentTime.week();
            case 6: return momentTime.month() + 1;
            default: return momentTime.year();
        }
    }
    networkcube.formatTimeAtGranularity = formatTimeAtGranularity;
    function downloadPNGFromCanvas(name) {
        var blob = getBlobFromCanvas(document.getElementsByTagName('canvas')[0]);
        var fileNameToSaveAs = name + '_' + new Date().toUTCString() + '.png';
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.href = window.webkitURL.createObjectURL(blob);
        downloadLink.click();
    }
    networkcube.downloadPNGFromCanvas = downloadPNGFromCanvas;
    function getBlobFromCanvas(canvas) {
        var dataURL = canvas.toDataURL("image/png");
        return dataURItoBlob(dataURL);
    }
    function downloadPNGfromSVG(name, svgId) {
        var blob = getBlobFromSVG(name, svgId, saveAs);
    }
    networkcube.downloadPNGfromSVG = downloadPNGfromSVG;
    function getBlobFromSVG(name, svgId, callback) {
        var width = $('#' + svgId).width();
        var height = $('#' + svgId).height();
        console.log('SVG SIZE: ' + width, height);
        getBlobFromSVGString(name, getSVGString(d3.select('#' + svgId).node()), width, height, callback);
    }
    networkcube.getBlobFromSVG = getBlobFromSVG;
    function getBlobFromSVGNode(name, svgNode, callback, backgroundColor) {
        var string = getSVGString(svgNode);
        var width = svgNode.getAttribute('width');
        var height = svgNode.getAttribute('height');
        if (width == null) {
            width = window.innerWidth + 1000;
        }
        if (height == null) {
            height = window.innerHeight + 1000;
        }
        getBlobFromSVGString(name, string, width, height, callback, backgroundColor);
    }
    networkcube.getBlobFromSVGNode = getBlobFromSVGNode;
    function getBlobFromSVGString(name, svgString, width, height, callback, backgroundColor) {
        console.log('width', width);
        console.log('height', height);
        var format = format ? format : 'png';
        var imgsrc = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));
        var canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        var context = canvas.getContext("2d");
        var image = new Image();
        image.src = imgsrc;
        console.log('image', image);
        image.onload = function () {
            context.clearRect(0, 0, width, height);
            if (backgroundColor) {
                context.fillStyle = backgroundColor;
                context.fillRect(0, 0, canvas.width, canvas.height);
            }
            context.drawImage(image, 0, 0, width, height);
            canvas.toBlob(function (blob) {
                console.log('BLOB', blob);
                callback(blob, name);
            });
        };
    }
    networkcube.getBlobFromSVGString = getBlobFromSVGString;
    function getSVGString(svgNode) {
        console.log('SVG NODE', svgNode);
        svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
        var cssStyleText = getCSSStyles(svgNode);
        appendCSS(cssStyleText, svgNode);
        var serializer = new XMLSerializer();
        var svgString = serializer.serializeToString(svgNode);
        svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink=');
        svgString = svgString.replace(/NS\d+:href/g, 'xlink:href');
        return svgString;
        function getCSSStyles(parentElement) {
            var selectorTextArr = [];
            selectorTextArr.push('#' + parentElement.id);
            for (var c = 0; c < parentElement.classList.length; c++)
                if (!contains('.' + parentElement.classList[c], selectorTextArr))
                    selectorTextArr.push('.' + parentElement.classList[c]);
            var nodes = parentElement.getElementsByTagName("*");
            for (var i = 0; i < nodes.length; i++) {
                var id = nodes[i].id;
                if (!contains('#' + id, selectorTextArr))
                    selectorTextArr.push('#' + id);
                var classes = nodes[i].classList;
                for (var c = 0; c < classes.length; c++)
                    if (!contains('.' + classes[c], selectorTextArr))
                        selectorTextArr.push('.' + classes[c]);
            }
            var extractedCSSText = "";
            for (var i = 0; i < document.styleSheets.length; i++) {
                var s = document.styleSheets[i];
                try {
                    if (!s.cssRules)
                        continue;
                }
                catch (e) {
                    if (e.name !== 'SecurityError')
                        throw e;
                    continue;
                }
                var cssRules = s.cssRules;
                for (var r = 0; r < cssRules.length; r++) {
                    if (contains(cssRules[r].selectorText, selectorTextArr))
                        extractedCSSText += cssRules[r].cssText;
                }
            }
            return extractedCSSText;
            function contains(str, arr) {
                return arr.indexOf(str) === -1 ? false : true;
            }
        }
        function appendCSS(cssText, element) {
            var styleElement = document.createElement("style");
            styleElement.setAttribute("type", "text/css");
            styleElement.innerHTML = cssText;
            var refNode = element.hasChildNodes() ? element.children[0] : null;
            element.insertBefore(styleElement, refNode);
        }
    }
    networkcube.getSVGString = getSVGString;
    function dataURItoBlob(dataURI) {
        var byteString;
        if (dataURI.split(',')[0].indexOf('base64') >= 0)
            byteString = atob(dataURI.split(',')[1]);
        else
            byteString = unescape(dataURI.split(',')[1]);
        var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
        console.log('mimeString', mimeString);
        var ia = new Uint8Array(byteString.length);
        for (var i = 0; i < byteString.length; i++) {
            ia[i] = byteString.charCodeAt(i);
        }
        return new Blob([ia], { type: mimeString });
    }
    var msgBox;
    function showMessage(message, timeout) {
        if ($('.messageBox'))
            $('.messageBox').remove();
        msgBox = $('<div id="div" class="messageBox" style="\
            width: 100%;\
            height: 100%;\
            background-color: #ffffff;\
            opacity: .9;\
            position: absolute;\
            top: 0px;\
            left: 0px;"></div>');
        msgBox.append('<div id="div" style="\
            font-size: 20pt;\
            font-weight: bold;\
            font-family: "Helvetica Neue", Helvetica, sans-serif;\
            width: 500px;\
            padding-top: 300px;\
            text-align: center;\
            margin:auto;">\
            <p>' + message + '</p></div>');
        $('body').append(msgBox);
        msgBox.click(function () {
            $('.messageBox').remove();
        });
        if (timeout) {
            window.setTimeout(function () {
                $('.messageBox').fadeOut(1000);
            }, timeout);
        }
    }
    networkcube.showMessage = showMessage;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    var BasicElement = (function () {
        function BasicElement(id, type, dynamicGraph) {
            this._id = id;
            this.type = type;
            this.g = dynamicGraph;
        }
        BasicElement.prototype.id = function () {
            return this._id;
        };
        BasicElement.prototype.attr = function (attr) {
            return this.g.attr(attr, this._id, this.type);
        };
        BasicElement.prototype.getSelections = function () {
            return this.g.attributeArrays[this.type].selections[this._id];
        };
        BasicElement.prototype.addToSelection = function (b) {
            this.g.attributeArrays[this.type].selections[this._id].push(b);
        };
        BasicElement.prototype.removeFromSelection = function (b) {
            var arr = this.g.attributeArrays[this.type].selections[this._id];
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] == b)
                    this.g.attributeArrays[this.type].selections[this._id].splice(i, 1);
            }
        };
        BasicElement.prototype.inSelection = function (s) {
            return this.getSelections().indexOf(s) > -1;
        };
        BasicElement.prototype.isSelected = function (selection) {
            if (!selection)
                return this.getSelections().length > 0;
            var selections = this.g.attributeArrays[this.type].selections[this._id];
            for (var i = 0; i < selections.length; i++) {
                if (selections[i] == this.g.defaultNodeSelection || selections[i] == this.g.defaultLinkSelection) {
                    continue;
                }
                if (selections[i] == selection)
                    return true;
            }
            return false;
        };
        BasicElement.prototype.isHighlighted = function () {
            return this.g.isHighlighted(this._id, this.type);
        };
        BasicElement.prototype.isFiltered = function () {
            return this.g.isFiltered(this._id, this.type);
        };
        BasicElement.prototype.isVisible = function () {
            var selections = this.getSelections();
            if (selections.length == 0)
                return true;
            for (var i = 0; i < selections.length; i++) {
                if (selections[i].filter)
                    return false;
            }
            return true;
        };
        BasicElement.prototype.presentIn = function (start, end) {
            var presence = this.attr('presence');
            if (!end)
                end = start;
            for (var i = start._id; i <= end._id; i++) {
                if (presence.indexOf(i) > -1)
                    return true;
            }
            return false;
        };
        return BasicElement;
    }());
    networkcube.BasicElement = BasicElement;
    var Time = (function (_super) {
        __extends(Time, _super);
        function Time(id, dynamicGraph) {
            return _super.call(this, id, 'time', dynamicGraph) || this;
        }
        Time.prototype.time = function () { return this.attr('momentTime'); };
        Time.prototype.moment = function () { return this.attr('momentTime'); };
        Time.prototype.label = function () { return this.attr('label'); };
        Time.prototype.unixTime = function () { return this.attr('unixTime'); };
        Time.prototype.links = function () {
            return new LinkQuery(this.attr('links'), this.g);
        };
        Time.prototype.year = function () { return this.time().year(); };
        Time.prototype.month = function () { return this.time().month(); };
        Time.prototype.week = function () { return this.time().week(); };
        Time.prototype.day = function () { return this.time().day(); };
        Time.prototype.hour = function () { return this.time().hour(); };
        Time.prototype.minute = function () { return this.time().minute(); };
        Time.prototype.second = function () { return this.time().second(); };
        Time.prototype.millisecond = function () { return this.time().millisecond(); };
        Time.prototype.format = function (format) {
            return this.time().format(format);
        };
        return Time;
    }(BasicElement));
    networkcube.Time = Time;
    var Node = (function (_super) {
        __extends(Node, _super);
        function Node(id, graph) {
            return _super.call(this, id, 'node', graph) || this;
        }
        Node.prototype.label = function () { return '' + this.attr('label'); };
        Node.prototype.nodeType = function () { return this.attr('nodeType'); };
        Node.prototype.neighbors = function (t1, t2) {
            if (t2 != undefined) {
                return new NodeQuery(this.attr('neighbors').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new NodeQuery(this.attr('neighbors').get(t1), this.g);
            }
            return new NodeQuery(this.attr('neighbors').toFlatArray(), this.g);
        };
        Node.prototype.inNeighbors = function (t1, t2) {
            if (t2 != undefined) {
                return new NodeQuery(this.attr('inNeighbors').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new NodeQuery(this.attr('inNeighbors').get(t1), this.g);
            }
            return new NodeQuery(this.attr('inNeighbors').toFlatArray(true), this.g);
        };
        Node.prototype.outNeighbors = function (t1, t2) {
            if (t2 != undefined) {
                return new NodeQuery(this.attr('outNeighbors').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new NodeQuery(this.attr('outNeighbors').get(t1), this.g);
            }
            return new NodeQuery(this.attr('outNeighbors').toFlatArray(), this.g);
        };
        Node.prototype.links = function (t1, t2) {
            if (t2 != undefined) {
                return new LinkQuery(this.attr('links').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new LinkQuery(this.attr('links').get(t1), this.g);
            }
            return new LinkQuery(this.attr('links').toFlatArray(true), this.g);
        };
        Node.prototype.inLinks = function (t1, t2) {
            if (t2 != undefined) {
                return new LinkQuery(this.attr('inLinks').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new LinkQuery(this.attr('inLinks').get(t1), this.g);
            }
            return new LinkQuery(this.attr('inLinks').toFlatArray(true), this.g);
        };
        Node.prototype.outLinks = function (t1, t2) {
            if (t2 != undefined) {
                return new LinkQuery(this.attr('outLinks').period(t1, t2).toFlatArray(true), this.g);
            }
            if (t1 != undefined) {
                return new LinkQuery(this.attr('outLinks').get(t1), this.g);
            }
            return new LinkQuery(this.attr('outLinks').toFlatArray(true), this.g);
        };
        Node.prototype.locations = function (t1, t2) {
            if (t2 != undefined) {
                return new LocationQuery(this.attr('locations').period(t1, t2).toArray(), this.g);
            }
            if (t1 != undefined) {
                return new LocationQuery([this.attr('locations').get(t1)], this.g);
            }
            return new LocationQuery(this.attr('locations').toArray(), this.g);
        };
        Node.prototype.locationSerie = function (t1, t2) {
            var serie;
            if (t2 != undefined)
                serie = this.attr('locations').period(t1, t2);
            else if (t1 != undefined)
                serie = this.attr('locations').get(t1);
            else
                serie = this.attr('locations');
            serie = serie.serie;
            var serie2 = new ScalarTimeSeries();
            for (var t in serie) {
                serie2.set(this.g.time(parseInt(t)), this.g.location(serie[t]));
            }
            return serie2;
        };
        Node.prototype.linksBetween = function (n) {
            var links = this.links().toArray();
            var finalLinks = [];
            var l;
            for (var i = 0; i < links.length; i++) {
                l = links[i];
                if (l.source == n || l.target == n)
                    finalLinks.push(l);
            }
            return new LinkQuery(finalLinks, this.g);
        };
        return Node;
    }(BasicElement));
    networkcube.Node = Node;
    var Link = (function (_super) {
        __extends(Link, _super);
        function Link(id, graph) {
            return _super.call(this, id, 'link', graph) || this;
        }
        Link.prototype.linkType = function () { return this.attr('linkType'); };
        Object.defineProperty(Link.prototype, "source", {
            get: function () { return this.g._nodes[this.attr('source')]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Link.prototype, "target", {
            get: function () { return this.g._nodes[this.attr('target')]; },
            enumerable: true,
            configurable: true
        });
        Link.prototype.nodePair = function () { return this.g._nodePairs[this.attr('nodePair')]; };
        Link.prototype.directed = function () { return this.attr('directed'); };
        Link.prototype.other = function (n) {
            return this.source == n ? this.target : this.source;
        };
        Link.prototype.weights = function (start, end) {
            if (start == undefined)
                return new NumberQuery(this.attr('weights').toArray());
            if (end == undefined)
                return new NumberQuery([this.attr('weights').get(start)]);
            return new NumberQuery(this.attr('weights').period(start, end).toArray());
        };
        Link.prototype.presentIn = function (start, end) {
            var presence = this.weights(start, end).toArray();
            return presence.length > 0;
        };
        Link.prototype.times = function () {
            return new TimeQuery(this.attr('presence'), this.g);
        };
        return Link;
    }(BasicElement));
    networkcube.Link = Link;
    var NodePair = (function (_super) {
        __extends(NodePair, _super);
        function NodePair(id, graph) {
            return _super.call(this, id, 'nodePair', graph) || this;
        }
        Object.defineProperty(NodePair.prototype, "source", {
            get: function () { return this.g._nodes[this.attr('source')]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodePair.prototype, "target", {
            get: function () { return this.g._nodes[this.attr('target')]; },
            enumerable: true,
            configurable: true
        });
        NodePair.prototype.links = function () { return new LinkQuery(this.attr('links'), this.g); };
        NodePair.prototype.nodeType = function () { return this.attr('nodeType'); };
        NodePair.prototype.presentIn = function (start, end) {
            for (var i = 0; i < this.links.length; i++) {
                if (this.links[i].presentIn(start, end))
                    return true;
            }
            return false;
        };
        return NodePair;
    }(BasicElement));
    networkcube.NodePair = NodePair;
    var Location = (function (_super) {
        __extends(Location, _super);
        function Location(id, graph) {
            return _super.call(this, id, 'location', graph) || this;
        }
        Location.prototype.label = function () { return this.attr('label') + ''; };
        Location.prototype.longitude = function () { return this.attr('longitude'); };
        Location.prototype.latitude = function () { return this.attr('latitude'); };
        Location.prototype.x = function () { return this.attr('x'); };
        Location.prototype.y = function () { return this.attr('y'); };
        Location.prototype.z = function () { return this.attr('z'); };
        Location.prototype.radius = function () { return this.attr('radius'); };
        return Location;
    }(BasicElement));
    networkcube.Location = Location;
    var ScalarTimeSeries = (function () {
        function ScalarTimeSeries() {
            this.serie = {};
        }
        ScalarTimeSeries.prototype.period = function (t1, t2) {
            var t1id = t1.id();
            var t2id = t2.id();
            var s = new ScalarTimeSeries();
            for (var prop in this.serie) {
                if (parseInt(prop) >= t1id
                    && parseInt(prop) <= t2id) {
                    s.serie[prop] = this.serie[prop];
                }
            }
            return s;
        };
        ScalarTimeSeries.prototype.set = function (t, element) {
            this.serie[t.id()] = element;
        };
        ScalarTimeSeries.prototype.get = function (t) {
            if (this.serie[t.id()] == undefined)
                return;
            return this.serie[t.id()];
        };
        ScalarTimeSeries.prototype.size = function () {
            return this.toArray().length;
        };
        ScalarTimeSeries.prototype.toArray = function (removeDuplicates) {
            if (removeDuplicates == undefined)
                removeDuplicates = false;
            var a = [];
            if (removeDuplicates) {
                for (var prop in this.serie) {
                    a.push(this.serie[prop]);
                }
            }
            else {
                for (var prop in this.serie) {
                    if (a.indexOf(this.serie[prop]) == -1)
                        a.push(this.serie[prop]);
                }
            }
            return a;
        };
        return ScalarTimeSeries;
    }());
    networkcube.ScalarTimeSeries = ScalarTimeSeries;
    var ArrayTimeSeries = (function () {
        function ArrayTimeSeries() {
            this.serie = {};
        }
        ArrayTimeSeries.prototype.period = function (t1, t2) {
            var t1id = t1.id();
            var t2id = t1.id();
            var s = new ArrayTimeSeries();
            for (var prop in this.serie) {
                if (parseInt(prop) >= t1id
                    && parseInt(prop) <= t1id) {
                    s.serie[prop] = this.serie[prop];
                }
            }
            return s;
        };
        ArrayTimeSeries.prototype.add = function (t, element) {
            if (t == undefined) {
                return;
            }
            if (!this.serie[t._id])
                this.serie[t._id] = [];
            this.serie[t._id].push(element);
        };
        ArrayTimeSeries.prototype.get = function (t) {
            return this.serie[t._id];
        };
        ArrayTimeSeries.prototype.toArray = function () {
            var a = [];
            for (var prop in this.serie) {
                a.push(this.serie[prop]);
            }
            return a;
        };
        ArrayTimeSeries.prototype.toFlatArray = function (removeDuplicates) {
            if (removeDuplicates == undefined)
                removeDuplicates = false;
            var a = [];
            for (var prop in this.serie) {
                for (var i = 0; i < this.serie[prop].length; i++) {
                    if (!removeDuplicates || (removeDuplicates && a.indexOf(this.serie[prop]) == -1)) {
                        a.push(this.serie[prop][i]);
                    }
                }
            }
            return a;
        };
        return ArrayTimeSeries;
    }());
    networkcube.ArrayTimeSeries = ArrayTimeSeries;
    var Query = (function () {
        function Query(elements) {
            this._elements = [];
            if (elements) {
                for (var i = 0; i < elements.length; i++) {
                    if (elements[i] != undefined)
                        this._elements.push(elements[i]);
                }
            }
        }
        Query.prototype.contains = function (element) {
            return this._elements.indexOf(element) > -1;
        };
        Query.prototype.addUnique = function (element) {
            if (this._elements.indexOf(element) == -1)
                this._elements.push(element);
        };
        Query.prototype.add = function (element) {
            this._elements.push(element);
        };
        Query.prototype.addAll = function (elements) {
            for (var i = 0; i < elements.length; i++) {
                if (elements[i] != undefined)
                    this._elements.push(elements[i]);
            }
        };
        Query.prototype.addAllUnique = function (elements) {
            for (var i = 0; i < elements.length; i++) {
                this.addUnique(elements[i]);
            }
        };
        Object.defineProperty(Query.prototype, "length", {
            get: function () {
                return this._elements.length;
            },
            enumerable: true,
            configurable: true
        });
        ;
        Query.prototype.size = function () { return this._elements.length; };
        ;
        Query.prototype.ids = function () {
            return this._elements;
        };
        Query.prototype.removeDuplicates = function () {
            var elements = this._elements.slice(0);
            this._elements = [];
            for (var i = 0; i < elements.length; i++) {
                if (this._elements.indexOf(elements[i]) == -1)
                    this._elements.push(elements[i]);
            }
            return this;
        };
        Query.prototype.generic_intersection = function (q) {
            var intersection = [];
            for (var i = 0; i < this._elements.length; i++) {
                for (var j = 0; j < q._elements.length; j++) {
                    if (this._elements[i] == q._elements[j]) {
                        intersection.push(this._elements[i]);
                    }
                }
            }
            return new Query(intersection);
        };
        return Query;
    }());
    networkcube.Query = Query;
    var NumberQuery = (function (_super) {
        __extends(NumberQuery, _super);
        function NumberQuery() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        NumberQuery.prototype.clone = function () {
            return this._elements.slice(0);
        };
        NumberQuery.prototype.min = function () {
            var min = this._elements[0];
            for (var i = 1; i < this._elements.length; i++) {
                if (this._elements[i] != undefined)
                    min = Math.min(min, this._elements[i]);
            }
            return min;
        };
        NumberQuery.prototype.max = function () {
            var max = this._elements[0];
            for (var i = 1; i < this._elements.length; i++) {
                if (this._elements[i] != undefined)
                    max = Math.max(max, this._elements[i]);
            }
            return max;
        };
        NumberQuery.prototype.mean = function () {
            var v = 0;
            var count = 0;
            for (var i = 0; i < this._elements.length; i++) {
                if (typeof this._elements[i] == 'number') {
                    v += this._elements[i];
                    count++;
                }
            }
            return v / count;
        };
        NumberQuery.prototype.sum = function () {
            var sum = 0;
            for (var i = 0; i < this._elements.length; i++) {
                if (typeof this._elements[i] == 'number') {
                    sum += this._elements[i];
                }
            }
            return sum;
        };
        NumberQuery.prototype.toArray = function () {
            return this._elements.slice(0);
        };
        NumberQuery.prototype.get = function (index) {
            return this._elements[index];
        };
        NumberQuery.prototype.forEach = function (f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this._elements[i], i);
            }
            return this;
        };
        return NumberQuery;
    }(Query));
    networkcube.NumberQuery = NumberQuery;
    var StringQuery = (function () {
        function StringQuery(elements) {
            if (elements)
                this._elements = elements.slice(0);
        }
        StringQuery.prototype.contains = function (element) {
            return this._elements.indexOf(element) > -1;
        };
        StringQuery.prototype.addUnique = function (element) {
            if (this._elements.indexOf(element) == -1)
                this._elements.push(element);
        };
        StringQuery.prototype.add = function (element) {
            this._elements.push(element);
        };
        StringQuery.prototype.addAll = function (elements) {
            for (var i = 0; i < elements.length; i++) {
                if (elements[i] != undefined)
                    this._elements.push(elements[i]);
            }
        };
        StringQuery.prototype.addAllUnique = function (elements) {
            for (var i = 0; i < elements.length; i++) {
                this.addUnique(elements[i]);
            }
        };
        Object.defineProperty(StringQuery.prototype, "length", {
            get: function () { return this._elements.length; },
            enumerable: true,
            configurable: true
        });
        ;
        StringQuery.prototype.size = function () { return this._elements.length; };
        ;
        StringQuery.prototype.toArray = function () {
            return this._elements.slice(0);
        };
        StringQuery.prototype.forEach = function (f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this._elements[i], i);
            }
            return this;
        };
        return StringQuery;
    }());
    networkcube.StringQuery = StringQuery;
    var GraphElementQuery = (function (_super) {
        __extends(GraphElementQuery, _super);
        function GraphElementQuery(elements, g) {
            var _this = _super.call(this, elements) || this;
            _this.elementType = '';
            _this.g = g;
            return _this;
        }
        GraphElementQuery.prototype.generic_filter = function (filter) {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                try {
                    if (filter(this.g.get(this.elementType, this._elements[i]))) {
                        arr.push(this._elements[i]);
                    }
                }
                catch (ex) {
                }
            }
            return arr;
        };
        GraphElementQuery.prototype.generic_selected = function () {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                if (this.g.get(this.elementType, this._elements[i]).isSelected()) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        };
        GraphElementQuery.prototype.generic_visible = function () {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                if (this.g.get(this.elementType, this._elements[i]).isVisible()) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        };
        GraphElementQuery.prototype.generic_highlighted = function () {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                if (this.g.get(this.elementType, this._elements[i]).isHighlighted()) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        };
        GraphElementQuery.prototype.generic_presentIn = function (start, end) {
            var arr = [];
            for (var i = 0; i < this._elements.length; i++) {
                if (this.g.get(this.elementType, this._elements[i]).presentIn(start, end)) {
                    arr.push(this._elements[i]);
                }
            }
            return arr;
        };
        GraphElementQuery.prototype.generic_sort = function (attrName, asc) {
            var _this = this;
            if (this._elements.length == 0) {
                return this;
            }
            var array = this._elements.slice(0);
            array.sort(function (e1, e2) {
                return networkcube.attributeSort(_this.g.get(_this.elementType, e1), _this.g.get(_this.elementType, e2), attrName, asc);
            });
            this._elements = array;
            return this;
        };
        GraphElementQuery.prototype.generic_removeDuplicates = function () {
            var uniqueElements = [];
            for (var i = 0; i < this._elements.length; i++) {
                if (uniqueElements.indexOf(this._elements[i]) == -1)
                    uniqueElements.push(this._elements[i]);
            }
            this._elements = uniqueElements;
            return this;
        };
        return GraphElementQuery;
    }(Query));
    networkcube.GraphElementQuery = GraphElementQuery;
    var NodeQuery = (function (_super) {
        __extends(NodeQuery, _super);
        function NodeQuery(elements, g) {
            var _this = _super.call(this, elements, g) || this;
            _this.elementType = 'node';
            if (elements.length > 0 && elements[0] instanceof networkcube.Node) {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i].id());
                }
            }
            else if (elements.length > 0 && typeof elements[0] == 'number') {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i]);
                }
            }
            _this.elementType = 'node';
            return _this;
        }
        NodeQuery.prototype.contains = function (n) {
            return this._elements.indexOf(n.id()) > -1;
        };
        NodeQuery.prototype.highlighted = function () {
            return new NodeQuery(_super.prototype.generic_highlighted.call(this), this.g);
        };
        NodeQuery.prototype.visible = function () {
            return new NodeQuery(_super.prototype.generic_visible.call(this), this.g);
        };
        NodeQuery.prototype.selected = function () {
            return new NodeQuery(_super.prototype.generic_selected.call(this), this.g);
        };
        NodeQuery.prototype.filter = function (filter) {
            return new NodeQuery(_super.prototype.generic_filter.call(this, filter), this.g);
        };
        NodeQuery.prototype.presentIn = function (t1, t2) {
            return new NodeQuery(_super.prototype.generic_presentIn.call(this, t1, t2), this.g);
        };
        NodeQuery.prototype.sort = function (attributeName, asc) {
            return _super.prototype.generic_sort.call(this, attributeName, asc);
        };
        NodeQuery.prototype.label = function () {
            var q = new StringQuery();
            for (var i = 0; i < this._elements.length; i++) {
                q.add('' + this.g.attr('label', this._elements[i], 'node'));
            }
            return q;
        };
        NodeQuery.prototype.neighbors = function (t1, t2) {
            return new NodeQuery(getBulkAttributes('neighbors', this._elements, 'node', this.g, t1, t2), this.g);
        };
        NodeQuery.prototype.links = function (t1, t2) {
            return new LinkQuery(getBulkAttributes('links', this._elements, 'node', this.g, t1, t2), this.g);
        };
        NodeQuery.prototype.locations = function (t1, t2) {
            return new LocationQuery(getBulkAttributes('locations', this._elements, 'node', this.g, t1, t2), this.g);
        };
        NodeQuery.prototype.nodeTypes = function () {
            var q = new StringQuery();
            for (var i = 0; i < this._elements.length; i++) {
                q.add(this.g.attr('nodeType', this._elements[i], 'node'));
            }
            return q;
        };
        NodeQuery.prototype.get = function (i) { return this.g._nodes[this._elements[i]]; };
        NodeQuery.prototype.last = function () { return this.g._nodes[this._elements[this._elements.length - 1]]; };
        NodeQuery.prototype.toArray = function () {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._nodes[this._elements[i]]);
            }
            return a;
        };
        NodeQuery.prototype.createAttribute = function (attrName, f) {
            if (this.g.nodeArrays[attrName] == undefined) {
                this.g.nodeArrays[attrName] = [];
                for (var i = 0; i < this.g._nodes.length; i++) {
                    this.g.nodeArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.nodeArrays[attrName][this._elements[i]] = f(this.g._nodes[this._elements[i]]);
            }
            return this;
        };
        NodeQuery.prototype.intersection = function (q) {
            return new NodeQuery(this.generic_intersection(q)._elements, this.g);
        };
        NodeQuery.prototype.removeDuplicates = function () {
            return new NodeQuery(this.generic_removeDuplicates()._elements, this.g);
        };
        NodeQuery.prototype.forEach = function (f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.node(this._elements[i]), i);
            }
            return this;
        };
        return NodeQuery;
    }(GraphElementQuery));
    networkcube.NodeQuery = NodeQuery;
    var LinkQuery = (function (_super) {
        __extends(LinkQuery, _super);
        function LinkQuery(elements, g) {
            var _this = _super.call(this, elements, g) || this;
            _this.elementType = 'link';
            if (elements.length > 0 && elements[0] instanceof networkcube.Link) {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i].id());
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i]);
                }
            }
            return _this;
        }
        LinkQuery.prototype.contains = function (l) {
            return this._elements.indexOf(l.id()) > -1;
        };
        LinkQuery.prototype.highlighted = function () {
            return new LinkQuery(_super.prototype.generic_highlighted.call(this), this.g);
        };
        LinkQuery.prototype.visible = function () {
            return new LinkQuery(_super.prototype.generic_visible.call(this), this.g);
        };
        LinkQuery.prototype.selected = function () {
            return new LinkQuery(_super.prototype.generic_selected.call(this), this.g);
        };
        LinkQuery.prototype.filter = function (filter) {
            return new LinkQuery(_super.prototype.generic_filter.call(this, filter), this.g);
        };
        LinkQuery.prototype.presentIn = function (t1, t2) {
            return new LinkQuery(_super.prototype.generic_presentIn.call(this, t1, t2), this.g);
        };
        LinkQuery.prototype.sort = function (attributeName) {
            return _super.prototype.generic_sort.call(this, attributeName);
        };
        LinkQuery.prototype.get = function (i) { return this.g._links[this._elements[i]]; };
        LinkQuery.prototype.last = function () { return this.g._links[this._elements[this._elements.length - 1]]; };
        LinkQuery.prototype.toArray = function () {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._links[this._elements[i]]);
            }
            return a;
        };
        LinkQuery.prototype.weights = function (start, end) {
            var s = new NumberQuery();
            for (var i = 0; i < this._elements.length; i++) {
                s.addAll(this.g.link(i).weights(start, end).toArray());
            }
            return s;
        };
        LinkQuery.prototype.createAttribute = function (attrName, f) {
            if (this.g.linkArrays[attrName] == undefined) {
                this.g.linkArrays[attrName] = [];
                for (var i = 0; i < this.g._links.length; i++) {
                    this.g.linkArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.linkArrays[attrName][this._elements[i]] = f(this.g._links[this._elements[i]]);
            }
            return this;
        };
        LinkQuery.prototype.linkTypes = function () {
            var linkTypes = [];
            var s;
            for (var i = 0; i < this._elements.length; i++) {
                s = this.g.link(this._elements[i]).linkType();
                if (linkTypes.indexOf(s) == -1)
                    linkTypes.push(s);
            }
            return linkTypes;
        };
        LinkQuery.prototype.sources = function () {
            var nodes = [];
            var link;
            for (var i = 0; i < this._elements.length; i++) {
                link = this.g.link(this._elements[i]);
                if (nodes.indexOf(link.source) == -1)
                    nodes.push(link.source.id());
            }
            return new NodeQuery(nodes, this.g);
        };
        LinkQuery.prototype.targets = function () {
            var nodes = [];
            var link;
            for (var i = 0; i < this._elements.length; i++) {
                link = this.g.link(this._elements[i]);
                if (nodes.indexOf(link.target) == -1)
                    nodes.push(link.target.id());
            }
            return new NodeQuery(nodes, this.g);
        };
        LinkQuery.prototype.intersection = function (q) {
            return new LinkQuery(this.generic_intersection(q)._elements, this.g);
        };
        LinkQuery.prototype.removeDuplicates = function () {
            return new LinkQuery(this.generic_removeDuplicates()._elements, this.g);
        };
        LinkQuery.prototype.forEach = function (f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.link(this._elements[i]), i);
            }
            return this;
        };
        return LinkQuery;
    }(GraphElementQuery));
    networkcube.LinkQuery = LinkQuery;
    var NodePairQuery = (function (_super) {
        __extends(NodePairQuery, _super);
        function NodePairQuery(elements, g) {
            var _this = _super.call(this, elements, g) || this;
            _this.elementType = 'nodePair';
            _this.elementType = 'nodePair';
            if (elements.length > 0 && elements[0] instanceof networkcube.NodePair) {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i].id());
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i]);
                }
            }
            return _this;
        }
        NodePairQuery.prototype.contains = function (n) {
            return this._elements.indexOf(n.id()) > -1;
        };
        NodePairQuery.prototype.highlighted = function () {
            return new NodePairQuery(_super.prototype.generic_highlighted.call(this), this.g);
        };
        NodePairQuery.prototype.visible = function () {
            return new NodePairQuery(_super.prototype.generic_visible.call(this), this.g);
        };
        NodePairQuery.prototype.selected = function () {
            return new NodePairQuery(_super.prototype.generic_selected.call(this), this.g);
        };
        NodePairQuery.prototype.filter = function (filter) {
            return new NodePairQuery(_super.prototype.generic_filter.call(this, filter), this.g);
        };
        NodePairQuery.prototype.presentIn = function (t1, t2) {
            return new NodePairQuery(_super.prototype.generic_presentIn.call(this, t1, t2), this.g);
        };
        NodePairQuery.prototype.sort = function (attributeName) {
            return _super.prototype.generic_sort.call(this, attributeName);
        };
        NodePairQuery.prototype.get = function (i) { return this.g._nodePairs[this._elements[i]]; };
        NodePairQuery.prototype.last = function () { return this.g._links[this._elements[this._elements.length - 1]]; };
        NodePairQuery.prototype.toArray = function () {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._nodePairs[this._elements[i]]);
            }
            return a;
        };
        NodePairQuery.prototype.createAttribute = function (attrName, f) {
            if (this.g.nodePairArrays[attrName] == undefined) {
                this.g.nodePairArrays[attrName] = [];
                for (var i = 0; i < this.g._nodePairs.length; i++) {
                    this.g.nodePairArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.nodePairArrays[attrName][this._elements[i]] = f(this.g._nodePairs[this._elements[i]]);
            }
            return this;
        };
        NodePairQuery.prototype.intersection = function (q) {
            return new NodePairQuery(this.generic_intersection(q)._elements, this.g);
        };
        NodePairQuery.prototype.removeDuplicates = function () {
            return new NodePairQuery(this.generic_removeDuplicates()._elements, this.g);
        };
        NodePairQuery.prototype.forEach = function (f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.nodePair(this._elements[i]), i);
            }
            return this;
        };
        return NodePairQuery;
    }(GraphElementQuery));
    networkcube.NodePairQuery = NodePairQuery;
    var TimeQuery = (function (_super) {
        __extends(TimeQuery, _super);
        function TimeQuery(elements, g) {
            var _this = _super.call(this, elements, g) || this;
            _this.elementType = 'time';
            _this.elementType = 'time';
            if (elements.length > 0 && elements[0] instanceof networkcube.Time) {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i].id());
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i]);
                }
            }
            return _this;
        }
        TimeQuery.prototype.contains = function (t) {
            return this._elements.indexOf(t.id()) > -1;
        };
        TimeQuery.prototype.highlighted = function () {
            return new TimeQuery(_super.prototype.generic_highlighted.call(this), this.g);
        };
        TimeQuery.prototype.visible = function () {
            return new TimeQuery(_super.prototype.generic_visible.call(this), this.g);
        };
        TimeQuery.prototype.selected = function () {
            return new TimeQuery(_super.prototype.generic_selected.call(this), this.g);
        };
        TimeQuery.prototype.filter = function (filter) {
            return new TimeQuery(_super.prototype.generic_filter.call(this, filter), this.g);
        };
        TimeQuery.prototype.presentIn = function (t1, t2) {
            return new TimeQuery(_super.prototype.generic_presentIn.call(this, t1, t2), this.g);
        };
        TimeQuery.prototype.sort = function (attributeName) {
            return _super.prototype.generic_sort.call(this, attributeName);
        };
        TimeQuery.prototype.links = function () {
            var links = [];
            for (var i = 0; i < this._elements.length; i++) {
                links = links.concat(this.g.attr('links', this._elements[i], 'time'));
            }
            return new LinkQuery(links, this.g);
        };
        TimeQuery.prototype.get = function (i) { return this.g._times[this._elements[i]]; };
        TimeQuery.prototype.last = function () { return this.g._times[this._elements[this._elements.length - 1]]; };
        TimeQuery.prototype.toArray = function () {
            var a = [];
            var allTimes = this.g._times;
            for (var i = 0; i < this._elements.length; i++) {
                a.push(allTimes[this._elements[i]]);
            }
            return a;
        };
        TimeQuery.prototype.createAttribute = function (attrName, f) {
            if (this.g.timeArrays[attrName] == undefined) {
                this.g.timeArrays[attrName] = [];
                for (var i = 0; i < this.g._times.length; i++) {
                    this.g.timeArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.timeArrays[attrName][this._elements[i]] = f(this.g._times[this._elements[i]]);
            }
            return this;
        };
        TimeQuery.prototype.unixTimes = function () {
            var unixTimes = [];
            for (var i = 0; i < this._elements.length; i++) {
                unixTimes.push(this.g.time(this._elements[i]).unixTime());
            }
            return unixTimes;
        };
        TimeQuery.prototype.intersection = function (q) {
            return new TimeQuery(this.generic_intersection(q)._elements, this.g);
        };
        TimeQuery.prototype.forEach = function (f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.time(this._elements[i]), i);
            }
            return this;
        };
        return TimeQuery;
    }(GraphElementQuery));
    networkcube.TimeQuery = TimeQuery;
    var LocationQuery = (function (_super) {
        __extends(LocationQuery, _super);
        function LocationQuery(elements, g) {
            var _this = _super.call(this, elements, g) || this;
            _this.elementType = 'location';
            _this.elementType = 'location';
            if (elements.length > 0 && elements[0] instanceof networkcube.Location) {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements = elements[i].id();
                }
            }
            if (elements.length > 0 && typeof elements[0] == 'number') {
                _this._elements = [];
                for (var i = 0; i < elements.length; i++) {
                    _this._elements.push(elements[i]);
                }
            }
            return _this;
        }
        LocationQuery.prototype.contains = function (l) {
            return this._elements.indexOf(l.id()) > -1;
        };
        LocationQuery.prototype.highlighted = function () {
            return new LocationQuery(_super.prototype.generic_highlighted.call(this), this.g);
        };
        LocationQuery.prototype.visible = function () {
            return new LocationQuery(_super.prototype.generic_visible.call(this), this.g);
        };
        LocationQuery.prototype.selected = function () {
            return new LocationQuery(_super.prototype.generic_selected.call(this), this.g);
        };
        LocationQuery.prototype.filter = function (filter) {
            return new LocationQuery(_super.prototype.generic_filter.call(this, filter), this.g);
        };
        LocationQuery.prototype.presentIn = function (t1, t2) {
            return new LocationQuery(_super.prototype.generic_presentIn.call(this, t1, t2), this.g);
        };
        LocationQuery.prototype.sort = function (attributeName) {
            return _super.prototype.generic_sort.call(this, attributeName);
        };
        LocationQuery.prototype.get = function (i) { return this.g._locations[this._elements[i]]; };
        LocationQuery.prototype.last = function () { return this.g._locations[this._elements[this._elements.length - 1]]; };
        LocationQuery.prototype.toArray = function () {
            var a = [];
            for (var i = 0; i < this._elements.length; i++) {
                a.push(this.g._locations[this._elements[i]]);
            }
            return a;
        };
        LocationQuery.prototype.createAttribute = function (attrName, f) {
            if (this.g.locationArrays[attrName] == undefined) {
                this.g.locationArrays[attrName] = [];
                for (var i = 0; i < this.g._locations.length; i++) {
                    this.g.locationArrays[attrName].push();
                }
            }
            for (var i = 0; i < this._elements.length; i++) {
                this.g.locationArrays[attrName][this._elements[i]] = f(this.g._locations[this._elements[i]]);
            }
            return this;
        };
        LocationQuery.prototype.intersection = function (q) {
            return new LocationQuery(this.generic_intersection(q)._elements, this.g);
        };
        LocationQuery.prototype.removeDuplicates = function () {
            return new LocationQuery(this.generic_removeDuplicates()._elements, this.g);
        };
        LocationQuery.prototype.forEach = function (f) {
            for (var i = 0; i < this._elements.length; i++) {
                f(this.g.location(this._elements[i]), i);
            }
            return this;
        };
        return LocationQuery;
    }(GraphElementQuery));
    networkcube.LocationQuery = LocationQuery;
    function getBulkAttributes(attrName, ids, type, g, t1, t2) {
        var a = [];
        var temp;
        for (var i = 0; i < ids.length; i++) {
            if (t2 != undefined) {
                temp = g.attr(attrName, ids[i], type).period(t1, t2).toArray();
            }
            else if (t1 != undefined) {
                temp = [g.attr(attrName, ids[i], type).get(t1)];
            }
            else {
                temp = g.attr(attrName, ids[i], type).toArray();
            }
            for (var j = 0; j < temp.length; j++) {
                if (temp[j] instanceof Array) {
                    a = a.concat(temp[j]);
                }
                else {
                    if (a.indexOf(temp[j]) == -1)
                        a.push(temp[j]);
                }
            }
        }
        return a;
    }
    var Motif = (function () {
        function Motif(nodes, links) {
            this.nodes = [];
            this.links = [];
            this.times = [];
            this.nodes = nodes.slice(0);
            this.links = links.slice(0);
        }
        Motif.prototype.print = function () {
            console.log('nodes:', this.nodes.length, 'links:', this.links.length);
        };
        return Motif;
    }());
    networkcube.Motif = Motif;
    var MotifTemplate = (function () {
        function MotifTemplate(nodes, links) {
            this.nodes = [];
            this.links = [];
            this.nodes = nodes.slice(0);
            this.links = links.slice(0);
        }
        return MotifTemplate;
    }());
    networkcube.MotifTemplate = MotifTemplate;
    var MotifSequence = (function () {
        function MotifSequence() {
            this.motifs = [];
        }
        MotifSequence.prototype.push = function (m) {
            this.motifs.push(m);
        };
        return MotifSequence;
    }());
    networkcube.MotifSequence = MotifSequence;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    networkcube.GRANULARITY = ['millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'year', 'decade', 'century', 'millenium'];
    networkcube.DGRAPH_SUB = "[*dgraph*]";
    networkcube.DGRAPH_SER_VERBOSE_LOGGING = false;
    function dgraphReviver(dgraph, key, value) {
        if (value == networkcube.DGRAPH_SUB)
            return dgraph;
        else
            return value;
    }
    networkcube.dgraphReviver = dgraphReviver;
    function dgraphReplacer(key, value) {
        if (networkcube.DGRAPH_SER_VERBOSE_LOGGING) {
            console.log("dgraphReplacer", key, value);
        }
        if (value instanceof DynamicGraph) {
            console.log("dgraphReplacer found a DynamicGraph property", key);
            return networkcube.DGRAPH_SUB;
        }
        return value;
    }
    networkcube.dgraphReplacer = dgraphReplacer;
    var DynamicGraph = (function () {
        function DynamicGraph() {
            this.BOOKMARK_COLORS = d3.scale.category10();
            this.selectionColor_pointer = 0;
            this.minWeight = 10000000;
            this.maxWeight = -10000000;
            this._nodes = [];
            this._links = [];
            this._nodePairs = [];
            this._locations = [];
            this._times = [];
            this.timeObjects = [];
            this.matrix = [];
            this.nodeArrays = new NodeArray();
            this.linkArrays = new LinkArray();
            this.nodePairArrays = new NodePairArray();
            this.timeArrays = new TimeArray();
            this.linkTypeArrays = new LinkTypeArray();
            this.nodeTypeArrays = new NodeTypeArray();
            this.locationArrays = new LocationArray();
            this.attributeArrays = {
                node: this.nodeArrays,
                link: this.linkArrays,
                time: this.timeArrays,
                nodePair: this.nodePairArrays,
                linkType: this.linkTypeArrays,
                nodeType: this.nodeTypeArrays,
                location: this.locationArrays
            };
            this.highlightArrays = new networkcube.IDCompound();
            this.currentSelection_id = 0;
            this.selections = [];
            this.gran_min_NAME = "gran_min";
            this.gran_max_NAME = "gran_max_NAME";
            this.minWeight_NAME = "minWeight_NAME";
            this.maxWeight_NAME = "maxWeight_NAME";
            this.matrix_NAME = "matrix_NAME";
            this.nodeArrays_NAME = "nodeArrays_NAME";
            this.linkArrays_NAME = "linkArrays_NAME";
            this.nodePairArrays_NAME = "nodePairArrays_NAME";
            this.timeArrays_NAME = "timeArrays_NAME";
            this.linkTypeArrays_NAME = "linkTypeArrays_NAME";
            this.nodeTypeArrays_NAME = "nodeTypeArrays_NAME";
            this.locationArrays_NAME = "locationArrays_NAME";
        }
        DynamicGraph.prototype.attr = function (field, id, type) {
            var r;
            try {
                r = this.attributeArrays[type][field][id];
            }
            catch (e) {
                r = undefined;
            }
            return r;
        };
        DynamicGraph.prototype.standardArrayReplacer = function (key, value) {
            if (value instanceof DynamicGraph) {
                console.log("standardReplacer found a DynamicGraph property", key);
                return networkcube.DGRAPH_SUB;
            }
            else if (key == 'selections')
                return undefined;
            return value;
        };
        DynamicGraph.timeReviver = function (k, v, s) {
            if (k == '') {
                return networkcube.copyPropsShallow(v, new networkcube.Time(v.id, s));
            }
            else {
                return dgraphReviver(s, k, v);
            }
        };
        DynamicGraph.nodeArrayReviver = function (k, v, s) {
            switch (k) {
                case '':
                    return networkcube.copyPropsShallow(v, new NodeArray());
                case 'outLinks':
                case 'inLinks':
                case 'links':
                    return networkcube.copyTimeSeries(v, function () { return new networkcube.ArrayTimeSeries(); });
                case 'outNeighbors':
                case 'inNeighbors':
                case 'neighbors':
                    return networkcube.copyTimeSeries(v, function () { return new networkcube.ArrayTimeSeries(); });
                case 'locations':
                    return networkcube.copyTimeSeries(v, function () { return new networkcube.ScalarTimeSeries(); });
                default:
                    return v;
            }
        };
        DynamicGraph.linkArrayReviver = function (k, v, s) {
            switch (k) {
                case '':
                    return networkcube.copyPropsShallow(v, new LinkArray());
                case 'weights':
                    return networkcube.copyTimeSeries(v, function () { return new networkcube.ScalarTimeSeries(); });
                default:
                    return v;
            }
        };
        DynamicGraph.nodePairArrayReviver = function (k, v, s) {
            switch (k) {
                case '':
                    return networkcube.copyPropsShallow(v, new NodePairArray());
                default:
                    return v;
            }
        };
        DynamicGraph.timeArrayReviver = function (k, v, s) {
            switch (k) {
                case '':
                    return networkcube.copyPropsShallow(v, new TimeArray());
                case 'time':
                    var vAsArray = v;
                    return vAsArray.map(function (s, i) { return moment(s); });
                default:
                    return v;
            }
        };
        DynamicGraph.linkTypeArrayReviver = function (k, v, s) {
            switch (k) {
                case '':
                    return networkcube.copyPropsShallow(v, new LinkTypeArray());
                default:
                    return v;
            }
        };
        DynamicGraph.nodeTypeArrayReviver = function (k, v, s) {
            switch (k) {
                case '':
                    return networkcube.copyPropsShallow(v, new NodeTypeArray());
                default:
                    return v;
            }
        };
        DynamicGraph.locationArrayReviver = function (k, v, s) {
            switch (k) {
                case '':
                    return networkcube.copyPropsShallow(v, new LocationArray());
                default:
                    return v;
            }
        };
        DynamicGraph.prototype.loadDynamicGraph = function (dataMgr, dataSetName) {
            this.clearSelections();
            this.name = dataSetName;
            var thisGraph = this;
            this.gran_min = dataMgr.getFromStorage(this.name, this.gran_min_NAME);
            console.log('this.gran_min', this.gran_min);
            this.gran_max = dataMgr.getFromStorage(this.name, this.gran_max_NAME);
            this.minWeight = dataMgr.getFromStorage(this.name, this.minWeight_NAME);
            this.maxWeight = dataMgr.getFromStorage(this.name, this.maxWeight_NAME);
            this.matrix = dataMgr.getFromStorage(this.name, this.matrix_NAME);
            this.nodeArrays = dataMgr.getFromStorage(this.name, this.nodeArrays_NAME, DynamicGraph.nodeArrayReviver);
            this.linkArrays = dataMgr.getFromStorage(this.name, this.linkArrays_NAME, DynamicGraph.linkArrayReviver);
            this.nodePairArrays = dataMgr.getFromStorage(this.name, this.nodePairArrays_NAME, DynamicGraph.nodePairArrayReviver);
            this.timeArrays = dataMgr.getFromStorage(this.name, this.timeArrays_NAME, DynamicGraph.timeArrayReviver);
            if (!('timeArrays' in this) || !this.timeArrays) {
                console.log('No timeArrays');
                this.timeArrays = new TimeArray();
            }
            else if ('momentTime' in this.timeArrays && 'unixTime' in this.timeArrays) {
                var ta = this.timeArrays['momentTime'];
                for (var i = 0; i < ta.length; i++) {
                    ta[i] = moment.utc(this.timeArrays['unixTime'][i]);
                }
            }
            else if ('unixTime' in this.timeArrays) {
                console.log('No time in timeArrays');
                this.timeArrays['momentTime'] = this.timeArrays['unixTime'].map(moment.utc);
            }
            else {
                console.log('No time or unixTime in timeArrays');
                this.timeArrays['momentTime'] = [];
            }
            this.linkTypeArrays = dataMgr.getFromStorage(this.name, this.linkTypeArrays_NAME, DynamicGraph.linkTypeArrayReviver);
            this.nodeTypeArrays = dataMgr.getFromStorage(this.name, this.nodeTypeArrays_NAME, DynamicGraph.nodeTypeArrayReviver);
            this.locationArrays = dataMgr.getFromStorage(this.name, this.locationArrays_NAME, DynamicGraph.locationArrayReviver);
            this.attributeArrays = {
                node: this.nodeArrays,
                link: this.linkArrays,
                time: this.timeArrays,
                nodePair: this.nodePairArrays,
                linkType: this.linkTypeArrays,
                nodeType: this.nodeTypeArrays,
                location: this.locationArrays
            };
            this.createGraphObjects(true, true);
            this.createSelections(true);
        };
        DynamicGraph.prototype.saveDynamicGraph = function (dataMgr) {
            dataMgr.saveToStorage(this.name, this.gran_min_NAME, this.gran_min);
            dataMgr.saveToStorage(this.name, this.gran_max_NAME, this.gran_max);
            dataMgr.saveToStorage(this.name, this.minWeight_NAME, this.minWeight);
            dataMgr.saveToStorage(this.name, this.maxWeight_NAME, this.maxWeight);
            dataMgr.saveToStorage(this.name, this.matrix_NAME, this.matrix);
            dataMgr.saveToStorage(this.name, this.nodeArrays_NAME, this.nodeArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.linkArrays_NAME, this.linkArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.nodePairArrays_NAME, this.nodePairArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.timeArrays_NAME, this.timeArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.linkTypeArrays_NAME, this.linkTypeArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.nodeTypeArrays_NAME, this.nodeTypeArrays, this.standardArrayReplacer);
            dataMgr.saveToStorage(this.name, this.locationArrays_NAME, this.locationArrays, this.standardArrayReplacer);
        };
        DynamicGraph.prototype.debugCompareTo = function (other) {
            var result = true;
            if (this.name != other.name) {
                console.log("name different");
                result = false;
            }
            if (this.gran_min != other.gran_min) {
                console.log("gran_min different", this.gran_min, other.gran_min);
                result = false;
            }
            if (this.gran_max != other.gran_max) {
                console.log("gran_max different", this.gran_max, other.gran_max);
                result = false;
            }
            if (this._nodes.length != other._nodes.length
                || !networkcube.compareTypesDeep(this._nodes, other._nodes, 2)) {
                console.log("nodes different");
                result = false;
            }
            if (this._links.length != other._links.length
                || !networkcube.compareTypesDeep(this._links, other._links, 2)) {
                console.log("links different");
                result = false;
            }
            if (this._nodePairs.length != other._nodePairs.length
                || !networkcube.compareTypesDeep(this._nodePairs, other._nodePairs, 2)) {
                console.log("nodePairs different");
                result = false;
            }
            if (this._locations.length != other._locations.length
                || !networkcube.compareTypesDeep(this._locations, other._locations, 2)) {
                console.log("locations different");
                result = false;
            }
            if (this._times.length != other._times.length
                || !networkcube.compareTypesDeep(this._times, other._times, 2)) {
                console.log("times different");
                result = false;
            }
            if ((this.nodeOrders && this.nodeOrders.length != other.nodeOrders.length)
                || !networkcube.compareTypesDeep(this.nodeOrders, other.nodeOrders, 2)) {
                console.log("nodeOrders different", this.nodeOrders, other.nodeOrders);
                result = false;
            }
            if (this.matrix.length != other.matrix.length
                || !networkcube.compareTypesDeep(this.matrix, other.matrix, 2)) {
                console.log("matrix different", this.matrix, other.matrix);
                result = false;
            }
            if (this.nodeArrays.length != other.nodeArrays.length
                || !networkcube.compareTypesDeep(this.nodeArrays, other.nodeArrays, 2)) {
                console.log("nodeArrays different", this.nodeArrays, other.nodeArrays);
                result = false;
            }
            if (this.linkArrays.length != other.linkArrays.length
                || !networkcube.compareTypesDeep(this.linkArrays, other.linkArrays, 2)) {
                console.log("linkArrays different", this.linkArrays, other.linkArrays);
                result = false;
            }
            if (this.nodePairArrays.length != other.nodePairArrays.length
                || !networkcube.compareTypesDeep(this.nodePairArrays, other.nodePairArrays, 2)) {
                console.log("nodePairArrays different", this.nodePairArrays, other.nodePairArrays);
                result = false;
            }
            if (this.timeArrays.length != other.timeArrays.length
                || !networkcube.compareTypesDeep(this.timeArrays, other.timeArrays, 2)) {
                console.log("timeArrays different", this.timeArrays, other.timeArrays);
                result = false;
            }
            if (this.linkTypeArrays.length != other.linkTypeArrays.length
                || !networkcube.compareTypesDeep(this.linkTypeArrays, other.linkTypeArrays, 2)) {
                console.log("linkTypeArrays different", this.linkTypeArrays, other.linkTypeArrays);
                result = false;
            }
            if (this.nodeTypeArrays.length != other.nodeTypeArrays.length
                || !networkcube.compareTypesDeep(this.nodeTypeArrays, other.nodeTypeArrays, 2)) {
                console.log("nodeTypeArrays different", this.nodeTypeArrays, other.nodeTypeArrays);
                result = false;
            }
            if (this.locationArrays.length != other.locationArrays.length
                || !networkcube.compareTypesDeep(this.locationArrays, other.locationArrays, 2)) {
                console.log("locationArrays different", this.locationArrays, other.locationArrays);
                result = false;
            }
            if (this.defaultLinkSelection.elementIds.length != other.defaultLinkSelection.elementIds.length
                || !networkcube.compareTypesDeep(this.defaultLinkSelection, other.defaultLinkSelection, 2)) {
                console.log("defaultLinkSelection different", this.defaultLinkSelection, other.defaultLinkSelection);
                result = false;
            }
            if (this.defaultNodeSelection.elementIds.length != other.defaultNodeSelection.elementIds.length
                || !networkcube.compareTypesDeep(this.defaultNodeSelection, other.defaultNodeSelection, 2)) {
                console.log("defaultNodeSelection different", this.defaultNodeSelection, other.defaultNodeSelection);
                result = false;
            }
            if (this.selections.length != other.selections.length
                || !networkcube.compareTypesDeep(this.selections, other.selections, 2)) {
                console.log("selections different", this.selections, other.selections);
                result = false;
            }
            return result;
        };
        DynamicGraph.prototype.initDynamicGraph = function (data) {
            this.clearSelections();
            console.log('[dynamicgraph.ts] Create dynamic graph for ', data.name, data);
            this.name = data.name;
            this.gran_min = 0;
            this.gran_max = 0;
            if (networkcube.isValidIndex(data.linkSchema.time)) {
                var timeLabels = [];
                var timeLabel;
                var unixTimes = [];
                var unixTime;
                for (var i = 0; i < data.linkTable.length; i++) {
                    timeLabel = data.linkTable[i][data.linkSchema.time];
                    unixTime = parseInt(moment(timeLabel, TIME_FORMAT).format('x'));
                    if (unixTime == undefined)
                        continue;
                    if (unixTimes.indexOf(unixTime) == -1) {
                        unixTimes.push(unixTime);
                    }
                }
                unixTimes.sort(networkcube.sortNumber);
                var diff = 99999999999999;
                for (var i = 0; i < unixTimes.length - 2; i++) {
                    diff = Math.min(diff, unixTimes[i + 1] - unixTimes[i]);
                }
                var diff_min = diff;
                if (diff >= 1000)
                    this.gran_min = 1;
                if (diff >= 1000 * 60)
                    this.gran_min = 2;
                if (diff >= 1000 * 60 * 60)
                    this.gran_min = 3;
                if (diff >= 1000 * 60 * 60 * 24)
                    this.gran_min = 4;
                if (diff >= 1000 * 60 * 60 * 24 * 7)
                    this.gran_min = 5;
                if (diff >= 1000 * 60 * 60 * 24 * 30)
                    this.gran_min = 6;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                    this.gran_min = 7;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                    this.gran_min = 8;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                    this.gran_min = 9;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                    this.gran_min = 10;
                diff = unixTimes[unixTimes.length - 1] - unixTimes[0];
                this.gran_max = 0;
                if (diff >= 1000)
                    this.gran_max = 1;
                if (diff >= 1000 * 60)
                    this.gran_max = 2;
                if (diff >= 1000 * 60 * 60)
                    this.gran_max = 3;
                if (diff >= 1000 * 60 * 60 * 24)
                    this.gran_max = 4;
                if (diff >= 1000 * 60 * 60 * 24 * 7)
                    this.gran_max = 5;
                if (diff >= 1000 * 60 * 60 * 24 * 30)
                    this.gran_max = 6;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12)
                    this.gran_max = 7;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 10)
                    this.gran_max = 8;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 100)
                    this.gran_max = 9;
                if (diff >= 1000 * 60 * 60 * 24 * 30 * 12 * 1000)
                    this.gran_max = 10;
                console.log('[Dynamic Graph] Minimal granularity', networkcube.GRANULARITY[this.gran_min]);
                console.log('[Dynamic Graph] Maximal granularity', networkcube.GRANULARITY[this.gran_max]);
                for (var i = 0; i < unixTimes.length; i++) {
                    this.timeArrays.id.push(i);
                    this.timeArrays.momentTime.push(moment(unixTimes[i]));
                    this.timeArrays.label.push(this.timeArrays.momentTime[i].format(TIME_FORMAT));
                    this.timeArrays.unixTime.push(unixTimes[i]);
                    this.timeArrays.selections.push([]);
                    this.timeArrays.filter.push(false);
                    this.timeArrays.links.push([]);
                    this._times.push(new networkcube.Time(i, this));
                }
                console.log('#TIMES:', this._times.length);
                console.log('   minTime', this.timeArrays.label[0]);
                console.log('   maxTime', this.timeArrays.label[this.timeArrays.length - 1]);
                for (var g = 0; g <= networkcube.GRANULARITY.length; g++) {
                    this.timeObjects.push([]);
                }
            }
            if (this.timeArrays.length == 0) {
                this.timeArrays.id.push(0);
                this.timeArrays.momentTime.push(moment(0));
                this.timeArrays.unixTime.push(0);
                this.timeArrays.selections.push([]);
                this.timeArrays.filter.push(false);
                this.timeArrays.links.push([]);
                this._times.push(new networkcube.Time(0, this));
            }
            var id_loc;
            var location;
            console.assert(!data.locationTable || networkcube.isValidIndex(data.locationSchema.id));
            if (data.locationTable) {
                for (var i = 0; i < data.locationTable.length; i++) {
                    this.locationArrays.id.push(data.locationTable[i][data.locationSchema.id]);
                    this.locationArrays.label.push(data.locationTable[i][data.locationSchema.label]);
                    this.locationArrays.longitude.push(data.locationTable[i][data.locationSchema.longitude]);
                    this.locationArrays.latitude.push(data.locationTable[i][data.locationSchema.latitude]);
                    this.locationArrays.x.push(data.locationTable[i][data.locationSchema.x]);
                    this.locationArrays.y.push(data.locationTable[i][data.locationSchema.y]);
                    this.locationArrays.z.push(data.locationTable[i][data.locationSchema.z]);
                    this.locationArrays.radius.push(data.locationTable[i][data.locationSchema.radius]);
                }
            }
            if ('id' in this.locationArrays)
                console.log('locations', this.locationArrays.id.length);
            var row;
            var nodeId_data;
            var nodeId_table;
            var attribute;
            var time;
            console.assert(data.nodeTable.length == 0 || networkcube.isValidIndex(data.nodeSchema.id), 'either there is no nodeTable data, or we have a schema for the nodetable');
            var nodeUserProperties = [];
            for (var prop in data.nodeSchema) {
                if (data.nodeSchema.hasOwnProperty(prop)
                    && prop != 'id'
                    && prop != 'label'
                    && prop != 'time'
                    && prop != 'name'
                    && prop != 'nodeType'
                    && prop != 'location'
                    && prop != 'constructor') {
                    nodeUserProperties.push(prop);
                    this.nodeArrays[prop] = [];
                }
            }
            for (var i = 0; i < data.nodeTable.length; i++) {
                row = data.nodeTable[i];
                nodeId_data = row[data.nodeSchema.id];
                nodeId_table = this.nodeArrays.id.indexOf(nodeId_data);
                if (nodeId_table == -1) {
                    nodeId_table = this.nodeArrays.id.length;
                    this.nodeArrays.id.push(nodeId_data);
                    this.nodeArrays.nodeType.push('');
                    this.nodeArrays.outLinks.push(new networkcube.ArrayTimeSeries());
                    this.nodeArrays.inLinks.push(new networkcube.ArrayTimeSeries());
                    this.nodeArrays.links.push(new networkcube.ArrayTimeSeries());
                    this.nodeArrays.outNeighbors.push(new networkcube.ArrayTimeSeries());
                    this.nodeArrays.inNeighbors.push(new networkcube.ArrayTimeSeries());
                    this.nodeArrays.neighbors.push(new networkcube.ArrayTimeSeries());
                    this.nodeArrays.selections.push([]);
                    this.nodeArrays.filter.push(false);
                    this.nodeArrays.locations.push(new networkcube.ScalarTimeSeries());
                    this.nodeArrays.attributes.push(new Object());
                    if (networkcube.isValidIndex(data.nodeSchema.label)) {
                        this.nodeArrays.label.push(row[data.nodeSchema.label]);
                    }
                    else {
                        this.nodeArrays.label.push(row[data.nodeSchema.id]);
                    }
                }
                if (networkcube.isValidIndex(data.nodeSchema.time)) {
                    timeLabel = row[data.nodeSchema.time];
                    if (timeLabel == undefined) {
                        time = this._times[0];
                    }
                    else {
                        time = this._times[this.getTimeIdForUnixTime(parseInt(moment(timeLabel, TIME_FORMAT).format('x')))];
                    }
                }
                else {
                    time = this._times[0];
                }
                if (time == undefined)
                    time = this._times[0];
                if (networkcube.isValidIndex(data.nodeSchema.location)) {
                    var locId = row[data.nodeSchema.location];
                    if (locId == null || locId == undefined)
                        continue;
                    this.nodeArrays.locations[nodeId_data].set(time, locId);
                }
                if (networkcube.isValidIndex(data.nodeSchema.nodeType)) {
                    typeName = data.nodeTable[i][data.nodeSchema.nodeType];
                    typeId = this.nodeTypeArrays.name.indexOf(typeName);
                    if (typeId < 0) {
                        typeId = this.nodeTypeArrays.length;
                        this.nodeTypeArrays.id.push(typeId);
                        this.nodeTypeArrays.name.push(typeName);
                    }
                    this.nodeArrays.nodeType[nodeId_table] = typeName;
                    data.nodeTable[i][data.nodeSchema.nodeType] = typeId;
                }
                for (var p = 0; p < nodeUserProperties.length; p++) {
                    prop = nodeUserProperties[p];
                    this.nodeArrays[prop].push(row[data.nodeSchema[prop]]);
                }
            }
            if ('id' in this.nodeArrays) {
                for (var i = 0; i < this.nodeArrays.id.length; i++) {
                    this.matrix.push(networkcube.array(undefined, this.nodeArrays.id.length));
                }
            }
            var s, t;
            var id;
            var timeId;
            var nodePairId;
            var linkId;
            var typeName;
            var typeId;
            var linkUserProperties = [];
            for (var prop in data.linkSchema) {
                if (data.linkSchema.hasOwnProperty(prop)
                    && prop != 'id'
                    && prop != 'linkType'
                    && prop != 'time'
                    && prop != 'name'
                    && prop != 'source'
                    && prop != 'target'
                    && prop != 'weight'
                    && prop != 'directed') {
                    linkUserProperties.push(prop);
                    this.linkArrays[prop] = [];
                }
            }
            console.log('linkUserProperties', linkUserProperties);
            console.assert(data.linkTable.length == 0 || (networkcube.isValidIndex(data.linkSchema.id)
                && networkcube.isValidIndex(data.linkSchema.source)
                && networkcube.isValidIndex(data.linkSchema.target)), 'either there are no links, or the linkschema is defined');
            for (var i = 0; i < data.linkTable.length; i++) {
                row = data.linkTable[i];
                linkId = row[data.linkSchema.id];
                this.linkArrays.directed.push(false);
                if (this.linkArrays.id.indexOf(linkId) == -1) {
                    this.linkArrays.id[linkId] = linkId;
                    this.linkArrays.source[linkId] = row[data.linkSchema.source];
                    this.linkArrays.target[linkId] = row[data.linkSchema.target];
                    this.linkArrays.linkType[linkId] = row[data.linkSchema.linkType];
                    this.linkArrays.directed[linkId] = row[data.linkSchema.directed];
                    this.linkArrays.weights[linkId] = new networkcube.ScalarTimeSeries();
                    this.linkArrays.presence[linkId] = [];
                    this.linkArrays.selections.push([]);
                    this.linkArrays.nodePair.push(undefined);
                    this.linkArrays.filter.push(false);
                }
                var TIME_FORMAT = 'YYYY-MM-DD hh:mm:ss';
                if (networkcube.isValidIndex(data.linkSchema.time)) {
                    timeLabel = data.linkTable[i][data.linkSchema.time];
                    unixTime = parseInt(moment(timeLabel, TIME_FORMAT).format('x'));
                    timeId = this.getTimeIdForUnixTime(unixTime);
                }
                else {
                    timeId = 0;
                }
                if (timeId == undefined)
                    timeId = 0;
                time = this._times[timeId];
                this.linkArrays.presence[linkId].push(timeId);
                if (networkcube.isValidIndex(data.linkSchema.weight) && data.linkTable[i][data.linkSchema.weight] != undefined) {
                    this.linkArrays.weights[linkId].set(time, data.linkTable[i][data.linkSchema.weight]);
                    this.minWeight = Math.min(this.minWeight, data.linkTable[i][data.linkSchema.weight]);
                    this.maxWeight = Math.max(this.maxWeight, data.linkTable[i][data.linkSchema.weight]);
                }
                else {
                    this.minWeight = 0;
                    this.maxWeight = 1;
                    this.linkArrays.weights[linkId].set(time, 1);
                }
                s = this.nodeArrays.id.indexOf(row[data.linkSchema.source]);
                t = this.nodeArrays.id.indexOf(row[data.linkSchema.target]);
                this.nodeArrays.neighbors[s].add(time, t);
                this.nodeArrays.neighbors[t].add(time, s);
                this.nodeArrays.links[s].add(time, linkId);
                this.nodeArrays.links[t].add(time, linkId);
                if (this.linkArrays.directed[i]) {
                    this.nodeArrays.outNeighbors[s].add(time, t);
                    this.nodeArrays.inNeighbors[t].add(time, s);
                    this.nodeArrays.outLinks[s].add(time, linkId);
                    this.nodeArrays.inLinks[t].add(time, linkId);
                }
                nodePairId = this.matrix[s][t];
                if (!networkcube.isValidIndex(nodePairId)) {
                    nodePairId = this.nodePairArrays.length;
                    this.matrix[s][t] = nodePairId;
                    this.nodePairArrays.id.push(nodePairId);
                    this.nodePairArrays.source.push(s);
                    this.nodePairArrays.target.push(t);
                    this.nodePairArrays.links.push([]);
                    this.nodePairArrays.selections.push([]);
                    this.nodePairArrays.filter.push(false);
                }
                if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
                    this.nodePairArrays.links[nodePairId].push(linkId);
                    this.linkArrays.nodePair[linkId] = nodePairId;
                }
                if (this.linkArrays.directed[i]) {
                    nodePairId = this.matrix[t][s];
                    if (!nodePairId) {
                        nodePairId = this.nodePairArrays.id.length;
                        this.matrix[t][s] = nodePairId;
                        this.nodePairArrays.id.push(nodePairId);
                        this.nodePairArrays.source.push(t);
                        this.nodePairArrays.target.push(s);
                        this.nodePairArrays.links.push(networkcube.doubleArray(this._times.length));
                    }
                    if (this.nodePairArrays.links[nodePairId].indexOf(linkId) == -1) {
                        this.nodePairArrays.links[nodePairId].push(linkId);
                        this.linkArrays.nodePair[linkId] = nodePairId;
                    }
                }
                if (networkcube.isValidIndex(data.linkSchema.linkType)) {
                    typeName = data.linkTable[i][data.linkSchema.linkType];
                    typeId = this.linkTypeArrays.name.indexOf(typeName);
                    if (typeId < 0) {
                        typeId = this.linkTypeArrays.length;
                        this.linkTypeArrays.id.push(typeId);
                        this.linkTypeArrays.name.push(typeName);
                    }
                    data.linkTable[i][data.linkSchema.linkType] = typeId;
                }
                for (var p = 0; p < linkUserProperties.length; p++) {
                    prop = linkUserProperties[p];
                    this.linkArrays[prop].push(row[data.linkSchema[prop]]);
                }
            }
            for (var i = 0; i < this.linkArrays.length; i++) {
                for (var j = 0; j < this.timeArrays.length; j++) {
                    if (this.linkArrays.weights[i].serie.hasOwnProperty(this.timeArrays.id[j].toString())) {
                        this.timeArrays.links[j].push(this.linkArrays.id[i]);
                    }
                }
            }
            var linkTypeCount = this.linkTypeArrays.length;
            console.log('[Dynamic Graph] Dynamic Graph created: ', this.nodeArrays.length);
            console.log('[Dynamic Graph]    - Nodes: ', this.nodeArrays.length);
            console.log('[Dynamic Graph]    - Edges: ', this.linkArrays.length);
            console.log('[Dynamic Graph]    - Times: ', this.timeArrays.length);
            console.log('[Dynamic Graph]    - Link types: ', this.linkTypeArrays.length);
            console.log('[Dynamic Graph]    - Node Pairs: ', this.nodePairArrays.length);
            console.log('>>>this.nodeArrays["neighbors"][0]', this.nodeArrays['neighbors'][0]);
            this.createGraphObjects(true, true);
            this.createSelections(false);
        };
        DynamicGraph.prototype.createSelections = function (shouldCreateArrays) {
            if (shouldCreateArrays) {
                if (!('nodeArrays' in this && this.nodeArrays)) {
                    this.nodeArrays = new NodeArray();
                    this.linkArrays = new LinkArray();
                    this.timeArrays = new TimeArray();
                    this.nodePairArrays = new NodePairArray();
                }
                this.nodeArrays.selections = new Array(this.nodeArrays.length);
                for (var i = 0; i < this.nodeArrays.selections.length; i++) {
                    this.nodeArrays.selections[i] = [];
                }
                this.linkArrays.selections = new Array(this.linkArrays.length);
                for (var i = 0; i < this.linkArrays.selections.length; i++) {
                    this.linkArrays.selections[i] = [];
                }
                this.timeArrays.selections = new Array(this.timeArrays.length);
                for (var i = 0; i < this.timeArrays.selections.length; i++) {
                    this.timeArrays.selections[i] = [];
                }
                this.nodePairArrays.selections = new Array(this.nodePairArrays.length);
                for (var i = 0; i < this.nodePairArrays.selections.length; i++) {
                    this.nodePairArrays.selections[i] = [];
                }
            }
            this.defaultNodeSelection = this.createSelection('node');
            this.defaultNodeSelection.name = 'Unselected';
            for (var i = 0; i < this._nodes.length; i++) {
                this.defaultNodeSelection.elementIds.push(i);
                this.addToAttributeArraysSelection(this.defaultNodeSelection, 'node', this._nodes[i].id());
            }
            this.defaultNodeSelection.color = '#000000';
            this.defaultNodeSelection.showColor = false;
            this.defaultNodeSelection.priority = 10000;
            this.selectionColor_pointer--;
            this.defaultLinkSelection = this.createSelection('link');
            this.defaultLinkSelection.name = 'Unselected';
            for (var i = 0; i < this._links.length; i++) {
                this.defaultLinkSelection.elementIds.push(i);
                this.addToAttributeArraysSelection(this.defaultLinkSelection, 'link', this._links[i].id());
            }
            this.defaultLinkSelection.color = '#000000';
            this.defaultLinkSelection.showColor = false;
            this.defaultLinkSelection.priority = 10000;
            this.selectionColor_pointer--;
            var types = [];
            var type, index;
            var selection;
            var nodeSelections = [];
            for (var i = 0; i < this.nodeArrays.nodeType.length; i++) {
                type = this.nodeArrays.nodeType[i];
                if (type == undefined || type.length == 0 || type == 'undefined')
                    continue;
                index = types.indexOf(type);
                if (index == -1) {
                    selection = this.createSelection('node');
                    selection.name = type;
                    nodeSelections.push(selection);
                    types.push(type);
                }
                else {
                    selection = nodeSelections[index];
                }
                this.addElementToSelection(selection, this._nodes[i]);
            }
            if (nodeSelections.length == 1) {
                console.log('nodeSelections[0]:', nodeSelections[0]);
                nodeSelections[0].color = '#444';
            }
            types = [];
            var linkSelections = [];
            for (var i = 0; i < this.linkArrays.linkType.length; i++) {
                type = this.linkArrays.linkType[i];
                if (!type || type == 'undefined')
                    continue;
                index = types.indexOf(type);
                if (index == -1) {
                    selection = this.createSelection('link');
                    selection.name = type;
                    linkSelections.push(selection);
                    types.push(type);
                }
                else {
                    selection = linkSelections[index];
                }
                this.addElementToSelection(selection, this._links[i]);
            }
            if (linkSelections.length == 1)
                linkSelections[0].color = '#444';
            this.currentSelection_id = 0;
        };
        DynamicGraph.prototype.createGraphObjects = function (shouldCreateTimes, shouldCreateLinkTypes) {
            console.log('[DynamicNetwork:createGraph()] >>> ');
            var d = Date.now();
            if (this.locationArrays && 'id' in this.locationArrays) {
                for (var i = 0; i < this.locationArrays.id.length; i++) {
                    this._locations.push(new networkcube.Location(this.locationArrays.id[i], this));
                }
            }
            else {
                this.locationArrays = new LocationArray();
            }
            var nodes = [];
            var locations;
            if ('nodeArrays' in this && this.nodeArrays) {
                for (var i = 0; i < this.nodeArrays.id.length; i++) {
                    nodes.push(new networkcube.Node(i, this));
                }
            }
            var links = [];
            var link;
            var source, target;
            if ('linkArrays' in this && this.linkArrays) {
                for (var i = 0; i < this.linkArrays.source.length; i++) {
                    link = new networkcube.Link(i, this);
                    links.push(link);
                }
            }
            var s, t;
            var pairLinks;
            var pair;
            var pairLinkId;
            var thisGraphNodePairIds = [];
            if ('nodePairArrays' in this && this.nodePairArrays) {
                for (var i = 0; i < this.nodePairArrays.length; i++) {
                    pairLinks = this.nodePairArrays.links[i];
                    this._nodePairs.push(new networkcube.NodePair(i, this));
                }
            }
            this._nodes = nodes;
            this._links = links;
            if (shouldCreateTimes) {
                this._times = [];
                for (var i = 0; i < this.timeArrays.length; i++)
                    this._times.push(new networkcube.Time(i, this));
            }
            console.log('[DynamicNetwork:getGraph()] <<< ', Date.now() - d, 'msec');
        };
        DynamicGraph.prototype.nodeAttr = function (attr, id) {
            return this.attr(attr, id, 'node');
        };
        DynamicGraph.prototype.linkAttr = function (attr, id) {
            return this.attr(attr, id, 'link');
        };
        DynamicGraph.prototype.pairAttr = function (attr, id) {
            return this.attr(attr, id, 'nodePair');
        };
        DynamicGraph.prototype.timeAttr = function (attr, id) {
            return this.attr(attr, id, 'time');
        };
        Object.defineProperty(DynamicGraph.prototype, "startTime", {
            get: function () { return this._times[0]; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DynamicGraph.prototype, "endTime", {
            get: function () { return this._times[this._times.length - 1]; },
            enumerable: true,
            configurable: true
        });
        DynamicGraph.prototype.highlight = function (action, idCompound) {
            if (action == 'reset') {
                this.highlightArrays.nodeIds = [];
                this.highlightArrays.linkIds = [];
                this.highlightArrays.nodePairIds = [];
                this.highlightArrays.timeIds = [];
                return;
            }
            if (!idCompound) {
                console.error('[DynamicGraph] highlight: idCompound not set!');
                return;
            }
            if (action == 'set') {
                this.highlight('reset');
                this.highlight('add', idCompound);
                return;
            }
            if (action == 'add') {
                for (var type in idCompound) {
                    for (var i = 0; i < idCompound[type].length; i++) {
                        this.highlightArrays[type].push(idCompound[type][i]);
                    }
                }
            }
            else if (action == 'remove') {
                var index;
                for (var type in idCompound) {
                    for (var i = 0; i < idCompound[type].length; i++) {
                        index = this.highlightArrays[type].indexOf(idCompound[type][i]);
                        if (index >= 0)
                            this.highlightArrays[type].splice(index, 1);
                    }
                }
            }
        };
        DynamicGraph.prototype.selection = function (action, idCompound, selectionId) {
            if (selectionId == undefined)
                selectionId = this.currentSelection_id;
            var selection = this.getSelection(selectionId);
            if (!selection)
                console.error('[DynamicGraph] Selection with ', selectionId, 'not found in ', this.selections);
            var self = this;
            if (action == 'set') {
                var c = new networkcube.IDCompound();
                c[selection.acceptedType] = selection.elementIds;
                this.selection('remove', c, selectionId);
                this.selection('add', idCompound, selectionId);
            }
            else if (action == 'add') {
                idCompound.linkIds.forEach(function (v, i, arr) { return self.addToSelectionByTypeAndId(selection, 'link', v); });
                idCompound.nodeIds.forEach(function (v, i, arr) { return self.addToSelectionByTypeAndId(selection, 'node', v); });
                idCompound.timeIds.forEach(function (v, i, arr) { return self.addToSelectionByTypeAndId(selection, 'time', v); });
                idCompound.nodePairIds.forEach(function (v, i, arr) { return self.addToSelectionByTypeAndId(selection, 'nodePair', v); });
            }
            else if (action == 'remove') {
                idCompound.linkIds.forEach(function (v, i, arr) { return self.removeFromSelectionByTypeAndId(selection, 'link', v); });
                idCompound.nodeIds.forEach(function (v, i, arr) { return self.removeFromSelectionByTypeAndId(selection, 'node', v); });
                idCompound.timeIds.forEach(function (v, i, arr) { return self.removeFromSelectionByTypeAndId(selection, 'time', v); });
                idCompound.nodePairIds.forEach(function (v, i, arr) { return self.removeFromSelectionByTypeAndId(selection, 'nodePair', v); });
            }
        };
        DynamicGraph.prototype.addToAttributeArraysSelection = function (selection, type, id) {
            var elementSelections = this.attributeArrays[type].selections[id];
            for (var i = 0; i < elementSelections.length; i++) {
                if (elementSelections[i].priority > selection.priority) {
                    this.attributeArrays[type].selections[id].splice(i, 0, selection);
                    return;
                }
            }
            this.attributeArrays[type].selections[id].push(selection);
        };
        DynamicGraph.prototype.removeFromAttributeArraysSelection = function (selection, type, id) {
            var arr = this.attributeArrays[type].selections[id];
            for (var i = 0; i < arr.length; i++) {
                if (arr[i] == selection)
                    this.attributeArrays[type].selections[id].splice(i, 1);
            }
        };
        DynamicGraph.prototype.addElementToSelection = function (selection, e) {
            this.addToSelectionByTypeAndId(selection, e.type, e.id());
        };
        DynamicGraph.prototype.addToSelectionByTypeAndId = function (selection, type, id) {
            if (type != selection.acceptedType) {
                console.log('attempting to put object of the wrong type into a selection');
                return;
            }
            selection.elementIds.push(id);
            this.addToAttributeArraysSelection(selection, type, id);
            var i;
            if (type == 'node') {
                i = this.defaultNodeSelection.elementIds.indexOf(id);
                if (i > -1) {
                    this.removeFromAttributeArraysSelection(this.defaultNodeSelection, type, id);
                    this.defaultNodeSelection.elementIds.splice(i, 1);
                }
            }
            else if (type == 'link') {
                i = this.defaultLinkSelection.elementIds.indexOf(id);
                if (i > -1) {
                    this.removeFromAttributeArraysSelection(this.defaultLinkSelection, type, id);
                    this.defaultLinkSelection.elementIds.splice(i, 1);
                }
            }
        };
        DynamicGraph.prototype.removeElementFromSelection = function (selection, e) {
            this.removeFromSelectionByTypeAndId(selection, e.type, e.id());
        };
        DynamicGraph.prototype.removeFromSelectionByTypeAndId = function (selection, type, id) {
            var i = selection.elementIds.indexOf(id);
            if (i == -1)
                return;
            selection.elementIds.splice(i, 1);
            this.removeFromAttributeArraysSelection(selection, type, id);
            if (this.getSelectionsByTypeAndId(type, id).length == 0) {
                if (type == 'node') {
                    this.defaultNodeSelection.elementIds.push(id);
                    this.addToAttributeArraysSelection(this.defaultNodeSelection, type, id);
                }
                else if (type == 'link') {
                    this.defaultLinkSelection.elementIds.push(id);
                    this.addToAttributeArraysSelection(this.defaultLinkSelection, type, id);
                }
            }
        };
        DynamicGraph.prototype.getSelectionsByTypeAndId = function (type, id) {
            return this.attributeArrays[type].selections[id];
        };
        DynamicGraph.prototype.filterSelection = function (selectionId, filter) {
            this.getSelection(selectionId).filter = filter;
        };
        DynamicGraph.prototype.isFiltered = function (id, type) {
            return this.attributeArrays[type + 's'].filter;
        };
        DynamicGraph.prototype.isHighlighted = function (id, type) {
            return this.highlightArrays[type + 'Ids'].indexOf(id) > -1;
        };
        DynamicGraph.prototype.getHighlightedIds = function (type) {
            return this.highlightArrays[type + 'Ids'];
        };
        DynamicGraph.prototype.setCurrentSelection = function (id) {
            console.log('[DynamicGraph] setCurrentSelectionId ', id);
            this.currentSelection_id = id;
        };
        DynamicGraph.prototype.getCurrentSelection = function () {
            return this.getSelection(this.currentSelection_id);
        };
        DynamicGraph.prototype.addSelection = function (id, color, acceptedType, priority) {
            var s = this.createSelection(acceptedType);
            s.id = id;
            s.color = color;
            s.priority = priority;
        };
        DynamicGraph.prototype.createSelection = function (type) {
            var s = new Selection(this.selections.length, type);
            s.color = this.BOOKMARK_COLORS(this.selectionColor_pointer % 10);
            this.selectionColor_pointer++;
            this.selections.push(s);
            return s;
        };
        DynamicGraph.prototype.deleteSelection = function (selectionId) {
            var s = this.getSelection(selectionId);
            var idCompound = new networkcube.IDCompound();
            idCompound[s.acceptedType + 'Ids'] = s.elementIds.slice(0);
            console.log('Delete selection->remove elemeents', s.elementIds.slice(0));
            this.selection('remove', idCompound, s.id);
            this.selections.splice(this.selections.indexOf(s), 1);
        };
        DynamicGraph.prototype.setSelectionColor = function (id, color) {
            var s = this.getSelection(id);
            if (!s) {
                return;
            }
            s.color = color;
        };
        DynamicGraph.prototype.getSelections = function (type) {
            var selections = [];
            if (type) {
                for (var i = 0; i < this.selections.length; i++) {
                    if (this.selections[i].acceptsType(type))
                        selections.push(this.selections[i]);
                }
                return selections;
            }
            else {
                return this.selections;
            }
        };
        DynamicGraph.prototype.getSelection = function (id) {
            for (var i = 0; i < this.selections.length; i++) {
                if (id == this.selections[i].id)
                    return this.selections[i];
            }
            console.error('[DynamicGraph] No selection with id ', id, 'found!');
        };
        DynamicGraph.prototype.clearSelections = function () {
            this.selections = [];
        };
        DynamicGraph.prototype.getTimeIdForUnixTime = function (unixTime) {
            var timeId;
            for (timeId = 0; timeId < this.timeArrays.length; timeId++) {
                if (unixTime == this.timeArrays.unixTime[timeId]) {
                    timeId;
                    return timeId;
                }
            }
            console.error('Time object for unix time', unixTime, 'not found!');
            return undefined;
        };
        DynamicGraph.prototype.addNodeOrdering = function (name, order) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    console.error('Ordering', name, 'already exists');
                    return;
                }
            }
            var o = new Ordering(name, order);
            this.nodeOrders.push(o);
        };
        DynamicGraph.prototype.setNodeOrdering = function (name, order) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    this.nodeOrders[i].order = order;
                    return;
                }
            }
            console.error('Ordering', name, 'does not exist');
        };
        DynamicGraph.prototype.removeNodeOrdering = function (name, order) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    this.nodeOrders.splice(i, 1);
                }
            }
        };
        DynamicGraph.prototype.getNodeOrder = function (name) {
            for (var i = 0; i < this.nodeOrders.length; i++) {
                if (this.nodeOrders[i].name == name) {
                    return this.nodeOrders[i];
                }
            }
            console.error('Ordering', name, 'not found!');
            return;
        };
        DynamicGraph.prototype.nodes = function () {
            return new networkcube.NodeQuery(this.nodeArrays.id, this);
        };
        DynamicGraph.prototype.links = function () {
            return new networkcube.LinkQuery(this.linkArrays.id, this);
        };
        DynamicGraph.prototype.times = function () {
            return new networkcube.TimeQuery(this.timeArrays.id, this);
        };
        DynamicGraph.prototype.locations = function () {
            return new networkcube.LocationQuery(this.locationArrays.id, this);
        };
        DynamicGraph.prototype.nodePairs = function () {
            return new networkcube.NodePairQuery(this.nodePairArrays.id, this);
        };
        DynamicGraph.prototype.linksBetween = function (n1, n2) {
            var nodePairId = this.matrix[n1.id()][n2.id()];
            if (nodePairId == undefined)
                nodePairId = this.matrix[n2.id()][n1.id()];
            if (nodePairId == undefined)
                return new networkcube.LinkQuery([], this);
            return new networkcube.LinkQuery(this.nodePair(nodePairId).links().toArray(), this);
        };
        DynamicGraph.prototype.get = function (type, id) {
            if (type.indexOf('nodePair') > -1)
                return this.nodePair(id);
            if (type.indexOf('node') > -1)
                return this.node(id);
            if (type.indexOf('link') > -1)
                return this.link(id);
            if (type.indexOf('time') > -1)
                return this.time(id);
            if (type.indexOf('locations') > -1)
                return this.location(id);
        };
        DynamicGraph.prototype.getAll = function (type) {
            if (type == 'nodes')
                return this.nodes();
            if (type == 'links')
                return this.links();
            if (type == 'times')
                return this.times();
            if (type == 'nodePairs')
                return this.nodePairs();
            if (type == 'locations')
                return this.locations();
        };
        DynamicGraph.prototype.node = function (id) {
            for (var i = 0; i < this._nodes.length; i++) {
                if (this._nodes[i].id() == id)
                    return this._nodes[i];
            }
        };
        DynamicGraph.prototype.link = function (id) {
            for (var i = 0; i < this._links.length; i++) {
                if (this._links[i].id() == id)
                    return this._links[i];
            }
        };
        DynamicGraph.prototype.time = function (id) {
            for (var i = 0; i < this._times.length; i++) {
                if (this._times[i].id() == id)
                    return this._times[i];
            }
        };
        DynamicGraph.prototype.location = function (id) {
            for (var i = 0; i < this._locations.length; i++) {
                if (this._locations[i].id() == id)
                    return this._locations[i];
            }
        };
        DynamicGraph.prototype.nodePair = function (id) {
            for (var i = 0; i < this._nodePairs.length; i++) {
                if (this._nodePairs[i].id() == id)
                    return this._nodePairs[i];
            }
        };
        DynamicGraph.prototype.getMinGranularity = function () { return this.gran_min; };
        DynamicGraph.prototype.getMaxGranularity = function () { return this.gran_max; };
        return DynamicGraph;
    }());
    networkcube.DynamicGraph = DynamicGraph;
    var Selection = (function () {
        function Selection(id, acceptedType) {
            this.showColor = true;
            this.filter = false;
            this.priority = 0;
            this.id = id;
            this.name = 'Selection-' + this.id;
            this.elementIds = [];
            this.acceptedType = acceptedType;
            this.priority = id;
        }
        Selection.prototype.acceptsType = function (type) {
            return this.acceptedType == type;
        };
        return Selection;
    }());
    networkcube.Selection = Selection;
    var AttributeArray = (function () {
        function AttributeArray() {
            this.id = [];
        }
        Object.defineProperty(AttributeArray.prototype, "length", {
            get: function () {
                return this.id.length;
            },
            enumerable: true,
            configurable: true
        });
        return AttributeArray;
    }());
    networkcube.AttributeArray = AttributeArray;
    var NodeArray = (function (_super) {
        __extends(NodeArray, _super);
        function NodeArray() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.id = [];
            _this.label = [];
            _this.outLinks = [];
            _this.inLinks = [];
            _this.links = [];
            _this.outNeighbors = [];
            _this.inNeighbors = [];
            _this.neighbors = [];
            _this.selections = [];
            _this.attributes = [];
            _this.locations = [];
            _this.filter = [];
            _this.nodeType = [];
            return _this;
        }
        return NodeArray;
    }(AttributeArray));
    networkcube.NodeArray = NodeArray;
    var LinkArray = (function (_super) {
        __extends(LinkArray, _super);
        function LinkArray() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.source = [];
            _this.target = [];
            _this.linkType = [];
            _this.directed = [];
            _this.nodePair = [];
            _this.presence = [];
            _this.weights = [];
            _this.selections = [];
            _this.filter = [];
            _this.attributes = new Object;
            return _this;
        }
        return LinkArray;
    }(AttributeArray));
    networkcube.LinkArray = LinkArray;
    var NodePairArray = (function (_super) {
        __extends(NodePairArray, _super);
        function NodePairArray() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.source = [];
            _this.target = [];
            _this.links = [];
            _this.selections = [];
            _this.filter = [];
            return _this;
        }
        return NodePairArray;
    }(AttributeArray));
    networkcube.NodePairArray = NodePairArray;
    var TimeArray = (function (_super) {
        __extends(TimeArray, _super);
        function TimeArray() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.id = [];
            _this.momentTime = [];
            _this.label = [];
            _this.unixTime = [];
            _this.selections = [];
            _this.filter = [];
            _this.links = [];
            return _this;
        }
        return TimeArray;
    }(AttributeArray));
    networkcube.TimeArray = TimeArray;
    var LinkTypeArray = (function (_super) {
        __extends(LinkTypeArray, _super);
        function LinkTypeArray() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.name = [];
            _this.count = [];
            _this.color = [];
            _this.filter = [];
            return _this;
        }
        return LinkTypeArray;
    }(AttributeArray));
    networkcube.LinkTypeArray = LinkTypeArray;
    var NodeTypeArray = (function (_super) {
        __extends(NodeTypeArray, _super);
        function NodeTypeArray() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.name = [];
            _this.count = [];
            _this.color = [];
            _this.filter = [];
            return _this;
        }
        return NodeTypeArray;
    }(AttributeArray));
    networkcube.NodeTypeArray = NodeTypeArray;
    var LocationArray = (function (_super) {
        __extends(LocationArray, _super);
        function LocationArray() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.id = [];
            _this.label = [];
            _this.longitude = [];
            _this.latitude = [];
            _this.x = [];
            _this.y = [];
            _this.z = [];
            _this.radius = [];
            return _this;
        }
        return LocationArray;
    }(AttributeArray));
    networkcube.LocationArray = LocationArray;
    var LinkType = (function () {
        function LinkType(id, name, color) {
            this.id = id;
            this.name = name;
            this.color = color;
        }
        return LinkType;
    }());
    networkcube.LinkType = LinkType;
    var NodeType = (function () {
        function NodeType(id, name, color) {
            this.id = id;
            this.name = name;
            this.color = color;
        }
        return NodeType;
    }());
    networkcube.NodeType = NodeType;
    var Ordering = (function () {
        function Ordering(name, order) {
            this.order = [];
            this.name = name;
            this.order = order;
        }
        return Ordering;
    }());
    networkcube.Ordering = Ordering;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    var DataManager = (function () {
        function DataManager(options) {
            this.keepOnlyOneSession = false;
            this.sessionDataPrefix = "ncubesession";
            this.SEP = "_";
            if (options) {
                if (options.keepOnlyOneSession)
                    this.setOptions(options);
            }
            else {
                this.keepOnlyOneSession = false;
            }
        }
        DataManager.prototype.setOptions = function (options) {
            this.keepOnlyOneSession = options.keepOnlyOneSession;
        };
        DataManager.prototype.clearSessionData = function (session) {
            var searchPrefix = this.sessionDataPrefix + this.SEP + session;
            var keysToClear = [];
            console.log('clearSessionData');
            for (var i = 0; i < localStorage.length; i++) {
                var key = localStorage.key(i);
                if (key.indexOf(searchPrefix) == 0)
                    keysToClear.push(key);
                else if (key.indexOf('connectoscope1') == 0)
                    keysToClear.push(key);
            }
            for (var i = 0; i < keysToClear.length; i++) {
                var key = keysToClear[i];
                console.log('remove from storage', key);
                localStorage.removeItem(key);
            }
        };
        DataManager.prototype.clearAllSessionData = function () {
            this.clearSessionData('');
        };
        DataManager.prototype.isSessionCached = function (session, dataSetName) {
            var prefix = this.sessionDataPrefix + this.SEP + session + this.SEP + dataSetName;
            var firstSessionKey = null;
            for (var i = 0; i < localStorage.length; i++) {
                var key = localStorage.key(i);
                if (key.indexOf(prefix) == 0) {
                    return true;
                }
            }
            return false;
        };
        DataManager.prototype.importData = function (session, data) {
            this.session = session;
            console.log('import data set', data.name, data);
            if (!data.nodeTable && !data.linkTable) {
                console.log('Empty tables. No data imported.');
                return;
            }
            if (!data.nodeTable) {
                console.log('[n3] Node table missing!');
            }
            if (!data.linkTable) {
                console.log('[n3] Link table missing!');
            }
            if (!data.nodeSchema) {
                console.log('[n3] Node schema missing!');
            }
            if (!data.linkSchema) {
                console.log('[n3] Link schema missing!');
            }
            for (var i = 0; i < data.nodeTable.length; i++) {
                for (var j = 0; j < data.nodeTable[i].length; j++) {
                    if (typeof data.nodeTable[i][j] == 'string')
                        data.nodeTable[i][j] = data.nodeTable[i][j].trim();
                }
            }
            for (var i = 0; i < data.linkTable.length; i++) {
                for (var j = 0; j < data.linkTable[i].length; j++) {
                    if (typeof data.linkTable[i][j] == 'string')
                        data.linkTable[i][j] = data.linkTable[i][j].trim();
                }
            }
            if (this.isSchemaWellDefined(data)) {
                console.log('data is well-schematized, caching dynamicGraph');
                if (this.keepOnlyOneSession)
                    this.clearAllSessionData();
                var graphForCaching = new networkcube.DynamicGraph();
                graphForCaching.initDynamicGraph(data);
                graphForCaching.saveDynamicGraph(this);
                var doubleCheckSave = false;
                if (doubleCheckSave) {
                    var testGraph = new networkcube.DynamicGraph();
                    testGraph.loadDynamicGraph(this, data.name);
                    testGraph.debugCompareTo(graphForCaching);
                }
            }
            else {
                console.log('data is not well-schematized, so not caching dynamicGraph');
            }
        };
        DataManager.prototype.saveToStorage = function (dataName, valueName, value, replacer) {
            if (value == undefined) {
                console.log('attempting to save undefined value. aborting', dataName, valueName);
                return;
            }
            var stringifyResult = JSON.stringify(value, replacer);
            var stringToSave;
            if (stringifyResult.length > 1024 * 1024 * 4)
                stringToSave = LZString.compress(stringifyResult);
            else
                stringToSave = stringifyResult;
            localStorage[this.sessionDataPrefix + this.SEP
                + this.session
                + this.SEP + dataName
                + this.SEP + valueName] = stringToSave;
        };
        DataManager.prototype.getFromStorage = function (dataName, valueName, reviver, state) {
            console.assert(this.session && this.session != '');
            var statefulReviver;
            if (reviver)
                statefulReviver = function (key, value) {
                    return reviver(key, value, state);
                };
            else
                statefulReviver = null;
            var storedResult = localStorage[this.sessionDataPrefix
                + this.SEP + this.session
                + this.SEP + dataName
                + this.SEP + valueName];
            if (storedResult && storedResult != "undefined") {
                var parseText;
                if ("\"'[{0123456789".indexOf(storedResult[0]) >= 0)
                    parseText = storedResult;
                else
                    parseText = LZString.decompress(storedResult);
                return JSON.parse(parseText, statefulReviver);
            }
            else {
                return undefined;
            }
        };
        DataManager.prototype.removeFromStorage = function (dataName, valueName) {
            localStorage.removeItem(this.sessionDataPrefix
                + this.SEP + this.session
                + this.SEP + dataName
                + this.SEP + valueName);
        };
        DataManager.prototype.getGraph = function (session, dataname) {
            this.session = session;
            if (!this.dynamicGraph || this.dynamicGraph.name != dataname) {
                this.dynamicGraph = new networkcube.DynamicGraph();
                this.dynamicGraph.loadDynamicGraph(this, dataname);
            }
            return this.dynamicGraph;
        };
        DataManager.prototype.isSchemaWellDefined = function (data) {
            console.log('isSchemaWellDefined');
            if (data.locationTable && !networkcube.isValidIndex(data.locationSchema.id))
                return false;
            if (data.nodeTable.length > 0 && !networkcube.isValidIndex(data.nodeSchema.id))
                return false;
            if (data.linkTable.length > 0
                && !(networkcube.isValidIndex(data.linkSchema.id)
                    && networkcube.isValidIndex(data.linkSchema.source)
                    && networkcube.isValidIndex(data.linkSchema.target)))
                return false;
            return true;
        };
        return DataManager;
    }());
    networkcube.DataManager = DataManager;
    function getDefaultNodeSchema() {
        return new NodeSchema(0);
    }
    networkcube.getDefaultNodeSchema = getDefaultNodeSchema;
    function getDefaultLinkSchema() {
        return new LinkSchema(0, 1, 2);
    }
    networkcube.getDefaultLinkSchema = getDefaultLinkSchema;
    function getDefaultLocationSchema() {
        return new LocationSchema(0, 1, 2, 3, 4, 5, 6, 7, 8);
    }
    networkcube.getDefaultLocationSchema = getDefaultLocationSchema;
    var DataSet = (function () {
        function DataSet(params) {
            this.locationTable = [];
            this.selections = [];
            this.name = params.name;
            this.nodeTable = params.nodeTable;
            this.linkTable = params.linkTable;
            if (params.nodeSchema == undefined)
                this.nodeSchema = getDefaultNodeSchema();
            else
                this.nodeSchema = params.nodeSchema;
            if (params.linkSchema == undefined)
                this.linkSchema = getDefaultLinkSchema();
            else
                this.linkSchema = params.linkSchema;
            if (params.locationTable != undefined)
                this.locationTable = params.locationTable;
            if (params.locationSchema == undefined)
                this.locationSchema = getDefaultLocationSchema();
            else
                this.locationSchema = params.locationSchema;
            console.log('[n3] data set created', this);
        }
        return DataSet;
    }());
    networkcube.DataSet = DataSet;
    var TableSchema = (function () {
        function TableSchema(name) {
            this.name = name;
        }
        return TableSchema;
    }());
    networkcube.TableSchema = TableSchema;
    var NodeSchema = (function (_super) {
        __extends(NodeSchema, _super);
        function NodeSchema(id) {
            var _this = _super.call(this, 'nodeSchema') || this;
            _this.id = id;
            return _this;
        }
        return NodeSchema;
    }(TableSchema));
    networkcube.NodeSchema = NodeSchema;
    var LinkSchema = (function (_super) {
        __extends(LinkSchema, _super);
        function LinkSchema(id, source, target) {
            var _this = _super.call(this, 'linkSchema') || this;
            _this.linkType = -1;
            _this.directed = -1;
            _this.time = -1;
            _this.source = source;
            _this.target = target;
            _this.id = id;
            return _this;
        }
        return LinkSchema;
    }(TableSchema));
    networkcube.LinkSchema = LinkSchema;
    var LocationSchema = (function (_super) {
        __extends(LocationSchema, _super);
        function LocationSchema(id, label, geoname, longitude, latitude, x, y, z, radius) {
            var _this = _super.call(this, 'locationSchema') || this;
            _this.geoname = -1;
            _this.longitude = -1;
            _this.latitude = -1;
            _this.x = -1;
            _this.y = -1;
            _this.z = -1;
            _this.radius = -1;
            _this.id = id;
            _this.label = label;
            if (networkcube.isValidIndex(geoname))
                _this.geoname = geoname;
            if (networkcube.isValidIndex(longitude))
                _this.longitude = longitude;
            if (networkcube.isValidIndex(latitude))
                _this.latitude = latitude;
            if (networkcube.isValidIndex(x))
                _this.x = x;
            if (networkcube.isValidIndex(y))
                _this.y = y;
            if (networkcube.isValidIndex(z))
                _this.z = z;
            if (networkcube.isValidIndex(radius))
                _this.radius = radius;
            return _this;
        }
        return LocationSchema;
    }(TableSchema));
    networkcube.LocationSchema = LocationSchema;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    function findTemplate(nodes, template, config) {
        var nodeCount = template.nodes.length;
        var linkCount = template.links.length;
        var n;
        var links;
        var candidateNodes = [];
        for (var i = 0; i < nodes.length; i++) {
            links = nodes[i].links().toArray();
            for (var j = 0; j < nodeCount; j++) {
                for (var k = 0; k < linkCount; k++) {
                    if (template.links[k][0] == template.nodes[j])
                        for (var l = 0; l < linkCount; l++) {
                        }
                }
            }
        }
    }
    networkcube.findTemplate = findTemplate;
    function findClusters(nodes, config) {
        if (nodes.length == 0)
            return [];
        var g = nodes[0].g;
        var links = nodes[0].g.links().toArray();
        for (var i = 0; i < links.length; i++) {
            links[i].value = links[i].weights().sum();
        }
        var clusters = netClustering.cluster(nodes, links);
        var motifs = [];
        var clusterArray = [];
        var clusterLinks = [];
        var cl;
        var s, t;
        for (var c = 0; c < clusters.length; c++) {
            clusterLinks = [];
            cl = clusters[c];
            if (cl.length < 4)
                continue;
            for (var j = 0; j < cl.length; j++) {
                cl[j] = g.node(parseInt(cl[j]));
            }
            for (var i = 0; i < cl.length; i++) {
                for (var j = i + 1; j < cl.length; j++) {
                    clusterLinks = clusterLinks.concat(cl[i].linksBetween(cl[j]).toArray());
                }
            }
            motifs.push({ nodes: cl, links: clusterLinks });
        }
        return motifs;
    }
    networkcube.findClusters = findClusters;
    function findCliques(nodes, config) {
        var cliques = [];
        var p = nodes.slice();
        var r = [];
        var x = [];
        if (!config)
            var config = {};
        if (config.links == undefined)
            config.links = nodes[0].g.links().toArray();
        cliques = bronKerboschIterative(nodes, config);
        var motifs = [];
        var cliqueLinks = [];
        for (var c = 0; c < cliques.length; c++) {
            if (cliques[c].length < 4)
                continue;
            cliqueLinks = [];
            for (var i = 0; i < cliques[c].length; i++) {
                for (var j = i + 1; j < cliques[c].length; j++) {
                    cliqueLinks.push(cliques[c][i].linksBetween(cliques[c][j]).get(0));
                }
            }
            motifs.push({ nodes: cliques[c], links: cliqueLinks });
        }
        return motifs;
    }
    networkcube.findCliques = findCliques;
    ;
    function bronKerbosch(nodes, r, p, x, cliques, config) {
        if (p.length === 0 && x.length === 0) {
            cliques.push(r);
            return;
        }
        p.forEach(function (v) {
            var tempR = r.splice(0);
            tempR.push(v);
            bronKerbosch(nodes, tempR, p.filter(function (temp) {
                return v.neighbors().contains(temp);
            }), x.filter(function (temp) {
                return v.neighbors().contains(temp);
            }), cliques, config);
            p.splice(p.indexOf(v), 1);
            if (x.indexOf(v) == -1)
                x.push(v);
        });
    }
    function bronKerboschIterative(nodes, config) {
        var cliques = [];
        var stack = [];
        var R = 0;
        var P = 1;
        var X = 2;
        stack.push([[], nodes, []]);
        var r, p, x, p2, x2;
        var step;
        var newStep;
        var v;
        var count = 0;
        while (stack.length > 0) {
            count++;
            step = stack.pop();
            r = [].concat(step[R]);
            p = [].concat(step[P]);
            x = [].concat(step[X]);
            if (p.length == 0
                && x.length == 0) {
                cliques.push(r.slice());
            }
            if (p.length > 0) {
                v = p[0];
                p2 = p.slice();
                p2.splice(p2.indexOf(v), 1);
                x2 = x.slice();
                if (x2.indexOf(v) == -1)
                    x2.push(v);
                stack.push([r.slice(), p2, x2]);
                if (r.indexOf(v) == -1)
                    r.push(v);
                newStep = [r];
                p = setOps.intersection(p2, v.neighbors().toArray());
                p2 = [];
                for (var i = 0; i < p.length; i++) {
                    if (p2.indexOf(p[i]) == -1)
                        p2.push(p[i]);
                }
                newStep.push(p2);
                x = setOps.intersection(x2, v.neighbors().toArray());
                x2 = [];
                for (var i = 0; i < x.length; i++) {
                    if (x2.indexOf(x[i]) == -1)
                        x2.push(x[i]);
                }
                newStep.push(x2);
                stack.push(newStep);
            }
        }
        return cliques;
    }
    function findFullEgoNetwork(nodes, config) {
        var motifs = [];
        var ns;
        var ls;
        var finalLinks;
        var n;
        for (var i = 0; i < nodes.length; i++) {
            n = nodes[i];
            finalLinks = [];
            ns = n.neighbors().removeDuplicates();
            ls = ns.links().removeDuplicates().toArray();
            ns = ns.toArray().concat(n);
            for (var j = 0; j < ls.length; j++) {
                if (ls[j] == undefined)
                    continue;
                if (ns.indexOf(ls[j].source) > -1 && ns.indexOf(ls[j].target) > -1) {
                    finalLinks.push(ls[j]);
                }
            }
            motifs.push(new networkcube.Motif(ns, finalLinks));
        }
        return motifs;
    }
    networkcube.findFullEgoNetwork = findFullEgoNetwork;
    function findStars(nodes, config) {
        if (!config)
            var config = {};
        if (config.minLinkCount == undefined)
            config.minLinkCount = 5;
        if (config.minNeighborCount == undefined) {
            config.minNeighborCount = 5;
            config.minLinkCount = 5;
        }
        if (config.links == undefined)
            config.links = nodes[0].g.links().toArray();
        var motifs = [];
        var n;
        var lls;
        var m;
        var neighbors;
        for (var i = 0; i < nodes.length; i++) {
            n = nodes[i];
            lls = n.links().toArray();
            lls = setOps.intersection(lls, config.links);
            if (lls.length <= config.minLinkCount)
                continue;
            neighbors = [];
            for (var j = 0; j < lls.length; j++) {
                if (neighbors.indexOf(lls[j].other(n)) == -1)
                    neighbors.push(lls[j].other(n));
            }
            if (neighbors.length <= config.minNeighborCount)
                continue;
            m = new networkcube.Motif([n], []);
            for (var j = 0; j < lls.length; j++) {
                m.links.push(lls[j]);
                m.nodes.push(lls[j].other(n));
            }
            motifs.push(m);
        }
        return motifs;
    }
    networkcube.findStars = findStars;
    function findTriangles(nodes, config) {
        if (!config)
            var config = {};
        if (config.links == undefined)
            config.links = nodes[0].g.links().toArray();
        var motifs = [];
        var g = nodes[0].g;
        var l;
        var s, t;
        var ns, nt;
        var common;
        var n;
        var ll1, ll2;
        var found;
        var m;
        for (var i = 0; i < config.links.length; i++) {
            s = config.links[i].source;
            ns = s.neighbors().toArray();
            ns = setOps.intersection(ns, nodes);
            if (ns.length == 0)
                continue;
            t = config.links[i].target;
            nt = t.neighbors().toArray();
            nt = setOps.intersection(nt, nodes);
            if (nt.length == 0)
                continue;
            common = setOps.intersection(ns, nt);
            common = setOps.difference(common, [s, t]);
            if (common.length == 0)
                continue;
            for (var j = 0; j < common.length; j++) {
                n = common[j];
                ll1 = setOps.intersection(g.linksBetween(s, n).toArray(), config.links);
                if (ll1.length == 0)
                    continue;
                ll2 = setOps.intersection(g.linksBetween(t, n).toArray(), config.links);
                if (ll2.length == 0)
                    continue;
                ll1 = ll1.concat(ll2);
                ll1.push(config.links[i]);
                motifs.push(new networkcube.Motif([s, t, n], ll1));
            }
        }
        return motifs;
    }
    networkcube.findTriangles = findTriangles;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    function findDegree(nodes) {
        var motifs = [];
        var ns;
        var ls;
        var finalLinks;
        var n;
        for (var i = 0; i < nodes.length; i++) {
            n = nodes[i];
            ns = n.neighbors().removeDuplicates().toArray().concat(n);
            ls = n.links().removeDuplicates().toArray();
            motifs.push(new networkcube.Motif(ns, ls));
        }
        return motifs;
    }
    networkcube.findDegree = findDegree;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    function loadDyson(url, callback) {
        d3.json(url, function (data) {
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var nodes = data.nodes;
            for (var i = 0; i < nodes.length; i++) {
                nodeTable.push([i, nodes[i].name]);
            }
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2, weight: 3, time: 4 };
            var times = data.times;
            var m;
            for (var i = 0; i < times.length; i++) {
                m = times[i].matrix;
                for (var s = 0; s < m.length; s++) {
                    for (var t = 0; t < m.length; t++) {
                        linkTable.push([s * m.length + t, s, t, m[s][t], i]);
                    }
                }
            }
            callback(new networkcube.DataSet({
                nodeTable: nodeTable,
                linkTable: linkTable,
                linkSchema: linkSchema,
                nodeSchema: nodeSchema,
                name: url
            }));
        });
    }
    networkcube.loadDyson = loadDyson;
    function loadLinkTable(url, callBack, linkSchema, delimiter, timeFormat) {
        if (timeFormat == undefined)
            timeFormat = 'x';
        console.log('linkSchema', linkSchema);
        if (linkSchema.source == undefined) {
            console.error('[n3] Link Schema does not have -source- attribute. Import aborted.');
            return;
        }
        if (linkSchema.target == undefined) {
            console.error('[n3] Link Schema does not have -target- attribute. Import aborted.');
            return;
        }
        $.get(url, function (linkData) {
            var linkData = Papa.parse(linkData, {}).data;
            var nodeTable = [];
            var names = [];
            var nodeTimes = [];
            var nodeSchema = new networkcube.NodeSchema(0);
            nodeSchema.label = 1;
            var id_source;
            var id_target;
            var name;
            var linkTable = [];
            var newLinkSchema = new networkcube.LinkSchema(0, 1, 2);
            var colCount = 3;
            for (var prop in linkSchema) {
                if (prop != 'source' && prop != 'target')
                    newLinkSchema[prop] = colCount++;
            }
            linkData.shift();
            var linkRow;
            for (var i = 0; i < linkData.length; i++) {
                if (linkData[i].length == 0 || linkData[i][0].length == 0) {
                    continue;
                }
                linkRow = new Array(colCount);
                if (linkSchema.id == undefined)
                    linkRow[0] = linkTable.length;
                else
                    linkRow[0] = linkData[i][linkSchema.id];
                for (var j = 0; j < linkData[i].length; j++) {
                    linkData[i][j] = linkData[i][j].trim();
                }
                name = linkData[i][linkSchema.source];
                if (names.indexOf(name) == -1) {
                    names.push(name);
                }
                id_source = names.indexOf(name);
                name = linkData[i][linkSchema.target];
                if (names.indexOf(name) == -1) {
                    names.push(name);
                }
                id_target = names.indexOf(name);
                linkRow[newLinkSchema.source] = id_source;
                linkRow[newLinkSchema.target] = id_target;
                if (linkSchema.weight != undefined) {
                    linkRow[newLinkSchema.weight] = Number(linkData[i][linkSchema.weight]);
                }
                if (linkSchema.time != undefined) {
                    linkRow[newLinkSchema.time] = moment(linkData[i][linkSchema.time], timeFormat).format(networkcube.timeFormat());
                }
                for (var prop in linkSchema) {
                    if (prop != 'source' && prop != 'target' && prop != 'time' && prop != 'weight') {
                        linkRow[newLinkSchema[prop]] = linkData[i][linkSchema[prop]];
                    }
                }
                linkTable.push(linkRow);
            }
            for (var i = 0; i < names.length; i++) {
                nodeTable.push([i, names[i]]);
            }
            var dataSet = new networkcube.DataSet({
                nodeTable: nodeTable,
                linkTable: linkTable,
                linkSchema: newLinkSchema,
                nodeSchema: nodeSchema,
                name: url
            });
            if (linkSchema.time != undefined) {
                dataSet.timeFormat = networkcube.timeFormat();
            }
            callBack(dataSet);
        }, 'text');
    }
    networkcube.loadLinkTable = loadLinkTable;
    function loadXML(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        d3.xml(url, "application/xml", function (data) {
            console.log('data:', data);
            var nodes = data.documentElement.getElementsByTagName("node");
            var nodeTable = [];
            var nodeIds = [];
            var nodeSchema = { id: 0, label: 1, nodeType: 2 };
            for (var i = 0; i < nodes.length; i++) {
                nodeTable.push([nodeTable.length, nodes[i].getAttribute('name'), nodes[i].getAttribute('type')]);
                nodeIds.push(nodes[i].id);
            }
            var linkTable = [];
            var line = [];
            var link;
            var linkSchema = new networkcube.LinkSchema(0, 1, 2);
            var links = data.documentElement.getElementsByTagName("edge");
            var s, t;
            var sPrev, tPrev;
            for (var i = 0; i < links.length; i++) {
                s = nodeIds.indexOf(links[i].getAttribute('source'));
                t = nodeIds.indexOf(links[i].getAttribute('through'));
                if (sPrev == s && tPrev == t) {
                    continue;
                }
                sPrev = s;
                tPrev = t;
                linkTable.push([linkTable.length, s, t]);
            }
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadXML = loadXML;
    function loadJson(url, callBack, dataName) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        d3.json(url, function (data) {
            if (!data)
                return;
            var links = data.links;
            if (!links)
                links = data.edges;
            if (!links)
                links = data.connections;
            if (!links)
                links = data.relations;
            var linkTable = [];
            var line = [];
            var link;
            var linkSchema = { id: 0, source: 1, target: 2, weight: 3 };
            var weight;
            var linkUserProps = [];
            var prop;
            for (var i = 0; i < links.length; i++) {
                link = links[i];
                for (prop in link) {
                    if (link.hasOwnProperty(prop)
                        && prop != 'id'
                        && prop != 'linkType'
                        && prop != 'time'
                        && prop != 'name'
                        && prop != 'source'
                        && prop != 'target'
                        && prop != 'weight'
                        && prop != 'directed') {
                        if (linkSchema[prop] == undefined) {
                            linkUserProps.push(prop);
                            linkSchema[prop] = 3 + linkUserProps.length;
                        }
                    }
                }
            }
            for (var i = 0; i < links.length; i++) {
                link = links[i];
                weight = 1;
                if (link.weight != undefined)
                    weight = link.weight;
                line = [i, link.source, link.target, weight];
                for (var p = 0; p < linkUserProps.length; p++) {
                    prop = linkUserProps[p];
                    if (link[prop] == undefined) {
                        line.push(undefined);
                    }
                    else {
                        line.push(link[prop]);
                    }
                }
                linkTable.push(line);
            }
            var nodes = data.nodes;
            if (!nodes)
                nodes = data.vertices;
            var node;
            var nodeTable = [];
            var locationTable = [];
            var locationSchema = { id: 0, longitude: 1, latitude: 2 };
            var locationEntry = [];
            var nodeSchema = { id: 0, label: 1 };
            var nodeUserProperties = [];
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                for (prop in node) {
                    if (node.hasOwnProperty(prop)
                        && prop != 'id'
                        && prop != 'label'
                        && prop != 'time'
                        && prop != 'name'
                        && prop != 'nodeType'
                        && prop != 'location'
                        && prop != 'constructor') {
                        if (nodeSchema[prop] == undefined) {
                            console.log('node user-prop found', prop);
                            nodeUserProperties.push(prop);
                            nodeSchema[prop] = 1 + nodeUserProperties.length;
                        }
                    }
                }
            }
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                line = [i];
                if (node.name) {
                    line.push(node.name);
                }
                else if (node.label) {
                    line.push(node.label);
                }
                else {
                    line.push('' + i);
                }
                for (var p = 0; p < nodeUserProperties.length; p++) {
                    prop = nodeUserProperties[p];
                    if (node[prop] == undefined) {
                        line.push(undefined);
                    }
                    else {
                        line.push(node[prop]);
                    }
                }
                nodeTable.push(line);
            }
            if (dataName == undefined)
                dataName = url.split('=')[0];
            callBack(new networkcube.DataSet({
                name: dataName,
                nodeTable: nodeTable,
                locationTable: locationTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                locationSchema: locationSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadJson = loadJson;
    function loadJsonList(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        d3.json(url, function (data) {
            console.log('data:', data);
            if (!data)
                return;
            var linkTable = [];
            var line = [];
            var link;
            var linkSchema = new networkcube.LinkSchema(0, 1, 2);
            var nodes = data;
            var node;
            var nodeTable = [];
            var nodeSchema = new networkcube.NodeSchema(0);
            var nodeNames = [];
            for (var i = 0; i < nodes.length; i++) {
                node = nodes[i];
                line = [i];
                if (node.name) {
                    line.push(node.name);
                    nodeSchema.label = 1;
                }
                if (node.label) {
                    line.push(node.name);
                    nodeSchema.label = 1;
                }
                nodeNames.push(node.name);
                nodeTable.push(line);
            }
            var s, t;
            for (var i = 0; i < nodes.length; i++) {
                for (var j = 0; j < nodes[i].imports.length; j++) {
                    s = nodeNames.indexOf(nodes[i].name);
                    t = nodeNames.indexOf(nodes[i].imports[j]);
                    if (s == -1 || t == -1)
                        console.error('---');
                    else
                        linkTable.push([linkTable.length, s, t]);
                }
            }
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadJsonList = loadJsonList;
    function loadGraphML(url, callBack) {
    }
    function loadTables(url, callBack) {
    }
    function loadNCube(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        d3.json(url, function (data) {
            var nodeTable = [];
            var linkTable = [];
            var nodeSchema = new networkcube.NodeSchema(0);
            nodeSchema.id = 0;
            nodeSchema.label = 1;
            nodeSchema.nodeType = 2;
            for (var i = 0; i < data.nodes.length; i++) {
                console.log('data.nodes[i].name.substring(0,3)', data.nodes[i].name.substring(0, 3));
                nodeTable.push([
                    data.nodes[i].nodeId,
                    data.nodes[i].name,
                    data.nodes[i].name.substring(0, 3)
                ]);
            }
            var linkSchema = new networkcube.LinkSchema(0, 1, 2);
            linkSchema.id = 0;
            linkSchema.source = 1;
            linkSchema.target = 2;
            linkSchema.time = 3;
            linkSchema.weight = 4;
            for (var i = 0; i < data.edges.length; i++) {
                linkTable.push([
                    data.edges[i].edgeId,
                    data.edges[i].sourceNodeId,
                    data.edges[i].targetNodeId,
                    moment().add(data.edges[i].timeIndex, 'seconds').format('YYYY-MM-DD hh:mm:ss'),
                    data.edges[i].weight
                ]);
            }
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadNCube = loadNCube;
    function loadPajek(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        $.get(url, function (data) {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2, directed: 3 };
            var parseType = '';
            var line;
            for (var i = 0; i < lines.length; i++) {
                line = lines[i];
                if (line.indexOf('*Vertices') > -1) {
                    parseType = 'nodes';
                    continue;
                }
                else if (line.indexOf('*Arcs') > -1) {
                    parseType = 'undirectedLinks';
                    continue;
                }
                else if (line.indexOf('*Edges') > -1) {
                    parseType = 'directedLinks';
                    continue;
                }
                line = line.trim();
                line = line.split(' ');
                for (var j = 0; j < line.length; j) {
                    if (line[j].length == 0) {
                        line.splice(j, 1);
                    }
                    else {
                        j++;
                    }
                }
                if (line.length == 0)
                    continue;
                if (parseType.indexOf('nodes') > -1) {
                    nodeTable.push([nodeTable.length, line[1]]);
                }
                else if (parseType.indexOf('undirectedLinks') > -1) {
                    linkTable.push([linkTable.length, parseInt(line[0]) - 1, parseInt(line[1]) - 1, false]);
                }
                else if (parseType.indexOf('directedLinks') > -1) {
                    linkTable.push([linkTable.length, parseInt(line[0]) - 1, parseInt(line[1]) - 1, true]);
                }
            }
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadPajek = loadPajek;
    function loadMat(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        $.get(url, function (data) {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2 };
            var parseType = '';
            var line;
            var rowCount = 0;
            var currRow = 0;
            for (var i = 0; i < lines.length; i++) {
                line = lines[i];
                if (line.indexOf('ROW LABELS') > -1) {
                    parseType = 'rows';
                    continue;
                }
                else if (line.indexOf('COLUMN LABELS') > -1) {
                    parseType = 'cols';
                    continue;
                }
                else if (line.indexOf('DATA:') > -1) {
                    parseType = 'links';
                    continue;
                }
                if (parseType.length == 0)
                    continue;
                line = line.trim();
                line = line.split(' ');
                if (parseType.indexOf('rows') > -1) {
                    nodeTable.push([nodeTable.length, line[0]]);
                    rowCount++;
                }
                else if (parseType.indexOf('cols') > -1) {
                    if (line[0].indexOf(nodeTable[0][1] > -1)) {
                        parseType = '';
                        rowCount = 0;
                        continue;
                    }
                    nodeTable.push([nodeTable.length, line[0]]);
                }
                else if (parseType.indexOf('links') > -1) {
                    for (var j = 0; j < line.length; j++) {
                        if (parseInt(line[j]) == 1) {
                            linkTable.push([linkTable.length, currRow, rowCount + 1]);
                        }
                    }
                    currRow++;
                }
            }
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadMat = loadMat;
    function loadGEDCOM(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        var nodeTable = [];
        var nodeSchema = { id: 0, label: 1, nodeType: 2 };
        var linkTable = [];
        var linkSchema = { id: 0, source: 1, target: 2 };
        var line;
        var s, t;
        $.get(url, function (data) {
            data = data.split('\n');
            var line;
            var currPersonId;
            var personIds = [];
            var personSex = [];
            var familiyIds = [];
            var familiyChildren = [];
            var familiyHusband = [];
            var familiyWife = [];
            for (var i = 0; i < data.length; i++) {
                line = data[i].replace(/@/g, '');
                line = line.split(' ');
                if (line.length < 3)
                    continue;
                if (parseInt(line[0]) == 0 && line[2].indexOf('INDI') > -1) {
                    personIds.push(line[1].trim());
                    personSex.push('');
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('SEX') > -1) {
                    personSex[personSex.length - 1] = line[2].trim();
                }
                else if (parseInt(line[0]) == 0 && line[2].indexOf('FAM') > -1) {
                    familiyIds.push(line[1].trim());
                    familiyChildren.push([]);
                    familiyHusband.push(undefined);
                    familiyWife.push(undefined);
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('CHIL') > -1) {
                    familiyChildren[familiyChildren.length - 1].push(line[2].trim());
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('HUSB') > -1) {
                    familiyHusband[familiyChildren.length - 1] = line[2].trim();
                }
                else if (parseInt(line[0]) == 1 && line[1].indexOf('WIFE') > -1) {
                    familiyWife[familiyChildren.length - 1] = line[2].trim();
                }
            }
            for (var fi = 0; fi < personIds.length; fi++) {
                nodeTable.push([fi, personIds[fi], personSex[fi]]);
            }
            var hi, wi, ci;
            var nodeNames = [];
            for (var fi = 0; fi < familiyIds.length; fi++) {
                hi = personIds.indexOf(familiyHusband[fi]);
                wi = personIds.indexOf(familiyWife[fi]);
                console.log('-->', hi, wi, familiyHusband[fi], familiyWife[fi]);
                for (var i = 0; i < familiyChildren[fi].length; i++) {
                    ci = personIds.indexOf(familiyChildren[fi][i]);
                    if (ci == undefined || ci == -1)
                        continue;
                    if (hi != undefined && hi > -1)
                        linkTable.push([linkTable.length, hi, ci]);
                    if (wi != undefined && wi > -1)
                        linkTable.push([linkTable.length, wi, ci]);
                }
            }
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadGEDCOM = loadGEDCOM;
    function loadLinkList(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        $.get(url, function (data) {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2, weight: 3 };
            var line;
            var s, t;
            for (var i = 0; i < lines.length; i++) {
                line = lines[i];
                if (line.indexOf('#') == -1) {
                    break;
                }
            }
            var DEL = ' ';
            if (lines[i].indexOf(',') > -1)
                DEL = ',';
            else if (lines[i].indexOf('\t') > -1)
                DEL = '\t';
            var nodeLabels = [];
            var weight;
            for (i; i < lines.length; i++) {
                line = lines[i];
                line = line.split(DEL);
                for (var j = 0; j < line.length; j) {
                    if (line[j].length == 0) {
                        line.splice(j, 1);
                    }
                    else {
                        j++;
                    }
                }
                if (line.length < 2)
                    continue;
                s = line[0].toLowerCase();
                if (s == undefined || s == '')
                    continue;
                var si = nodeLabels.indexOf(s);
                if (si == -1) {
                    si = nodeLabels.length;
                    nodeLabels.push(s);
                }
                t = line[1].toLowerCase();
                if (t == undefined)
                    continue;
                t = t.trim();
                var ti = nodeLabels.indexOf(t);
                if (ti == -1) {
                    ti = nodeLabels.length;
                    nodeLabels.push(t);
                }
                weight = 1;
                linkTable.push([linkTable.length, si, ti, weight]);
            }
            for (i = 0; i <= nodeLabels.length; i++) {
                nodeTable.push([i, nodeLabels[i] + '']);
            }
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadLinkList = loadLinkList;
    function loadMatrix(url, callBack) {
        var d;
        var url = url;
        var dataset;
        var callBack = callBack;
        $.get(url, function (data) {
            var lines = data.split('\n');
            var nodeTable = [];
            var nodeSchema = { id: 0, label: 1 };
            var linkTable = [];
            var linkSchema = { id: 0, source: 1, target: 2 };
            var parseType = '';
            var line;
            var rowCount = 0;
            var currRow = 0;
            var nodeNames = [];
            var label;
            var line = lines[0].trim().split(',');
            for (var i = 0; i < line.length; i++) {
                label = line[i].trim();
                nodeTable.push([nodeTable.length, label]);
                nodeNames.push(label);
            }
            var t;
            for (var i = 1; i < lines.length; i++) {
                line = lines[i];
                line = line.trim();
                line = line.split(',');
                t = nodeNames.indexOf(line[0].trim());
                if (t == -1) {
                    console.error('Node', line[0], 'not defined');
                    continue;
                }
                for (var j = 1; j < line.length; j++) {
                    if (line[j].length > 0 && parseInt(line[j].replace(/\s/g, '')) > 300000) {
                        linkTable.push([linkTable.length, t, j - 1]);
                    }
                }
            }
            console.log('---->nodes found:', nodeTable.length);
            console.log('---->links found:', linkTable.length);
            callBack(new networkcube.DataSet({
                name: url.split('=')[0],
                nodeTable: nodeTable,
                linkTable: linkTable,
                nodeSchema: nodeSchema,
                linkSchema: linkSchema
            }));
        });
    }
    networkcube.loadMatrix = loadMatrix;
    function exportCSV(graph) {
        var csv = '';
        var DEL = ',';
        var ST = '';
        var BR = '\n';
        for (var i = 0; i < graph.links().length; i++) {
            csv += ST + graph.link(i).source.id() + ST + DEL
                + ST + graph.link(i).target.id() + ST + BR;
        }
        return csv;
    }
    networkcube.exportCSV = exportCSV;
    function downloadText(text, filename) {
        var textFileAsBlob = new Blob([text], { type: 'text/text' });
        var fileNameToSaveAs = filename;
        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        downloadLink.click();
    }
    networkcube.downloadText = downloadText;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    function searchForTerm(term, dgraph, type) {
        var terms = term.toLowerCase().split(',');
        var result = new networkcube.IDCompound();
        for (var i = 0; i < terms.length; i++) {
            term = terms[i].trim();
            console.log('search term', term);
            if (!type || type == 'node')
                result.nodeIds = result.nodeIds.concat(dgraph.nodes().filter(function (e) {
                    return e.label().toLowerCase().indexOf(term) > -1
                        || e.nodeType().toLowerCase().indexOf(term) > -1;
                }).ids());
            if (!type || type == 'link')
                result.linkIds = result.linkIds.concat(dgraph.links().filter(function (e) {
                    return e.source.label().toLowerCase().indexOf(term) > -1
                        || e.target.label().toLowerCase().indexOf(term) > -1
                        || e.linkType().indexOf(term) > -1;
                }).ids());
            if (!type || type == 'locations')
                result.locationIds = result.locationIds.concat(dgraph.locations().filter(function (e) {
                    return e.label().toLowerCase().indexOf(term) > -1;
                }).ids());
        }
        return result;
    }
    networkcube.searchForTerm = searchForTerm;
    var StringContainsFilter = (function () {
        function StringContainsFilter(pattern) {
            this.pattern = pattern;
        }
        StringContainsFilter.prototype.test = function (word) {
            console.log('contains:', word, this.pattern);
            return word.indexOf(this.pattern) > -1;
        };
        return StringContainsFilter;
    }());
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    networkcube.MESSAGE_HIGHLIGHT = 'highlight';
    networkcube.MESSAGE_SELECTION = 'selection';
    networkcube.MESSAGE_TIME_RANGE = 'timeRange';
    networkcube.MESSAGE_SELECTION_CREATE = 'createSelection';
    networkcube.MESSAGE_SELECTION_DELETE = 'deleteSelection';
    networkcube.MESSAGE_SELECTION_SET_CURRENT = 'setCurrentSelectionId';
    networkcube.MESSAGE_SELECTION_COLORING = 'setSelectionColor';
    networkcube.MESSAGE_SELECTION_SET_COLORING_VISIBILITY = 'selectionColoring';
    networkcube.MESSAGE_SELECTION_FILTER = 'selectionFilter';
    networkcube.MESSAGE_SELECTION_PRIORITY = 'selectionPriority';
    networkcube.MESSAGE_SEARCH_RESULT = 'searchResult';
    var MESSENGER_PROPAGATE = true;
    var MESSAGE_HANDLERS = [
        networkcube.MESSAGE_HIGHLIGHT,
        networkcube.MESSAGE_SELECTION,
        networkcube.MESSAGE_TIME_RANGE,
        networkcube.MESSAGE_SELECTION_CREATE,
        networkcube.MESSAGE_SELECTION_DELETE,
        networkcube.MESSAGE_SELECTION_SET_CURRENT,
        networkcube.MESSAGE_SELECTION_SET_COLORING_VISIBILITY,
        networkcube.MESSAGE_SELECTION_FILTER,
        networkcube.MESSAGE_SELECTION_PRIORITY,
        networkcube.MESSAGE_SEARCH_RESULT,
        networkcube.MESSAGE_SELECTION_COLORING
    ];
    var messageHandlers = [];
    var MessageHandler = (function () {
        function MessageHandler() {
        }
        return MessageHandler;
    }());
    var messageHandler = new MessageHandler();
    var previousMessageId = -1;
    function addEventListener(messageType, handler) {
        console.log('>>> addEventListener', messageType);
        messageHandler[messageType] = handler;
    }
    networkcube.addEventListener = addEventListener;
    function setDefaultEventListener(handler) {
        for (var i = 0; i < MESSAGE_HANDLERS.length; i++) {
            messageHandler[MESSAGE_HANDLERS[i]] = handler;
        }
    }
    networkcube.setDefaultEventListener = setDefaultEventListener;
    window.addEventListener('storage', receiveMessage, false);
    var Message = (function () {
        function Message(type) {
            this.id = Math.random();
            this.type = type;
        }
        return Message;
    }());
    networkcube.Message = Message;
    function sendMessage(type, body) {
        var m = new Message(type);
        m.body = body;
        distributeMessage(m, true);
    }
    networkcube.sendMessage = sendMessage;
    function isEmpty(obj) {
        for (var key in obj) {
            if (obj.hasOwnProperty(key))
                return false;
        }
        return true;
    }
    function highlight(action, elementCompound) {
        var g = networkcube.getDynamicGraph();
        var idCompound = networkcube.makeIdCompound(elementCompound);
        var highlightAnyElement = false;
        if (elementCompound != null && !isEmpty(elementCompound)) {
            highlightAnyElement = true;
        }
        console.log('>>>>' + highlightAnyElement);
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_HIGHLIGHT, highlightAnyElement);
        if (!elementCompound == undefined)
            action = 'reset';
        var m;
        m = new HighlightMessage(action, idCompound);
        distributeMessage(m);
        if (elementCompound && g.currentSelection_id > 0) {
            $('body').css('cursor', 'url(/networkcube/icons/brush.png),auto');
        }
        else {
            $('body').css('cursor', 'auto');
        }
    }
    networkcube.highlight = highlight;
    var HighlightMessage = (function (_super) {
        __extends(HighlightMessage, _super);
        function HighlightMessage(action, idCompound) {
            var _this = _super.call(this, networkcube.MESSAGE_HIGHLIGHT) || this;
            _this.action = action;
            _this.idCompound = idCompound;
            return _this;
        }
        return HighlightMessage;
    }(Message));
    networkcube.HighlightMessage = HighlightMessage;
    function selection(action, compound, selectionId) {
        var g = networkcube.getDynamicGraph();
        if (!selectionId)
            selectionId = g.currentSelection_id;
        var selection = g.getSelection(selectionId);
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION, compound);
        var idCompound = networkcube.makeIdCompound(compound);
        var m = new SelectionMessage(action, idCompound, selectionId);
        distributeMessage(m);
    }
    networkcube.selection = selection;
    var SelectionMessage = (function (_super) {
        __extends(SelectionMessage, _super);
        function SelectionMessage(action, idCompound, selectionId) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION) || this;
            _this.action = action;
            _this.idCompound = idCompound;
            _this.selectionId = selectionId;
            return _this;
        }
        return SelectionMessage;
    }(Message));
    networkcube.SelectionMessage = SelectionMessage;
    function timeRange(startUnix, endUnix, single, propagate) {
        var m = new TimeRangeMessage(startUnix, endUnix);
        if (propagate == undefined)
            propagate = false;
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_TIME_RANGE);
        if (propagate)
            distributeMessage(m);
        else
            processMessage(m);
    }
    networkcube.timeRange = timeRange;
    var TimeRangeMessage = (function (_super) {
        __extends(TimeRangeMessage, _super);
        function TimeRangeMessage(start, end) {
            var _this = _super.call(this, networkcube.MESSAGE_TIME_RANGE) || this;
            _this.startUnix = start;
            _this.endUnix = end;
            return _this;
        }
        return TimeRangeMessage;
    }(Message));
    networkcube.TimeRangeMessage = TimeRangeMessage;
    function createSelection(type, name) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION_CREATE);
        var g = networkcube.getDynamicGraph();
        var b = g.createSelection(type);
        b.name = name;
        var m = new CreateSelectionMessage(b);
        distributeMessage(m, false);
        return b;
    }
    networkcube.createSelection = createSelection;
    var CreateSelectionMessage = (function (_super) {
        __extends(CreateSelectionMessage, _super);
        function CreateSelectionMessage(b) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION_CREATE) || this;
            _this.selection = b;
            return _this;
        }
        return CreateSelectionMessage;
    }(Message));
    networkcube.CreateSelectionMessage = CreateSelectionMessage;
    function setCurrentSelection(b) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION_SET_CURRENT);
        var g = networkcube.getDynamicGraph();
        var m = new SetCurrentSelectionIdMessage(b);
        distributeMessage(m);
    }
    networkcube.setCurrentSelection = setCurrentSelection;
    var SetCurrentSelectionIdMessage = (function (_super) {
        __extends(SetCurrentSelectionIdMessage, _super);
        function SetCurrentSelectionIdMessage(b) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION_SET_CURRENT) || this;
            _this.selectionId = b.id;
            return _this;
        }
        return SetCurrentSelectionIdMessage;
    }(Message));
    networkcube.SetCurrentSelectionIdMessage = SetCurrentSelectionIdMessage;
    function showSelectionColor(selection, showColor) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION_SET_COLORING_VISIBILITY);
        var m = new ShowSelectionColorMessage(selection, showColor);
        distributeMessage(m);
    }
    networkcube.showSelectionColor = showSelectionColor;
    var ShowSelectionColorMessage = (function (_super) {
        __extends(ShowSelectionColorMessage, _super);
        function ShowSelectionColorMessage(selection, showColor) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION_SET_COLORING_VISIBILITY) || this;
            _this.selectionId = selection.id;
            _this.showColor = showColor;
            return _this;
        }
        return ShowSelectionColorMessage;
    }(Message));
    networkcube.ShowSelectionColorMessage = ShowSelectionColorMessage;
    function filterSelection(selection, filter) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION_FILTER);
        var m = new FilterSelectionMessage(selection, filter);
        distributeMessage(m);
    }
    networkcube.filterSelection = filterSelection;
    var FilterSelectionMessage = (function (_super) {
        __extends(FilterSelectionMessage, _super);
        function FilterSelectionMessage(selection, filter) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION_FILTER) || this;
            _this.selectionId = selection.id;
            _this.filter = filter;
            return _this;
        }
        return FilterSelectionMessage;
    }(Message));
    networkcube.FilterSelectionMessage = FilterSelectionMessage;
    function swapPriority(s1, s2) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION_PRIORITY);
        var m = new SelectionPriorityMessage(s1, s2, s2.priority, s1.priority);
        distributeMessage(m);
    }
    networkcube.swapPriority = swapPriority;
    var SelectionPriorityMessage = (function (_super) {
        __extends(SelectionPriorityMessage, _super);
        function SelectionPriorityMessage(s1, s2, p1, p2) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION_PRIORITY) || this;
            _this.selectionId1 = s1.id;
            _this.selectionId2 = s2.id;
            _this.priority1 = p1;
            _this.priority2 = p2;
            return _this;
        }
        return SelectionPriorityMessage;
    }(Message));
    networkcube.SelectionPriorityMessage = SelectionPriorityMessage;
    function deleteSelection(selection) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION_DELETE);
        var m = new DeleteSelectionMessage(selection);
        distributeMessage(m);
    }
    networkcube.deleteSelection = deleteSelection;
    var DeleteSelectionMessage = (function (_super) {
        __extends(DeleteSelectionMessage, _super);
        function DeleteSelectionMessage(selection) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION_DELETE) || this;
            _this.selectionId = selection.id;
            return _this;
        }
        return DeleteSelectionMessage;
    }(Message));
    networkcube.DeleteSelectionMessage = DeleteSelectionMessage;
    function setSelectionColor(s, color) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SELECTION_COLORING);
        distributeMessage(new SelectionColorMessage(s, color));
    }
    networkcube.setSelectionColor = setSelectionColor;
    var SelectionColorMessage = (function (_super) {
        __extends(SelectionColorMessage, _super);
        function SelectionColorMessage(selection, color) {
            var _this = _super.call(this, networkcube.MESSAGE_SELECTION_COLORING) || this;
            _this.selectionId = selection.id;
            _this.color = color;
            return _this;
        }
        return SelectionColorMessage;
    }(Message));
    function search(term, type) {
        trace.event(null, 'toolFunctionUse', networkcube.MESSAGE_SEARCH_RESULT, term);
        var idCompound = networkcube.searchForTerm(term, networkcube.getDynamicGraph(), type);
        distributeMessage(new SearchResultMessage(term, idCompound));
    }
    networkcube.search = search;
    var SearchResultMessage = (function (_super) {
        __extends(SearchResultMessage, _super);
        function SearchResultMessage(searchTerm, idCompound) {
            var _this = _super.call(this, networkcube.MESSAGE_SEARCH_RESULT) || this;
            _this.idCompound = idCompound;
            _this.searchTerm = searchTerm;
            return _this;
        }
        return SearchResultMessage;
    }(Message));
    networkcube.SearchResultMessage = SearchResultMessage;
    var MESSAGE_KEY = 'networkcube_message';
    localStorage[MESSAGE_KEY] = undefined;
    function distributeMessage(message, ownView) {
        if (ownView == undefined || ownView)
            processMessage(message);
        if (MESSENGER_PROPAGATE) {
            localStorage[MESSAGE_KEY] = JSON.stringify(message, function (k, v) { return networkcube.dgraphReplacer(k, v); });
        }
    }
    networkcube.distributeMessage = distributeMessage;
    function receiveMessage() {
        var s = localStorage[MESSAGE_KEY];
        if (s == undefined || s == 'undefined')
            return;
        var dgraph = networkcube.getDynamicGraph();
        var m = JSON.parse(s, function (k, v) { return networkcube.dgraphReviver(dgraph, k, v); });
        if (!m || m.id == previousMessageId) {
            return;
        }
        previousMessageId = m.id;
        processMessage(m);
    }
    function processMessage(m) {
        var graph = networkcube.getDynamicGraph();
        if (messageHandler[m.type]) {
            if (m.type == networkcube.MESSAGE_HIGHLIGHT) {
                var m2 = m;
                graph.highlight(m2.action, m2.idCompound);
            }
            else if (m.type == networkcube.MESSAGE_SELECTION) {
                var m3 = m;
                graph.selection(m3.action, m3.idCompound, m3.selectionId);
            }
            else if (m.type == networkcube.MESSAGE_TIME_RANGE) {
            }
            else if (m.type == networkcube.MESSAGE_SELECTION_SET_COLORING_VISIBILITY) {
                var m4 = m;
                graph.getSelection(m4.selectionId).showColor = m4.showColor;
            }
            else if (m.type == networkcube.MESSAGE_SELECTION_PRIORITY) {
                var m5 = m;
                graph.getSelection(m5.selectionId1).priority = m5.priority1;
                graph.getSelection(m5.selectionId2).priority = m5.priority2;
                var linkElements = graph.links().selected().toArray();
                for (var i = 0; i < linkElements.length; i++) {
                    linkElements[i].getSelections().sort(networkcube.sortByPriority);
                }
                var nodeElements = graph.nodes().selected().toArray();
                for (var i = 0; i < nodeElements.length; i++) {
                    nodeElements[i].getSelections().sort(networkcube.sortByPriority);
                }
                var nodePairElements = graph.nodePairs().selected().toArray();
                for (var i = 0; i < nodePairElements.length; i++) {
                    nodePairElements[i].getSelections().sort(networkcube.sortByPriority);
                }
            }
            else if (m.type == networkcube.MESSAGE_SELECTION_FILTER) {
                var m6 = m;
                graph.filterSelection(m6.selectionId, m6.filter);
            }
            else if (m.type == networkcube.MESSAGE_SELECTION_CREATE) {
                var m7 = m;
                graph.addSelection(m7.selection.id, m7.selection.color, m7.selection.acceptedType, m7.selection.priority);
            }
            else if (m.type == networkcube.MESSAGE_SELECTION_SET_CURRENT) {
                var m8 = m;
                graph.setCurrentSelection(m8.selectionId);
            }
            else if (m.type == networkcube.MESSAGE_SELECTION_DELETE) {
                var m10 = m;
                graph.deleteSelection(m10.selectionId);
            }
            else if (m.type == networkcube.MESSAGE_SEARCH_RESULT) {
                var m11 = m;
                graph.highlight('set', m11.idCompound);
            }
            else if (m.type == networkcube.MESSAGE_SELECTION_COLORING) {
                var m12 = m;
                graph.getSelection(m12.selectionId).color = m12.color;
            }
            callHandler(m);
        }
    }
    function callHandler(message) {
        if (messageHandler[message.type] && messageHandler[message.type] != undefined) {
            messageHandler[message.type](message);
        }
    }
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    function orderNodes(graph, config) {
        var max = 0;
        var similarityMatrix = [];
        var order = graph.nodes().ids();
        var distance = config.distance ? config.distance : science.stats.distance.manhattan;
        var nodes = config.nodes ? config.nodes : graph.nodes().toArray();
        var links = config.links ? config.links : graph.links().toArray();
        var start = config.start ? config.start : graph.startTime;
        var end = config.end ? config.end : graph.endTime;
        var arr;
        for (var i = 0; i < nodes.length; i++) {
            arr = [];
            similarityMatrix.push(arr);
            for (var j = 0; j < nodes.length; j++) {
                similarityMatrix[i].push(0);
            }
        }
        var weight = 0;
        var l;
        var s;
        var t;
        for (var i = 0; i < links.length; i++) {
            weight = 0;
            s = nodes.indexOf(links[i].source);
            t = nodes.indexOf(links[i].target);
            if (s == -1 || t == -1)
                continue;
            weight += links[i].weights(start, end).mean();
            if (weight) {
                similarityMatrix[s][t] = weight;
                similarityMatrix[t][s] = weight;
            }
            else {
                console.log('weight', weight);
            }
        }
        var leafOrder = reorder.leafOrder()
            .distance(distance)(similarityMatrix);
        leafOrder.forEach(function (lo, i) {
            order[nodes[lo].id()] = i;
        });
        return order;
    }
    networkcube.orderNodes = orderNodes;
    var OrderingConfiguration = (function () {
        function OrderingConfiguration() {
        }
        return OrderingConfiguration;
    }());
    networkcube.OrderingConfiguration = OrderingConfiguration;
})(networkcube || (networkcube = {}));
var networkcube;
(function (networkcube) {
    networkcube.TIME_FORMAT = 'YYYY-MM-DD hh:mm:ss';
    function timeFormat() {
        return networkcube.TIME_FORMAT;
    }
    networkcube.timeFormat = timeFormat;
    var dataManager = new networkcube.DataManager();
    var session;
    function getSessionId() {
        return session;
    }
    networkcube.getSessionId = getSessionId;
    function setDataManagerOptions(options) {
        dataManager.setOptions(options);
    }
    networkcube.setDataManagerOptions = setDataManagerOptions;
    function isSessionCached(session, dataSetName) {
        return dataManager.isSessionCached(session, dataSetName);
    }
    networkcube.isSessionCached = isSessionCached;
    function importData(sessionName, data) {
        console.log('[n3] Import data', data.name);
        session = sessionName;
        dataManager.importData(sessionName, data);
    }
    networkcube.importData = importData;
    function clearAllDataManagerSessionCaches() {
        dataManager.clearAllSessionData();
    }
    networkcube.clearAllDataManagerSessionCaches = clearAllDataManagerSessionCaches;
    function getDynamicGraph(dataName, session) {
        var so = setOps;
        uidMethod = so.pushUid(function () {
            return this._id;
        });
        var vars = networkcube.getUrlVars();
        if (!dataName)
            dataName = vars['datasetName'];
        if (!session)
            this.session = vars['session'];
        else
            this.session = session;
        return dataManager.getGraph(this.session, dataName);
    }
    networkcube.getDynamicGraph = getDynamicGraph;
    function openVisualizationWindow(session, visUri, dataName) {
        openView(session, visUri, dataName, false);
    }
    networkcube.openVisualizationWindow = openVisualizationWindow;
    function openVisualizationTab(session, visUri, dataName) {
        openView(session, visUri, dataName, true);
    }
    networkcube.openVisualizationTab = openVisualizationTab;
    function createTabVisualizations(parentId, visSpec, session, dataName, width, height, visParams) {
        var parent = $('#' + parentId);
        var tabDiv = $('<div></div>');
        parent.append(tabDiv);
        var visDiv = $('<div></div>');
        parent.append(visDiv);
        var ul = $('<ul class="networkcube-tabs"\
                style="\
                    list-style-type: none;\
                    margin: 0;\
                    padding:2px;\
                    overflow: hidden;\
                    border: none;\
                    background-color: #f1f1f1;"\
                ></ul>');
        tabDiv.append(ul);
        for (var i = 0; i < visSpec.length; i++) {
            visSpec[i].name = visSpec[i].name.replace(' ', '-');
            ul.append($('<li style="float: left;"><a style="\
                display: inline-block;\
                color: black;\
                margin-right: 8px;\
                margin-left: 8px;\
                padding: 5px;\
                text-align: left;\
                text-decoration: none;\
                transition: 0.3s;\
                font-weight: 800;\
                border: #fff 1px solid;\
                border-raduis: 5px;\
                font-size: 13px;" href="#" class="networkcube-tablinks" onclick="networkcube.switchVisTab(event, \'' + visSpec[i].name + '\')">' + visSpec[i].name + '</a></li>'));
            visDiv.append($('<div id="networkcube-visTab-' + visSpec[i].name + '" style="display:' + (i == 0 ? 'block' : 'none') + ';" class="networkcube-visTabContent"></div>'));
            createVisualizationIFrame('networkcube-visTab-' + visSpec[i].name, visSpec[i].url, session, dataName, width, height, visParams);
        }
    }
    networkcube.createTabVisualizations = createTabVisualizations;
    function switchVisTab(evt, visName) {
        var i, tabcontent, tablinks;
        tabcontent = document.getElementsByClassName("networkcube-visTabContent");
        for (i = 0; i < tabcontent.length; i++) {
            tabcontent[i].style.display = "none";
        }
        tablinks = document.getElementsByClassName("networkcube-tablinks");
        for (i = 0; i < tablinks.length; i++) {
            tablinks[i].className = tablinks[i].className.replace(" active", "");
        }
        document.getElementById('networkcube-visTab-' + visName).style.display = "block";
        evt.currentTarget.className += " active";
    }
    networkcube.switchVisTab = switchVisTab;
    function createVisualizationIFrame(parentId, visUri, session, dataName, width, height, visParams) {
        $('#' + parentId)
            .append('<iframe></iframe>')
            .attr('width', width)
            .attr('height', height);
        var iframe = $('#' + parentId + '> iframe');
        var visParamString = '';
        for (var prop in visParams) {
            visParamString += '&' + prop + '=' + visParams[prop];
        }
        iframe.attr('src', visUri + '?'
            + 'session=' + session
            + '&datasetName=' + dataName
            + visParamString);
        if (width)
            iframe.attr('width', width);
        if (height)
            iframe.attr('height', height);
        if (visParams != undefined && visParams.hasOwnProperty('scrolling')) {
            iframe.attr('scrolling', visParams.scrolling);
        }
        return iframe;
    }
    networkcube.createVisualizationIFrame = createVisualizationIFrame;
    function openView(session, visUri, dataname, tab) {
        var url = visUri + '?session=' + session + '&datasetName=' + dataname;
        if (tab)
            window.open(url, '_blank');
        else
            window.open(url);
    }
    function getURLString(dataName) {
        return '?session=' + session + '&datasetName=' + dataName;
    }
    networkcube.getURLString = getURLString;
    var OrderType;
    (function (OrderType) {
        OrderType[OrderType["Local"] = 0] = "Local";
        OrderType[OrderType["Global"] = 1] = "Global";
        OrderType[OrderType["Data"] = 2] = "Data";
    })(OrderType = networkcube.OrderType || (networkcube.OrderType = {}));
    ;
    function isTrackingEnabled() {
        var value = localStorage.getItem("NETWORKCUBE_IS_TRACKING_ENABLED");
        console.log('>>>>>>>', value);
        return value == 'true' ? true : false;
    }
    networkcube.isTrackingEnabled = isTrackingEnabled;
    function isTrackingSet() {
        var value = localStorage.getItem("NETWORKCUBE_IS_TRACKING_ENABLED");
        return value === null ? false : true;
    }
    networkcube.isTrackingSet = isTrackingSet;
})(networkcube || (networkcube = {}));
var glutils;
(function (glutils) {
    function makeAlphaBuffer(array, stretch) {
        var buffer = new Float32Array(array.length * stretch);
        for (var i = 0; i < array.length; i++) {
            for (var j = 0; j < stretch; j++) {
                buffer[i * stretch + j] = array[i];
            }
        }
        return buffer;
    }
    glutils.makeAlphaBuffer = makeAlphaBuffer;
    function addBufferedHatchedRect(vertexArray, x, y, z, width, height, colorArray, c) {
        var HATCH_NUM = 3;
        var LINE_WIDTH = 1;
        var hatchWidth = width / HATCH_NUM;
        width = width / 2;
        height = height / 2;
        var startX = x + width;
        var startY = y - height;
        for (var i = 1; i <= HATCH_NUM; i++) {
            vertexArray.push([startX - hatchWidth * i, startY, z], [startX - hatchWidth * i + LINE_WIDTH, startY, z], [startX, startY + hatchWidth * i + LINE_WIDTH, z], [startX, startY + hatchWidth * i + LINE_WIDTH, z], [startX, startY + hatchWidth * i, z], [startX - hatchWidth * i, startY, z]);
            colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
        }
    }
    glutils.addBufferedHatchedRect = addBufferedHatchedRect;
    function addBufferedRect(vertexArray, x, y, z, width, height, colorArray, c) {
        width = width / 2;
        height = height / 2;
        vertexArray.push([x - width, y - height, z], [x + width, y - height, z], [x + width, y + height, z], [x + width, y + height, z], [x - width, y + height, z], [x - width, y - height, z]);
        colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
    }
    glutils.addBufferedRect = addBufferedRect;
    function addBufferedCirlce(vertexArray, x, y, z, radius, colorArray, c) {
        var segments = 11;
        var angle = Math.PI / (segments / 2);
        for (var i = 0; i < segments; i++) {
            vertexArray.push([x + Math.cos(i * angle) * radius, y + Math.sin(i * angle) * radius, z], [x + Math.cos((i + 1) * angle) * radius, y + Math.sin((i + 1) * angle) * radius, z], [x, y, z]);
            colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
        }
    }
    glutils.addBufferedCirlce = addBufferedCirlce;
    function addBufferedDiamond(vertexArray, x, y, z, width, height, colorArray, c) {
        width = width / 2;
        height = height / 2;
        vertexArray.push([x - width, y, z], [x, y - height, z], [x + width, y, z], [x + width, y, z], [x, y + height, z], [x - width, y, z]);
        colorArray.push([c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]], [c[0], c[1], c[2], c[3]]);
    }
    glutils.addBufferedDiamond = addBufferedDiamond;
    function createRectFrame(w, h, color, lineThickness) {
        w = w / 2;
        h = h / 2;
        var geom = new THREE.Geometry();
        geom.vertices = [
            new THREE.Vector3(-w, -h, 0),
            new THREE.Vector3(-w, h, 0),
            new THREE.Vector3(w, h, 0),
            new THREE.Vector3(w, -h, 0),
            new THREE.Vector3(-w, -h, 0)
        ];
        var material = new THREE.LineBasicMaterial({
            color: color,
        });
        return new THREE.Line(geom, material);
    }
    glutils.createRectFrame = createRectFrame;
    function createDiagonalCross(w, h, color, lineThickness) {
        w = w / 2;
        h = h / 2;
        var geom = new THREE.Geometry();
        geom.vertices = [
            new THREE.Vector3(-w, -h, 0),
            new THREE.Vector3(-w, h, 0),
            new THREE.Vector3(w, h, 0),
            new THREE.Vector3(w, -h, 0),
            new THREE.Vector3(-w, -h, 0),
            new THREE.Vector3(w, h, 0),
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(-w, h, 0),
            new THREE.Vector3(w, -h, 0)
        ];
        var material = new THREE.LineBasicMaterial({
            color: color,
            linewidth: lineThickness,
        });
        return new THREE.Line(geom, material);
    }
    glutils.createDiagonalCross = createDiagonalCross;
    function makeBuffer3f(array) {
        var buffer = new Float32Array(array.length * 3);
        for (var i = 0; i < array.length; i++) {
            buffer[i * 3 + 0] = array[i][0];
            buffer[i * 3 + 1] = array[i][1];
            buffer[i * 3 + 2] = array[i][2];
        }
        return buffer;
    }
    glutils.makeBuffer3f = makeBuffer3f;
    function makeBuffer4f(array) {
        var buffer = new Float32Array(array.length * 4);
        for (var i = 0; i < array.length; i++) {
            buffer[i * 4 + 0] = array[i][0];
            buffer[i * 4 + 1] = array[i][1];
            buffer[i * 4 + 2] = array[i][2];
            buffer[i * 4 + 3] = array[i][3];
        }
        return buffer;
    }
    glutils.makeBuffer4f = makeBuffer4f;
    function updateBuffer(buffer, array, size) {
        for (var i = 0; i < array.length; i++) {
            for (var j = 0; j < size; j++) {
                buffer[i * size + j] = array[i][j];
            }
        }
    }
    glutils.updateBuffer = updateBuffer;
    function createText(string, x, y, z, size, color, weight, align) {
        if (weight === void 0) { weight = 'normal'; }
        if (align === void 0) { align = 'left'; }
        var textGeom = new THREE.TextGeometry(string, {
            size: size,
            height: 1,
            weight: weight,
            curveSegments: 1,
            font: 'helvetiker'
        });
        var textMaterial = new THREE.MeshBasicMaterial({ color: color });
        var label = new THREE.Mesh(textGeom, textMaterial);
        if (align == 'right') {
            label.geometry.computeBoundingBox();
            var bounds = label.geometry.boundingBox;
            x -= bounds.max.x - bounds.min.x;
        }
        label.position.set(x, y, z);
        return label;
    }
    glutils.createText = createText;
    function getMousePos(canvas, x, y) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: x - rect.left,
            y: y - rect.top
        };
    }
    glutils.getMousePos = getMousePos;
    var txtCanvas = document.createElement("canvas");
    var WebGL = (function () {
        function WebGL(params) {
            this.elementQueries = [];
            txtCanvas = document.createElement("canvas");
            txtCanvas.setAttribute('id', 'textCanvas');
        }
        WebGL.prototype.render = function () {
            for (var i = 0; i < this.elementQueries.length; i++) {
                if (this.elementQueries[i].updateAttributes || this.elementQueries[i].updateStyle) {
                    this.elementQueries[i].set();
                }
            }
            this.renderer.render(this.scene, this.camera);
        };
        WebGL.prototype.selectAll = function () {
            return glutils.selectAll();
        };
        WebGL.prototype.enableZoom = function (b) {
            if (b) {
                window.addEventListener("mousewheel", mouseWheel, false);
                function mouseWheel(event) {
                    event.preventDefault();
                    webgl.camera.zoom += event.wheelDelta / 1000;
                    webgl.camera.zoom = Math.max(0.1, webgl.camera.zoom);
                    webgl.camera.updateProjectionMatrix();
                    webgl.render();
                }
            }
            else {
                window.addEventListener("mousewheel", mouseWheel, false);
            }
        };
        WebGL.prototype.enablePanning = function (b) {
            this.interactor.isPanEnabled = b;
        };
        WebGL.prototype.enableHorizontalPanning = function (b) {
            this.interactor.isHorizontalPanEnabled = b;
        };
        return WebGL;
    }());
    glutils.WebGL = WebGL;
    var webgl;
    function initWebGL(parentId, width, height, params) {
        webgl = new WebGL(params);
        webgl.camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 0, 1000);
        webgl.scene = new THREE.Scene();
        webgl.scene.add(webgl.camera);
        webgl.camera.position.z = 100;
        webgl.renderer = new THREE.WebGLRenderer({
            antialias: true,
            preserveDrawingBuffer: true
        });
        webgl.renderer.setSize(width, height);
        webgl.renderer.setClearColor(0xffffff, 1);
        webgl.canvas = webgl.renderer.domElement;
        $("#" + parentId).append(webgl.canvas);
        webgl.interactor = new WebGLInteractor(webgl.scene, webgl.canvas, webgl.camera);
        var light = new THREE.PointLight(0x000000, 1, 100);
        light.position.set(0, 0, 1000);
        webgl.scene.add(light);
        return webgl;
    }
    glutils.initWebGL = initWebGL;
    function setWebGL(scene, camera, renderer, canvas) {
        webgl = new WebGL();
        webgl.camera = camera;
        webgl.scene = scene;
        webgl.renderer = renderer;
    }
    glutils.setWebGL = setWebGL;
    function selectAll() {
        var q = new glutils.WebGLElementQuery();
        webgl.elementQueries.push(q);
        return q;
    }
    glutils.selectAll = selectAll;
    var WebGLElementQuery = (function () {
        function WebGLElementQuery() {
            this.dataElements = [];
            this.visualElements = [];
            this.children = [];
            this.x = [];
            this.y = [];
            this.z = [];
            this.r = [];
            this.fill = [];
            this.stroke = [];
            this.strokewidth = [];
            this.opacity = [];
            this.updateAttributes = false;
            this.updateStyle = false;
            this.IS_SHADER = false;
            this.scene = webgl.scene;
        }
        WebGLElementQuery.prototype.data = function (arr) {
            this.dataElements = arr.slice(0);
            return this;
        };
        WebGLElementQuery.prototype.append = function (shape) {
            var elements = [];
            switch (shape) {
                case 'circle':
                    createCirclesWithBuffers(this, this.scene);
                    break;
                case 'path':
                    elements = createPaths(this.dataElements, this.scene);
                    break;
                case 'line':
                    elements = createLines(this.dataElements, this.scene);
                    break;
                case 'rect':
                    elements = createRectangles(this.dataElements, this.scene);
                    break;
                case 'text':
                    elements = createWebGLText(this.dataElements, this.scene);
                    break;
                case 'polygon':
                    elements = createPolygons(this.dataElements, this.scene);
                    break;
                default: console.error('Shape', shape, 'does not exist.');
            }
            if (!this.IS_SHADER) {
                for (var i = 0; i < elements.length; i++) {
                    this.x.push(0);
                    this.y.push(0);
                    this.z.push(0);
                }
            }
            this.shape = shape;
            this.visualElements = elements;
            return this;
        };
        WebGLElementQuery.prototype.push = function (e) {
            this.dataElements.push(e);
            return this;
        };
        WebGLElementQuery.prototype.getData = function (i) {
            return this.dataElements[this.visualElements.indexOf(i)];
        };
        WebGLElementQuery.prototype.getVisual = function (i) {
            return this.visualElements[this.dataElements.indexOf(i)];
        };
        Object.defineProperty(WebGLElementQuery.prototype, "length", {
            get: function () {
                return this.dataElements.length;
            },
            enumerable: true,
            configurable: true
        });
        WebGLElementQuery.prototype.filter = function (f) {
            var arr = [];
            var visArr = [];
            for (var i = 0; i < this.dataElements.length; i++) {
                if (f(this.dataElements[i], i)) {
                    arr.push(this.dataElements[i]);
                    visArr.push(this.visualElements[i]);
                }
            }
            var q = new WebGLElementQuery()
                .data(arr);
            q.visualElements = visArr;
            return q;
        };
        WebGLElementQuery.prototype.attr = function (name, v) {
            var l = this.visualElements.length;
            if (this.IS_SHADER) {
                for (var i = 0; i < this.dataElements.length; i++) {
                    this[name][i] = v instanceof Function ? v(this.dataElements[i], i) : v;
                }
            }
            else {
                for (var i = 0; i < l; i++) {
                    this.setAttr(this.visualElements[i], name, v instanceof Function ? v(this.dataElements[i], i) : v, i);
                    if (this.visualElements[i].hasOwnProperty('wireframe')) {
                        this.setAttr(this.visualElements[i].wireframe, name, v instanceof Function ? v(this.dataElements[i], i) : v, i);
                    }
                }
            }
            this.updateAttributes = true;
            return this;
        };
        WebGLElementQuery.prototype.style = function (name, v) {
            var l = this.visualElements.length;
            if (this.IS_SHADER) {
                name = name.replace('-', '');
                for (var i = 0; i < this.dataElements.length; i++) {
                    this[name][i] = v instanceof Function ? v(this.dataElements[i], i) : v;
                }
            }
            else {
                for (var i = 0; i < l; i++) {
                    setStyle(this.visualElements[i], name, v instanceof Function ? v(this.dataElements[i], i) : v, this);
                }
            }
            this.updateStyle = true;
            return this;
        };
        WebGLElementQuery.prototype.set = function () {
            if (!this.IS_SHADER)
                return this;
            var l = this.visualElements.length;
            var vertexPositionBuffer = [];
            var vertexColorBuffer = [];
            var c;
            if (this.shape == 'circle') {
                for (var i = 0; i < this.dataElements.length; i++) {
                    c = new THREE.Color(this.fill[i]);
                    addBufferedCirlce(vertexPositionBuffer, this.x[i], this.y[i], this.z[i], this.r[i], vertexColorBuffer, [c.r, c.g, c.b, this.opacity[i]]);
                }
            }
            var geometry = this.mesh.geometry;
            geometry.addAttribute('position', new THREE.BufferAttribute(makeBuffer3f(vertexPositionBuffer), 3));
            geometry.addAttribute('customColor', new THREE.BufferAttribute(makeBuffer4f(vertexColorBuffer), 4));
            geometry.needsUpdate = true;
            geometry.verticesNeedUpdate = true;
            this.mesh.material.needsUpdate = true;
            this.updateAttributes = false;
            this.updateStyle = false;
            return this;
        };
        WebGLElementQuery.prototype.text = function (v) {
            var l = this.visualElements.length;
            for (var i = 0; i < l; i++) {
                this.visualElements[i]['text'] = v instanceof Function ? v(this.dataElements[i], i) : v;
                if (this.visualElements[i]['text'] == undefined)
                    continue;
                setText(this.visualElements[i], this.visualElements[i]['text']);
            }
            return this;
        };
        WebGLElementQuery.prototype.on = function (event, f) {
            switch (event) {
                case 'mouseover':
                    this.mouseOverHandler = f;
                    break;
                case 'mousemove':
                    this.mouseMoveHandler = f;
                    break;
                case 'mouseout':
                    this.mouseOutHandler = f;
                    break;
                case 'mousedown':
                    this.mouseDownHandler = f;
                    break;
                case 'mouseup':
                    this.mouseUpHandler = f;
                    break;
                case 'click':
                    this.clickHandler = f;
                    break;
            }
            webgl.interactor.register(this, event);
            return this;
        };
        WebGLElementQuery.prototype.call = function (method, dataElement, event) {
            var i = this.dataElements.indexOf(dataElement);
            switch (method) {
                case 'mouseover':
                    this.mouseOverHandler(dataElement, i, event);
                    break;
                case 'mousemove':
                    this.mouseMoveHandler(dataElement, i, event);
                    break;
                case 'mouseout':
                    this.mouseOutHandler(dataElement, i, event);
                    break;
                case 'mousedown':
                    this.mouseDownHandler(dataElement, i, event);
                    break;
                case 'mouseup':
                    this.mouseUpHandler(dataElement, i, event);
                    break;
                case 'click':
                    this.clickHandler(dataElement, i, event);
                    break;
            }
            return this;
        };
        WebGLElementQuery.prototype.setAttr = function (element, attr, v, index) {
            switch (attr) {
                case 'x':
                    element.position.x = v;
                    this.x[index] = v;
                    break;
                case 'y':
                    element.position.y = v;
                    this.y[index] = v;
                    break;
                case 'z':
                    element.position.z = v;
                    this.z[index] = v;
                    break;
                case 'x1':
                    setX1(element, v);
                    break;
                case 'y1':
                    setY1(element, v);
                    break;
                case 'x2':
                    setX2(element, v);
                    break;
                case 'y2':
                    setY2(element, v);
                    break;
                case 'r':
                    element.scale.set(v, v, v);
                    break;
                case 'width':
                    element.scale.setX(v);
                    break;
                case 'height':
                    element.scale.setY(v);
                    break;
                case 'depth':
                    element.scale.setZ(v);
                    break;
                case 'd':
                    createPath(element, v);
                    break;
                case 'points':
                    createPolygon(element, v);
                    break;
                case 'rotation':
                    element.rotation.z = v * Math.PI / 180;
                    break;
                case 'scaleX':
                    element.scale.x = v;
                    break;
                case 'scaleY':
                    element.scale.y = v;
                    break;
                default: console.error('Attribute', attr, 'does not exist.');
            }
            element.geometry.verticesNeedUpdate = true;
            element.geometry.elementsNeedUpdate = true;
            element.geometry.lineDistancesNeedUpdate = true;
        };
        WebGLElementQuery.prototype.removeAll = function () {
            for (var i = 0; i < this.visualElements.length; i++) {
                if (this.visualElements[i].wireframe)
                    this.scene.remove(this.visualElements[i].wireframe);
                this.scene.remove(this.visualElements[i]);
            }
        };
        return WebGLElementQuery;
    }());
    glutils.WebGLElementQuery = WebGLElementQuery;
    function setStyle(element, attr, v, query) {
        switch (attr) {
            case 'fill':
                if (query.shape == 'text')
                    setText(element, element['text'], { color: v });
                else
                    element.material.color = new THREE.Color(v);
                break;
            case 'stroke':
                if (element.hasOwnProperty('wireframe')) {
                    element.wireframe.material.color = new THREE.Color(v);
                }
                else {
                    element.material.color = new THREE.Color(v);
                }
                break;
            case 'opacity':
                element.material.opacity = v;
                if (element.hasOwnProperty('wireframe'))
                    element.wireframe.material.opacity = v;
                break;
            case 'stroke-width':
                if (element.hasOwnProperty('wireframe'))
                    element.wireframe.material.linewidth = v;
                else
                    element.material.linewidth = v;
                break;
            case 'font-size':
                element.scale.x = v / 30;
                element.scale.y = v / 30;
                element.geometry.verticesNeedUpdate = true;
                break;
            default: console.error('Style', attr, 'does not exist.');
        }
        element.material.needsUpdate = true;
        if (element.hasOwnProperty('wireframe'))
            element.wireframe.material.needsUpdate = true;
    }
    function setText(mesh, text, parConfig) {
        var config = parConfig;
        if (config == undefined) {
            config = {};
        }
        if (config.color == undefined)
            config.color = '#000000';
        mesh['text'] = text;
        var backgroundMargin = 10;
        var txtCanvas = document.createElement("canvas");
        var context = txtCanvas.getContext("2d");
        var SIZE = 30;
        context.font = SIZE + "pt Helvetica";
        var WIDTH = context.measureText(text).width;
        txtCanvas.width = WIDTH;
        txtCanvas.height = SIZE;
        context.textAlign = "left";
        context.textBaseline = "middle";
        context.fillStyle = config.color;
        context.font = SIZE + "pt Helvetica";
        context.fillText(text, 0, txtCanvas.height / 2);
        var tex = new THREE.Texture(txtCanvas);
        tex.minFilter = THREE.LinearFilter;
        tex.flipY = true;
        tex.needsUpdate = true;
        mesh.material.map = tex;
        mesh.material.transparent = true;
        mesh.material.needsUpdate = true;
        mesh.geometry = new THREE.PlaneGeometry(WIDTH, SIZE);
        mesh.geometry.needsUpdate = true;
        mesh.geometry.verticesNeedUpdate = true;
        mesh.needsUpdate = true;
    }
    function setX1(mesh, v) {
        mesh.geometry.vertices[0].x = v;
    }
    function setY1(mesh, v) {
        mesh.geometry.vertices[0].y = v;
    }
    function setX2(mesh, v) {
        mesh.geometry.vertices[1].x = v;
    }
    function setY2(mesh, v) {
        mesh.geometry.vertices[1].y = v;
    }
    function createG(dataElements, scene) {
        var visualElements = [];
        for (var i = 0; i < dataElements.length; i++) {
            visualElements.push(new GroupElement());
        }
        return visualElements;
    }
    var GroupElement = (function () {
        function GroupElement() {
            this.position = { x: 0, y: 0, z: 0 };
            this.children = [];
        }
        return GroupElement;
    }());
    function createCirclesNoShader(dataElements, scene) {
        var material;
        var geometry;
        var visualElements = [];
        var c;
        for (var i = 0; i < dataElements.length; i++) {
            material = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true });
            geometry = new THREE.CircleGeometry(1, 10);
            geometry.dynamic = true;
            c = new THREE.Mesh(geometry, material);
            visualElements.push(c);
            c.position.set(0, 0, 1);
            c.scale.set(10, 10, 1);
            scene.add(c);
        }
        return visualElements;
    }
    var vertexShaderProgram = "\
        attribute vec4 customColor;\
        varying vec4 vColor;\
        void main() {\
            vColor = customColor;\
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1 );\
        }";
    var fragmentShaderProgram = "\
        varying vec4 vColor;\
        void main() {\
            gl_FragColor = vec4(vColor[0], vColor[1], vColor[2], vColor[3]);\
        }";
    function createCirclesWithBuffers(query, scene) {
        var dataElements = query.dataElements;
        query.IS_SHADER = true;
        var attributes = {
            customColor: { type: 'c', value: [] }
        };
        var shaderMaterial = new THREE.ShaderMaterial({
            attributes: attributes,
            vertexShader: vertexShaderProgram,
            fragmentShader: fragmentShaderProgram,
            linewidth: 2
        });
        shaderMaterial.blending = THREE.NormalBlending;
        shaderMaterial.depthTest = true;
        shaderMaterial.transparent = true;
        shaderMaterial.side = THREE.DoubleSide;
        var visualElements = [];
        var c;
        var vertexPositionBuffer = [];
        var vertexColorBuffer = [];
        var geometry = new THREE.BufferGeometry();
        addBufferedRect([], 0, 0, 0, 10, 10, [], [0, 0, 1, .5]);
        for (var i = 0; i < dataElements.length; i++) {
            query.x.push(0);
            query.y.push(0);
            query.z.push(0);
            query.r.push(0);
            query.fill.push('0x000000');
            query.stroke.push('0x000000');
            query.strokewidth.push(1);
            query.opacity.push(1);
        }
        geometry.addAttribute('position', new THREE.BufferAttribute(makeBuffer3f([]), 3));
        geometry.addAttribute('customColor', new THREE.BufferAttribute(makeBuffer4f([]), 4));
        query.mesh = new THREE.Mesh(geometry, shaderMaterial);
        query.mesh.position.set(0, 0, 1);
        scene.add(query.mesh);
        return query;
    }
    function createRectangles(dataElements, scene) {
        var material;
        var geometry;
        var visualElements = [];
        var c;
        for (var i = 0; i < dataElements.length; i++) {
            var rectShape = new THREE.Shape();
            rectShape.moveTo(0, 0);
            rectShape.lineTo(0, -1);
            rectShape.lineTo(1, -1);
            rectShape.lineTo(1, 0);
            rectShape.lineTo(0, 0);
            geometry = new THREE.ShapeGeometry(rectShape);
            c = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true }));
            c.position.set(0, 0, 1);
            visualElements.push(c);
            scene.add(c);
            geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, -1, 0), new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0));
            var wireframe = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, linewidth: 1 }));
            c['wireframe'] = wireframe;
            wireframe.position.set(0, 0, 1.1);
            scene.add(wireframe);
        }
        return visualElements;
    }
    function createPaths(dataElements, scene) {
        var material;
        var geometry;
        var visualElements = [];
        var c, p;
        for (var i = 0; i < dataElements.length; i++) {
            geometry = new THREE.Geometry();
            c = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true }));
            c.position.set(0, 0, 0);
            visualElements.push(c);
            scene.add(c);
        }
        return visualElements;
    }
    function createPolygons(dataElements, scene) {
        var material;
        var geometry;
        var visualElements = [];
        var c, p;
        for (var i = 0; i < dataElements.length; i++) {
            geometry = new THREE.Geometry();
            c = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, side: THREE.DoubleSide }));
            c.doubleSided = true;
            c.position.set(0, 0, 0);
            visualElements.push(c);
            scene.add(c);
        }
        return visualElements;
    }
    function createLines(dataElements, scene) {
        var material;
        var geometry;
        var visualElements = [];
        var c, p;
        for (var i = 0; i < dataElements.length; i++) {
            geometry = new THREE.Geometry();
            geometry.vertices.push(new THREE.Vector3(-10, 0, 0), new THREE.Vector3(0, 10, 0));
            c = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0x000000, transparent: true }));
            c.position.set(0, 0, 0);
            visualElements.push(c);
            scene.add(c);
        }
        return visualElements;
    }
    function createWebGLText(dataElements, scene) {
        var visualElements = [];
        var mesh;
        for (var i = 0; i < dataElements.length; i++) {
            mesh = new THREE.Mesh(new THREE.PlaneGeometry(1000, 100), new THREE.MeshBasicMaterial());
            mesh.doubleSided = true;
            visualElements.push(mesh);
            scene.add(mesh);
        }
        return visualElements;
    }
    function createPath(mesh, points) {
        mesh.geometry.vertices = [];
        for (var i = 0; i < points.length; i++) {
            mesh.geometry.vertices.push(new THREE.Vector3(points[i].x, points[i].y, 0));
        }
        mesh.geometry.verticesNeedUpdate = true;
    }
    function createPolygon(mesh, points) {
        var vectors = [];
        var shape = new THREE.Shape(points);
        mesh.geometry = new THREE.ShapeGeometry(shape);
        mesh.geometry.verticesNeedUpdate = true;
    }
    var WebGLInteractor = (function () {
        function WebGLInteractor(scene, canvas, camera) {
            var _this = this;
            this.mouse = [];
            this.mouseStart = [];
            this.mouseDown = false;
            this.cameraStart = [];
            this.panOffset = [];
            this.lastIntersectedSelections = [];
            this.lastIntersectedElements = [];
            this.isPanEnabled = true;
            this.isHorizontalPanEnabled = true;
            this.isLassoEnabled = true;
            this.lassoPoints = [];
            this.mouseOverSelections = [];
            this.mouseMoveSelections = [];
            this.mouseOutSelections = [];
            this.mouseDownSelections = [];
            this.mouseUpSelections = [];
            this.clickSelections = [];
            this.scene = scene;
            this.canvas = canvas;
            this.camera = camera;
            this.mouse = [0, 0];
            canvas.addEventListener('mousemove', function (e) {
                _this.mouseMoveHandler(e);
            });
            canvas.addEventListener('mousedown', function (e) {
                _this.mouseDownHandler(e);
            });
            canvas.addEventListener('mouseup', function (e) {
                _this.mouseUpHandler(e);
            });
            canvas.addEventListener('click', function (e) {
                _this.clickHandler(e);
            });
        }
        WebGLInteractor.prototype.register = function (selection, method) {
            switch (method) {
                case 'mouseover':
                    this.mouseOverSelections.push(selection);
                    break;
                case 'mousemove':
                    this.mouseMoveSelections.push(selection);
                    break;
                case 'mouseout':
                    this.mouseOutSelections.push(selection);
                    break;
                case 'mousedown':
                    this.mouseDownSelections.push(selection);
                    break;
                case 'mouseup':
                    this.mouseUpSelections.push(selection);
                    break;
                case 'click':
                    this.clickSelections.push(selection);
                    break;
            }
        };
        WebGLInteractor.prototype.addEventListener = function (eventName, f) {
            if (eventName == 'lassoStart')
                this.lassoStartHandler = f;
            if (eventName == 'lassoEnd')
                this.lassoEndHandler = f;
            if (eventName == 'lassoMove')
                this.lassoMoveHandler = f;
        };
        WebGLInteractor.prototype.mouseMoveHandler = function (e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            if (this.isLassoEnabled && e.which == 2) {
                this.lassoPoints.push(this.mouse);
                if (this.lassoMoveHandler)
                    this.lassoMoveHandler(this.lassoPoints);
            }
            else {
                var intersectedVisualElements = [];
                for (var i = 0; i < this.lastIntersectedSelections.length; i++) {
                    for (var j = 0; j < this.lastIntersectedElements[i].length; j++) {
                        this.lastIntersectedSelections[i].call('mouseout', this.lastIntersectedElements[i][j]);
                    }
                }
                this.lastIntersectedSelections = [];
                this.lastIntersectedElements = [];
                var nothingIntersected = true;
                for (var i = 0; i < this.mouseOverSelections.length; i++) {
                    intersectedVisualElements = this.intersect(this.mouseOverSelections[i], this.mouse[0], this.mouse[1]);
                    if (intersectedVisualElements.length > 0) {
                        this.lastIntersectedElements.push(intersectedVisualElements);
                        this.lastIntersectedSelections.push(this.mouseOverSelections[i]);
                    }
                    for (var j = 0; j < intersectedVisualElements.length; j++) {
                        this.mouseOverSelections[i].call('mouseover', intersectedVisualElements[j], e);
                    }
                    if (intersectedVisualElements.length > 0)
                        nothingIntersected = false;
                }
                for (var i = 0; i < this.mouseMoveSelections.length; i++) {
                    intersectedVisualElements = this.intersect(this.mouseMoveSelections[i], this.mouse[0], this.mouse[1]);
                    for (var j = 0; j < intersectedVisualElements.length; j++) {
                        this.mouseMoveSelections[i].call('mousemove', intersectedVisualElements[j], e);
                    }
                    if (intersectedVisualElements.length > 0)
                        nothingIntersected = false;
                }
                if (nothingIntersected && this.mouseDown) {
                    if (this.isPanEnabled) {
                        this.panOffset = [e.clientX - this.mouseStart[0], e.clientY - this.mouseStart[1]];
                        if (this.isHorizontalPanEnabled)
                            webgl.camera.position.x = this.cameraStart[0] - this.panOffset[0] / webgl.camera.zoom;
                        webgl.camera.position.y = this.cameraStart[1] + this.panOffset[1] / webgl.camera.zoom;
                        webgl.render();
                    }
                }
            }
        };
        WebGLInteractor.prototype.clickHandler = function (e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            var intersectedVisualElements = [];
            for (var i = 0; i < this.clickSelections.length; i++) {
                intersectedVisualElements = this.intersect(this.clickSelections[i], this.mouse[0], this.mouse[1]);
                for (var j = 0; j < intersectedVisualElements.length; j++) {
                    this.clickSelections[i].call('click', intersectedVisualElements[j], e);
                }
            }
            this.mouseDown = false;
        };
        WebGLInteractor.prototype.mouseDownHandler = function (e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            this.mouseStart = [e.clientX, e.clientY];
            this.cameraStart = [webgl.camera.position.x, webgl.camera.position.y];
            this.mouseDown = true;
            var intersectedVisualElements = [];
            for (var i = 0; i < this.mouseDownSelections.length; i++) {
                intersectedVisualElements = this.intersect(this.mouseDownSelections[i], this.mouse[0], this.mouse[1]);
                for (var j = 0; j < intersectedVisualElements.length; j++) {
                    this.mouseDownSelections[i].call('mousedown', intersectedVisualElements[j], e);
                }
            }
            this.lassoPoints = [];
            this.lassoPoints.push(this.mouse);
            if (this.lassoStartHandler && e.which == 2) {
                this.lassoStartHandler(this.lassoPoints);
            }
        };
        WebGLInteractor.prototype.mouseUpHandler = function (e) {
            this.mouse = mouseToWorldCoordinates(e.clientX, e.clientY);
            var intersectedVisualElements = [];
            for (var i = 0; i < this.mouseUpSelections.length; i++) {
                intersectedVisualElements = this.intersect(this.mouseUpSelections[i], this.mouse[0], this.mouse[1]);
                for (var j = 0; j < intersectedVisualElements.length; j++) {
                    this.mouseUpSelections[i].call('mouseup', intersectedVisualElements[j], e);
                }
            }
            this.mouseDown = false;
            if (this.lassoEndHandler && e.which == 2) {
                this.lassoEndHandler(this.lassoPoints);
            }
        };
        WebGLInteractor.prototype.intersect = function (selection, mousex, mousey) {
            switch (selection.shape) {
                case 'circle':
                    return this.intersectCircles(selection);
                    break;
                case 'rect':
                    return this.intersectRects(selection);
                    break;
                case 'path':
                    return this.intersectPaths(selection);
                    break;
                case 'text':
                    return this.intersectRects(selection);
                    break;
            }
            return [];
        };
        WebGLInteractor.prototype.intersectCircles = function (selection) {
            var intersectedElements = [];
            var d;
            for (var i = 0; i < selection.dataElements.length; i++) {
                d = Math.sqrt(Math.pow(this.mouse[0] - selection.x[i], 2) + Math.pow(this.mouse[1] - selection.y[i], 2));
                if (d <= selection.r[i])
                    intersectedElements.push(selection.dataElements[i]);
            }
            return intersectedElements;
        };
        WebGLInteractor.prototype.intersectRects = function (selection) {
            var intersectedElements = [];
            var d;
            var e;
            for (var i = 0; i < selection.visualElements.length; i++) {
                e = selection.visualElements[i];
                if (this.mouse[0] >= e.position.x && this.mouse[0] <= e.position.x + e.geometry.vertices[0].x * e.scale.x
                    && this.mouse[1] <= e.position.y && this.mouse[1] >= e.position.y + e.geometry.vertices[1].y * e.scale.y)
                    intersectedElements.push(selection.dataElements[i]);
            }
            return intersectedElements;
        };
        WebGLInteractor.prototype.intersectPaths = function (selection) {
            var intersectedElements = [];
            var e;
            var v1, v2;
            var x, y;
            var found = false;
            for (var i = 0; i < selection.visualElements.length; i++) {
                e = selection.visualElements[i];
                for (var j = 1; j < e.geometry.vertices.length; j++) {
                    v1 = e.geometry.vertices[j - 1];
                    v1 = { x: v1.x + selection.x[i],
                        y: v1.y + selection.y[i]
                    };
                    v2 = e.geometry.vertices[j];
                    v2 = { x: v2.x + selection.x[i],
                        y: v2.y + selection.y[i]
                    };
                    if (distToSegmentSquared({ x: this.mouse[0], y: this.mouse[1] }, v1, v2) < 3) {
                        intersectedElements.push(selection.dataElements[i]);
                        found = true;
                        break;
                    }
                }
                if (found)
                    break;
            }
            return intersectedElements;
            function sqr(x) {
                return x * x;
            }
            function dist2(v, w) {
                return sqr(v.x - w.x) + sqr(v.y - w.y);
            }
            function distToSegmentSquared(p, v, w) {
                var l2 = dist2(v, w);
                if (l2 == 0)
                    return dist2(p, v);
                var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                if (t < 0)
                    return dist2(p, v);
                if (t > 1)
                    return dist2(p, w);
                return dist2(p, { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) });
            }
            function distToSegment(p, v, w) {
                return Math.sqrt(distToSegmentSquared(p, v, w));
            }
        };
        return WebGLInteractor;
    }());
    glutils.WebGLInteractor = WebGLInteractor;
    function mouseToWorldCoordinates(mouseX, mouseY) {
        var rect = webgl.canvas.getBoundingClientRect();
        var x = webgl.camera.position.x + webgl.camera.left / webgl.camera.zoom + (mouseX - rect.left) / webgl.camera.zoom;
        var y = webgl.camera.position.y + webgl.camera.top / webgl.camera.zoom - (mouseY - rect.top) / webgl.camera.zoom;
        return [x, y];
    }
    glutils.mouseToWorldCoordinates = mouseToWorldCoordinates;
    function curve(points) {
        var arrayPoints = [];
        for (var i = 0; i < points.length; i++) {
            if (!isNaN(points[i].x))
                arrayPoints.push([points[i].x, points[i].y]);
        }
        var spline = new BSpline(arrayPoints, 3);
        var curvePoints = [];
        for (var t = 0; t <= 1; t += 0.01) {
            var p = spline.calcAt(t);
            curvePoints.push({ x: p[0], y: p[1] });
        }
        return curvePoints;
    }
    glutils.curve = curve;
    var CheckBox = (function () {
        function CheckBox() {
            var _this = this;
            this.selected = false;
            this.frame = selectAll()
                .data([0])
                .append('circle')
                .attr('r', 5)
                .style('fill', '#fff')
                .style('stroke', '#000000')
                .on('click', function () {
                _this.selected = !_this.selected;
                _this.circle.style('opacity', _this.selected ? 1 : 0);
                if (_this.changeCallBack != undefined)
                    _this.changeCallBack();
            });
            this.circle = selectAll()
                .data([0]);
        }
        CheckBox.prototype.attr = function (attrName, value) {
            switch (attrName) {
                case 'x':
                    this.frame.attr('x', value);
                    return this;
                case 'y':
                    this.frame.attr('y', value);
                    return this;
            }
        };
        CheckBox.prototype.on = function (eventType, fn) {
            switch (eventType) {
                case 'change': this.changeCallBack = fn;
            }
        };
        return CheckBox;
    }());
    glutils.CheckBox = CheckBox;
})(glutils || (glutils = {}));
var THREEx = THREEx || {};
THREEx.DynamicTexture = function (width, height) {
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    this.canvas = canvas;
    var context = canvas.getContext('2d');
    this.context = context;
    var texture = new THREE.Texture(canvas);
    this.texture = texture;
};
THREEx.DynamicTexture.prototype.clear = function (fillStyle) {
    if (fillStyle !== undefined) {
        this.context.fillStyle = fillStyle;
        this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }
    else {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    this.texture.needsUpdate = true;
    return this;
};
THREEx.DynamicTexture.prototype.drawText = function (text, x, y, fillStyle, contextFont) {
    if (contextFont !== undefined)
        this.context.font = contextFont;
    if (x === undefined || x === null) {
        var textSize = this.context.measureText(text);
        x = (this.canvas.width - textSize.width) / 2;
    }
    this.context.fillStyle = fillStyle;
    this.context.fillText(text, x, y);
    this.texture.needsUpdate = true;
    return this;
};
THREEx.DynamicTexture.prototype.drawTextCooked = function (text, options) {
    var context = this.context;
    var canvas = this.canvas;
    options = options || {};
    var params = {
        margin: options.margin !== undefined ? options.margin : 0.1,
        lineHeight: options.lineHeight !== undefined ? options.lineHeight : 0.1,
        align: options.align !== undefined ? options.align : 'left',
        fillStyle: options.fillStyle !== undefined ? options.fillStyle : 'black',
    };
    context.save();
    context.fillStyle = params.fillStyle;
    var y = (params.lineHeight + params.margin) * canvas.height;
    while (text.length > 0) {
        var maxText = computeMaxTextLength(text);
        text = text.substr(maxText.length);
        var textSize = context.measureText(maxText);
        if (params.align === 'left') {
            var x = params.margin * canvas.width;
        }
        else if (params.align === 'right') {
            var x = (1 - params.margin) * canvas.width - textSize.width;
        }
        else if (params.align === 'center') {
            var x = (canvas.width - textSize.width) / 2;
        }
        else
            console.assert(false);
        this.context.fillText(maxText, x, y);
        y += params.lineHeight * canvas.height;
    }
    context.restore();
    this.texture.needsUpdate = true;
    return this;
    function computeMaxTextLength(text) {
        var maxText = '';
        var maxWidth = (1 - params.margin * 2) * canvas.width;
        while (maxText.length !== text.length) {
            var textSize = context.measureText(maxText);
            if (textSize.width > maxWidth)
                break;
            maxText += text.substr(maxText.length, 1);
        }
        return maxText;
    }
};
THREEx.DynamicTexture.prototype.drawImage = function () {
    this.context.drawImage.apply(this.context, arguments);
    this.texture.needsUpdate = true;
    return this;
};
var geometry;
(function (geometry) {
    function length(v1) {
        return Math.sqrt(v1[0] * v1[0] + v1[1] * v1[1]);
    }
    geometry.length = length;
    function normalize(v) {
        var l = length(v);
        return [v[0] / l, v[1] / l];
    }
    geometry.normalize = normalize;
    function setLength(v, l) {
        var len = length(v);
        return [l * v[0] / len, l * v[1] / len];
    }
    geometry.setLength = setLength;
})(geometry || (geometry = {}));
(function () {
    var _traceq = _traceq || [];
    var traceUrl = "http://vizatt.saclay.inria.fr/";
    if (location.protocol == "https:") {
        traceUrl = "https://vizatt.saclay.inria.fr/";
    }
    var _sending = null;
    var sessionId;
    var starting = true;
    var debug = false;
    var pagename = null;
    trace = { version: "0.3" };
    trace.url = function (url) {
        if (!arguments.length)
            return url;
        traceUrl = url;
        return trace;
    };
    trace.sessionId = function () {
        return sessionId;
    };
    trace.debug = function (d) {
        if (!arguments.length)
            return debug;
        debug = d;
        return trace;
    };
    function getName(s) {
        return s.replace(/^.*[\\\/]/, '');
    }
    function getPageName() {
        if (pagename == null) {
            pagename = getName(document.location.pathname);
        }
        return pagename;
    }
    var uuid = function () {
        var uuid = "", i, random;
        for (i = 0; i < 32; i++) {
            random = Math.random() * 16 | 0;
            if (i == 8 || i == 12 || i == 16 || i == 20) {
                uuid += "-";
            }
            uuid += (i == 12 ? 4 : (i == 16 ? (random & 3 | 8) : random)).toString(16);
        }
        return uuid;
    };
    var sendLogs_ = function (list) {
        var httpRequest;
        if (window.XDomainRequest) {
            httpRequest = new XDomainRequest();
            httpRequest.onload = function () { sendMoreOrAgain(true); };
        }
        else if (window.XMLHttpRequest)
            httpRequest = new XMLHttpRequest();
        else
            httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
        httpRequest.onreadystatechange = function () {
            if (debug) {
                window.console && console.log("readyState =%d", httpRequest.readyState);
            }
            if (httpRequest.readyState == this.DONE) {
                if (debug) {
                    window.console && console.log("status =%d", httpRequest.status);
                }
                sendMoreOrAgain(httpRequest.status < 300);
            }
        };
        var json = JSON.stringify(list);
        httpRequest.open("POST", traceUrl, true);
        if (window.XDomainRequest) {
        }
        else if (window.XMLHttpRequest) {
            httpRequest.setRequestHeader("Content-Type", "application/json");
            httpRequest.setRequestHeader("Accept", "text/plain");
        }
        httpRequest.send(json);
    };
    var sendLogs = function () {
        if (_traceq.length == 0)
            return;
        _sending = _traceq;
        if (debug) {
            window.console && console.log("Sending %d messages", _sending.length);
        }
        _traceq = [];
        sendLogs_(_sending);
    };
    var sendMoreOrAgain = function (ok) {
        if (ok) {
            _sending = null;
            sendLogs();
        }
        else {
            if (_traceq.length != 0) {
                _sending = _sending.concat(_traceq);
                _traceq = [];
            }
            if (debug) {
                window.console && console.log("Re-sending %d messages", _sending.length);
            }
            sendLogs_(_sending);
        }
    };
    function traceMetadata(action, label, value) {
        return traceEvent("_trace", action, label, value);
    }
    function traceEvent(cat, action, label, value) {
        if (!networkcube.isTrackingEnabled())
            return;
        if (starting) {
            starting = false;
            _sending = [];
            traceEvent("_trace", "document.location", "href", document.location.href);
            traceEvent("_trace", "browser", "userAgent", navigator.userAgent);
            traceEvent("_trace", "screen", "size", "w:" + screen.width + ";h:" + screen.height);
            traceEvent("_trace", "window", "innerSize", "w:" + window.innerWidth + ";h:" + window.innerHeight);
            _sending = null;
        }
        if (debug) {
            window.console && console.log("Track[" + cat + "," + action + "," + label + "]");
        }
        var ts = Date.now();
        if (cat == null) {
            var url = parent.location.href;
            var datasetName = url.split('datasetName=')[1];
            cat = getPageName() + "/" + datasetName;
            console.log(">> CAT: " + cat);
        }
        _traceq.push({ "session": sessionId,
            "ts": ts,
            "cat": cat,
            "action": action,
            "label": label,
            "value": value });
        if (_sending == null)
            sendLogs();
        return trace;
    }
    function sendMailFunction(to, from, subject, message, cc_vistorian, blob_image, blob_svg) {
        console.log('>>>> SENDING EMAIL...');
        var formdata = new FormData(), oReq = new XMLHttpRequest();
        var date = new Date();
        var params = window.parent.location.search.replace("?", "").split('&');
        var tmp, value, vars = {};
        params.forEach(function (item) {
            console.log('item', item);
            tmp = item.split("=");
            console.log('tmp', tmp);
            value = decodeURIComponent(tmp[1]);
            vars[tmp[0]] = value;
        });
        var uid = vars['session'];
        console.log('session/userid: ' + uid);
        formdata.append("from", from);
        formdata.append("to", to);
        var url = parent.location.href;
        var datasetName = url.split('datasetName=')[1];
        console.log('datasetName:', datasetName);
        formdata.append("subject", '[Vistorian] Screenshot: ' + datasetName + ', ' + date.getDate());
        formdata.append("note", message + "\n\n(Your unique user ID is " + uid + ".)");
        if (cc_vistorian)
            formdata.append("cc", 'vistorian@inria.fr');
        if (blob_image)
            formdata.append("image", blob_image, "vistorian.png");
        if (blob_svg)
            formdata.append("svg", blob_svg, "vistorian.svg");
        if (location.protocol == "https:")
            oReq.open("POST", "https://aviz.saclay.inria.fr/sendmail/send", true);
        else
            oReq.open("POST", "http://aviz.fr/sendmail/send", true);
        oReq.send(formdata);
        console.log('>>>> EMAIL SEND');
    }
    function sendUserTrackingRegistrationFunction(email) {
        var formdata = new FormData(), oReq = new XMLHttpRequest();
        console.log('session/email: ' + email);
        formdata.append("email", email);
        if (location.protocol == "https:")
            oReq.open("POST", "https://aviz.saclay.inria.fr/sendmail/register", true);
        else
            oReq.open("POST", "http://aviz.fr/sendmail/register", true);
        oReq.send(formdata);
        console.log('>>>> EMAIL SEND');
    }
    function traceEventDeferred(delay, cat, action, label, value) {
        return window.setTimeout(function () {
            traceEvent(cat, action, label, value);
        }, delay);
    }
    function traceEventClear(id) {
        if (typeof id == "number") {
            clearTimeout(id);
        }
        return trace;
    }
    trace.event = traceEvent;
    trace.eventDeferred = traceEventDeferred;
    trace.eventClear = traceEventClear;
    trace.sendmail = sendMailFunction;
    trace.registerUser = sendUserTrackingRegistrationFunction;
    sessionId = readCookie("uuid");
    if (sessionId == null) {
        sessionId = uuid();
        createCookie("uuid", sessionId, 1);
    }
})();
function createCookie(name, value, days) {
    if (days) {
        var date = new Date();
        date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
        var expires = "; expires=" + date.toGMTString();
    }
    else
        var expires = "";
    document.cookie = name + "=" + value + expires + "; path=/";
}
function readCookie(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for (var i = 0; i < ca.length; i++) {
        var c = ca[i];
        while (c.charAt(0) == ' ')
            c = c.substring(1, c.length);
        if (c.indexOf(nameEQ) == 0)
            return c.substring(nameEQ.length, c.length);
    }
    return null;
}
function eraseCookie(name) {
    createCookie(name, "", -1);
}
trace.debug(true);
//# sourceMappingURL=networkcube.js.map